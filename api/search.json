[{"id":"d2c315dbacaf4db1404e8241080ca51e","title":"香港之旅","content":"香港之旅\n护照\n港澳通行证\n信用卡（广发，招商）\n信用卡账单\n手机卡（香港，美国，英国）\n\n香港银行卡","slug":"香港之旅","date":"2024-08-04T09:58:23.416Z","categories_index":"","tags_index":"","author_index":"暗使开开"},{"id":"def7331dff58f37eff7cfcc23979e5a9","title":"独角数卡-CentOS","content":"独角数卡-CentOShttps://github.com/assimon/dujiaoka/releasestar -xvf dujiaoka-2.0.6.tar.gz cd dujiaoka-2.0.6mkdir /usr/share/nginx/fakamv * .[^.]* /usr/share/nginx/fakacd /usr/share/nginx/fakavi .envmysql -uroot -p create database faka character set utf8mb4 collate utf8mb4_unicode_ci;sudo ln -s /usr/bin/php74 /usr/bin/phpsudo curl -sS https://getcomposer.org/installer | phpmv composer.phar /usr/local/bin/composersudo ln -s /usr/local/bin/composer /usr/bin/composerphp -vyum -y install php-bcmathcomposer install安装redisphp扩展cd /usr/local/srcwget http://pecl.php.net/get/redis-6.0.2.tgztar -zxvf redis-6.0.2.tgzcd redis-6.0.2/opt/remi/php74/root/usr/bin/phpize # **或者你自己的php目录下**/bin/phpize./configure --with-php-config=/opt/remi/php74/root/usr/bin/php-config # **你自己的php目录下**/bin/php-configmake &amp;&amp; make installvi /etc/opt/remi/php74/php.d/20-redis.iniextension=redis.so  systemctl restart php74-php-fpmsudo pip install supervisorecho_supervisord_conf &gt; /etc/supervisord.confvi /etc/supervisord.conf[include]files = /etc/supervisor/*.confmkdir /etc/supervisorsupervisord -c /etc/supervisord.conf如果提示已经有进程在运行，那么先 kill 掉它。cd /usr/share/nginx/faka/php artisan queue:workvi /etc/supervisor/faka.conf[program:laravel-worker]process_name=%(program_name)s_%(process_num)02dcommand=php /usr/share/nginx/faka/artisan queue:work --tries=3autostart=trueautorestart=trueuser=rootnumprocs=8redirect_stderr=truestdout_logfile=/var/log/supervisor/laravel-queue.logsudo supervisorctl rereadsudo supervisorctl updatesudo supervisorctl start laravel-worker:*\n\n","slug":"独角数卡","date":"2024-07-30T07:41:51.000Z","categories_index":"开发经验","tags_index":"独角数卡","author_index":"暗使开开"},{"id":"2def8f8452c229b4f9321455aa1146d4","title":"时运赋","content":"时运赋天有不测风云，人有旦夕祸福，蜈蚣百足，行不及蛇，家鸡翼大，飞不过鸦，马有千里之程，无骑不能自往，人有凌云之志，非运不能腾达。\n文章盖世，孔子厄困于陈邦；武略超群，太公垂钓于渭水。盗跖年长，不是善良之辈，颜回命短，实非凶恶之徒。尧舜至圣，却生不肖之子；瞽叟顽劣，反生大孝之儿。\n张良原是布衣，萧何称谓县吏。晏子不满五尺，使楚拜齐名相；诸葛无力缚鸡，出为蜀汉军师。冯唐有安邦之才，终身不第。李广有射虎之威，到老未封。韩信未遇之时，无一日之餐，及至遇行，腰悬三齐玉印。楚王虽雄，败于乌江自刎；汉王柔弱，竟有河山万里。满腹经纶，白发不第。才疏学浅，少年及第登科。有先富而后贫，有先贫而后富。蛟龙未遇，潜身于鱼鳖之间。君子失时，拱手于小人之下。天不得时，日月无光。地不得时，草木不长。水不得时，风浪不静。人不得时，利运不通。\n昔时，余在洛阳，日投僧院，夜宿寒窑；破衣不能遮其体，淡粥不能充其饥；上人憎，下人厌，皆言余之贱也。余曰，非吾贱也！乃时也，运也，命也。余及第登科，官至极品，位列三公；有挞百僚之杖，有斩鄙吝之剑；出则壮士执鞭，入则佳人捧觞；思衣则绫罗锦缎，思食则山珍海味；上人宠，下人拥，人皆仰慕，皆言余之贵也。余曰，非吾贵也，乃时也，运也，命也。\n盖，人生在世，富贵不可尽用，贫贱不可自欺；此乃天地循环，终而复始者也。\n","slug":"时运赋","date":"2024-07-30T07:34:51.000Z","categories_index":"修身养性","tags_index":"修身养性","author_index":"暗使开开"},{"id":"0f7187f056360c5c434c1ad57a60280d","title":"学习方法","content":"学习方法费曼学习法：不要浮躁，每个概念都清晰的用笔和纸简短的给别人讲清楚。\n","slug":"学习方法","date":"2024-07-30T07:33:39.000Z","categories_index":"随笔","tags_index":"随笔","author_index":"暗使开开"},{"id":"b7a0c97312b85aac49e7a436cf1976e7","title":"wordpress优化","content":"wordpress主题安装主题文件大小受限制\nphp.ini\n把 upload_max_filesize 和 post_max_size 修改为20M\n\n&#x2F;etc&#x2F;nginx&#x2F;nginx.conf\nclient_max_body_size 20m;\n\n\n上传主题压缩包安装或者选择网上主题进行安装\nhttp自动跳转httpsserver &#123;        listen       80;        listen       [::]:80;        server_name  star.amshadow.cn;\t\t        #把http的域名请求转成https\t\treturn 301 https://$host$request_uri;\t\t#强制将http的URL重写成https        #rewrite ^(.*) https://$server_name$1 permanent;    &#125;\n\nwordpress插件AntiVirusmanual Scan \nWordfence安全扫描\ngoogle登录验证\nWPS隐藏登录WPS CleanerWPS Bidouille加速插件\nWP Fastest Cache\nwordpress主题开发文件每个主题至少要有这两个文件 - style.css 和 index.php。index.php 告诉主题中所有的元素如何布局，style.css 则告诉主题中所有的元素该如何展示，以及它们的样式。下面是一个完整的主题含有的文件列表style.css\n\nindex.php\nhome.php\nsingle.php\npage.php\narchive.php\ncategory.php\nsearch.php\n404.php\ncomments.php\ncomments-popup.php\nauthor.php\ndate.php、\n\nWordPress 专业术语：\nTemplate（模板） — 其实就是一个代码集，主题中很多地方会利用到这个代码集，所以把它们整合成一个模板，这样就就不必一遍遍输入这些重复代码。\nTemplate file（模板文件） — 一个包含一个或者多个代码集（模板）文件。每个主题是由多个模板文件组成的，比如：index.php，style.css，sidebar.php 等等。\nTheme（主题）或者 WordPress theme（WordPress 主题） — 所有你正在使用的文件：文本，图像，代码等等。注意： WordPress theme（主题）和 WordPress template(s)（模板）是两个不同的东西，尽管有些人认为他们一样。\nPost（日志或者文章） — 现在你读的就是一篇日志。此外，它是你 blog 的一个简单的条目，如：一个页面或者一篇日记。\nPage（静态页面） — 一种特殊的 post，它不是以分类组织的。它有别于你其他的日志。注意：在 WordPress，page（页面）和 Page（静态页面）是两种不同的东西。\n\nWordPress 博客的每个页面是由多个模板文件组成的，我们可以看出主题的 index.php 是由 4 个模板文件组成： header.php，index.php，sidebar.php 和 footer.php。\nHeader 模板文件:通常在这个文件中包含博客的标题（title）和描述（description）。而且它们通常在整个博客中都是一样的。\nIndex 模板文件：这个模板文件包含你的日志的标题，日志的内容（就是每篇日志的文本和图片）和日志的元数据 （元数据是每篇日志的额外信息，如作者是谁，日志发布的时间，在哪个分类下，有多少留言等等）。\nSidebar 模板文件这个模板文件主要用于控制博客的页面列表，类别列表，存档列表，友情链接列表和其他一些列表。\nfooter.php 通常不会因为页面的改变而改变，你可以在这里放置任何东西，但是通常是版权信息。\n现在让我解释为什么把上面图片中的 index.php 所在的区域标为红色的。引文这块区域是会根据不同类型的页面而发生变化。\n如果你在单一日志页面，这时候页面将会包含这四个模板文件：header.php，**single.php**，sidebar.php 和 footer。\n优化wordpress先通过top看下信息(shift + m 会让进程按照memory排序)发现里面有大量php-fpm进程，经过查找资料发现，php-fpm 的 FastCGI 进程一旦加载就不会释放 。因此有必要先针对这个做一个优化。\nphp-fpm优化修改php-fpm文件，一般的地址是&#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf\nvi &#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf\n修改下面这几个参数，找一下就行(参考文末链接1的内容，结果参数含义如下)\n\npm：表示使用那种方式，有两个值可以选择，就是static（静态）或者dynamic（动态），默认为dynamic。\npm.max_children：静态方式下开启的php-fpm进程数量。\npm.start_servers：动态方式下的起始php-fpm进程数量。\npm.min_spare_servers：动态方式下的最小php-fpm进程数量。\npm.max_spare_servers：动态方式下的最大php-fpm进程数量。\n\npm = dynamicpm.max_children = 20pm.start_servers = 5pm.min_spare_servers = 2pm.max_spare_servers = 10pm.max_requests = 300\n\n保存，之后，重启php-fpm服务\nsystemctl restart php-fpm\n删除没用的主题删除的方法是就是进入到wordpress的themes目录比如我的是&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;wordpress&#x2F;wp-content&#x2F;themes\ncd &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;wordpress&#x2F;wp-content&#x2F;themes\n然后把theme的文件夹删除就好了， 通过rm\nmysql优化超乎寻常的有!!! 但是降低一点打开的速度，一般可以降低50%的内存消耗\n编辑 my.cnf文件vi  my.cnf\n在文末添加下面这一段 (如果你这个文件中已经有了[mysqld]\n[mysqld]performance_schema &#x3D; 0\n重启mysqld服务systemctl restart mysqld\n","slug":"wordpress优化","date":"2024-07-30T07:29:37.000Z","categories_index":"开发经验","tags_index":"wordpress","author_index":"暗使开开"},{"id":"c25419b8d02da82558175dcb4c4ab39b","title":"Wordpress-CentOS7","content":"Wordpress-CentOS7centos7安装wordpress\n安装mysql5.7mkdir /opt/mysqlcd /opt/mysqlyum -y install wgetwget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tartar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tarrpm -qa|grep mari  原本可能有的数据库 提前删干净rpm -e --nodeps mariadb-libs 删除mari相关的所有rpm -e --nodeps marisarpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm yum -y install libaio yum -y install numactl rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm --force --nodeps systemctl start mysqld.service如果报错Job for mysqld.service failed because the control process exited with error code. See &quot;systemctl status mysqld.service&quot; and &quot;journalctl -xe&quot; for details.mkdir -p /var/run/mysqld/chown mysql.mysql /var/run/mysqld///ormkdir /var/lib/mysql/datavi /etc/my.cnfdatadir=/var/lib/mysql/datasystemctl status mysqld.servicegrep &quot;password&quot; /var/log/mysqld.logmysql -uroot -pALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;@(PdpyY9%X5S4#&#x27;;ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;@(PdpyY9%X5S4#&#x27;;配置远程连接USE mysql;UPDATE mysql.user SET host = &#x27;%&#x27; WHERE user = &#x27;root&#x27;;SELECT user, host, plugin, authentication_string FROM mysql.user;FLUSH PRIVILEGES;create database star_amshadow_cn character set utf8mb4 collate utf8mb4_unicode_ci;use wordpress;quit配置开机启动启动查看MySQL是否自启：systemctl is-enabled mysqld开启自启 ：systemctl enable mysqld关闭自启 ：systemctl disable mysqldsystemctl enable mysqld.service # 开机自启动systemctl disable mysqld.service # 禁用开机自启动//如果服务器内存小可以改vi /etc/my.cnf[mysqld]performance_schema = 0systemctl restart mysqld\n\n\n\n安装mysql8wget https://repo.mysql.com//mysql80-community-release-el7-9.noarch.rpmrpm -qa |grep -i mysql如果有yum remove -y mysql*rpm -e --nodeps mysql80 ...rpm -qa | grep mariadb如果有rpm -e --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64yum install -y libaiorpm -ivh mysql80-community-release-el7-9.noarch.rpm rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2023yum -y install mysql-community-servervi /etc/my.cnf#数据库默认字符集, 主流字符集支持一些特殊表情符号（特殊表情符占用4个字节）character-set-server = utf8mb4#数据库字符集对应一些排序等规则，注意要和character-set-server对应collation-server = utf8mb4_general_ci#设置client连接mysql时的字符集,防止乱码init_connect=&#x27;SET NAMES utf8mb4&#x27;#是否对sql语句大小写敏感，1表示不敏感lower_case_table_names = 1systemctl start mysqldsystemctl status mysqldgrep &quot;password&quot; /var/log/mysqld.logmysql -uroot -pALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;;ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;;配置远程连接USE mysql;UPDATE mysql.user SET host = &#x27;%&#x27; WHERE user = &#x27;root&#x27;;SELECT user, host, plugin, authentication_string FROM mysql.user;FLUSH PRIVILEGES;create database wordpress character set utf8mb4 collate utf8mb4_unicode_ci;use wordpress;quit配置开机启动启动查看MySQL是否自启：systemctl is-enabled mysqld开启自启 ：systemctl enable mysqld关闭自启 ：systemctl disable mysqldsystemctl enable mysqld.service # 开机自启动systemctl disable mysqld.service # 禁用开机自启动mysql -V\n\n\n\n安装Nginx更新yum库备份mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak20240409wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repoyum -y install epel-releaseyum -y install nginx       systemctl start nginx       systemctl enable nginx.service      \n\n设置完成后在浏览器输入：公网ip能看到页面则表示安装成功\n修改nginx主配置文件vi /etc/nginx/nginx.conf\n#server &#123;#\t\tlisten 80;#\t\tserver_name shop.richcai.com;#\t\treturn 301 https://server_name$name$request_uri;#\t&#125;include servers/*;mkdir /etc/nginx/servers /usr/share/nginx/amshadow_cn /etc/nginx/cert传好证书vi /etc/nginx/servers/star_amshadowcn.confserver &#123;\t    listen       443 ssl http2;        listen       [::]:443 ssl http2;        server_name  star.amshadow.cn; \t\troot         /usr/share/nginx/star_amshadow_cn; \t\t\t\t#证书文件名称        ssl_certificate &quot;/etc/nginx/cert/amshadowcn.pem&quot;;        #证书私钥文件名称        ssl_certificate_key &quot;/etc/nginx/cert/amshadowcn.key&quot;;        #ssl_session_cache shared:SSL:1m;        #ssl验证配置        ssl_session_timeout  10m;        #配置加密套件/算法加密，写法遵循openssl标准        ssl_ciphers HIGH:!aNULL:!MD5;        #使用服务器端的首选算法        ssl_prefer_server_ciphers on;        #安全链接可选加密协议        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;\t\t\t\t# Load configuration files for the default server block.\t\tinclude /etc/nginx/default.d/*.conf;\t\t\tlocation / &#123;\t\t\tindex index.php index.html index.htm;\t\t\ttry_files $uri $uri/ /index.php?$args;\t\t&#125;\t\t\trewrite /wp-admin$ $scheme://$host$uri/ permanent;\t\t\tlocation ~* ^.+\\.(ogg|ogv|svg|svgz|eot|otf|woff|mp4|ttf|rss|atom|jpg|jpeg|gif|png|ico|zip|tgz|gz|rar|bz2|doc|xls|exe|ppt|tar|mid|midi|wav|bmp|rtf)$ &#123;\t\t\t\t\taccess_log off; log_not_found off; expires max;\t\t&#125;\t\t\tlocation ~ \\.php$ &#123;\t\t\ttry_files $uri =404;\t\t\tfastcgi_split_path_info ^(.+\\.php)(/.+)$;\t\t\tfastcgi_pass 127.0.0.1:9000;\t\t\tfastcgi_index index.php;\t\t\tfastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\t\t\tinclude fastcgi_params;\t\t&#125;\t&#125;------------------------------------------------------------server &#123;\t\tlisten       80 default_server;\t\tlisten       [::]:80 default_server;\t\tserver_name  39.106.159.62; # 此处修改为域名或者公网IP\t\troot         /usr/share/nginx/amshadow_cn; # 站点的目录\t\t\t# Load configuration files for the default server block.\t\tinclude /etc/nginx/default.d/*.conf;\t\t\tlocation / &#123;\t\t\tindex index.php index.html index.htm;\t\t\ttry_files $uri $uri/ /index.php?$args;\t\t&#125;\t\t\trewrite /wp-admin$ $scheme://$host$uri/ permanent;\t\t\tlocation ~* ^.+\\.(ogg|ogv|svg|svgz|eot|otf|woff|mp4|ttf|rss|atom|jpg|jpeg|gif|png|ico|zip|tgz|gz|rar|bz2|doc|xls|exe|ppt|tar|mid|midi|wav|bmp|rtf)$ &#123;\t\t\t\t\taccess_log off; log_not_found off; expires max;\t\t&#125;\t\t\tlocation ~ \\.php$ &#123;\t\t\ttry_files $uri =404;\t\t\tfastcgi_split_path_info ^(.+\\.php)(/.+)$;\t\t\tfastcgi_pass 127.0.0.1:9000;\t\t\tfastcgi_index index.php;\t\t\tfastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\t\t\tinclude fastcgi_params;\t\t&#125;\t&#125;\n\n输入：nginx -t -c /etc/nginx/nginx.conf检查配置文件重载：systemctl reload nginx\n安装php74yum install epel-releaseyum -y install http://rpms.remirepo.net/enterprise/remi-release-7.rpmyum -y install yum-utilsyum install -y php74-php-fpm php74-php-cli php74-php-bcmath php74-php-gd php74-php-json php74-php-mbstring php74-php-mcrypt php74-php-mysqlnd php74-php-opcache php74-php-pdo php74-php-pecl-crypto php74-php-pecl-mcrypt php74-php-pecl-geoip php74-php-recode php74-php-snmp php74-php-soap php74-php-xml --skip-brokenphp74 -vsystemctl start php74-php-fpmsystemctl enable php74-php-fpmreboot\n\n\n\n\n\n安装PHP8yum -y install epel-releaseyum -y install http://rpms.remirepo.net/enterprise/remi-release-7.rpmyum -y install yum-utilsyum-config-manager --enable remi-php80rpm -qa | grep phpyum remove -y php*rpm -e --nodeps yum -y install php php-cli php-common php-devel php-fpm php-gd php-intl php-mbstring php-mysqlnd php-opcache php-pdo php-pecl-apcu php-pecl-imagick php-pecl-mongodb php-pecl-redis php-pecl-xdebug php-pecl-zip php-soap php-xmlphp -vsystemctl start php-fpm systemctl enable php-fpm    # 设置开机启动reboot\n\n\n\n测试php-fpm是否安装成功输入vi /usr/share/nginx/amshadow_cn/index.php，按i进入编辑模式，输入以下内容：\n&lt;?php    echo &quot;&lt;title&gt;Test Page&lt;/title&gt;&quot;;    echo &quot;Hello World!&quot;;?&gt;\n\n在浏览器中输入http：//公网IP/index.php；如果浏览器中出现Hello World!则表示配置成功,可继续进行以下步骤，若出现文件下载弹窗，则配置失败，检查以上步骤是否出错。\n安装配置wordpress wget https://cn.wordpress.org/latest-zh_CN.tar.gz    tar zxvf latest-zh_CN.tar.gz    cd wordpress/    cp wp-config-sample.php wp-config.php   vi wp-config.php  /** The name of the database for WordPress */define(&#x27;DB_NAME&#x27;, &#x27;wordpress&#x27;); /** MySQL database username */define(&#x27;DB_USER&#x27;, &#x27;root&#x27;);  # 数据库用户名/** MySQL database password */define(&#x27;DB_PASSWORD&#x27;, &#x27;@(PdpyY9%X5S4#&#x27;);    # 数据库密码/** Database hostname */define( &#x27;DB_HOST&#x27;, &#x27;localhost/ip&#x27; );//文件最后加，不需要FTPdefine(&#x27;FS_METHOD&#x27;, &quot;direct&quot;);mv * /usr/share/nginx/star_amshadow_cn/ # 将wordpress文件移动web站点的根目录chown -Rf apache:root /usr/share/nginx/star_amshadow_cn/\n\n完成后，在浏览器中输入http://你的主机IP或者域名/wp-admin/install.php进入到wordpress的配置页面，输入网站标题，用户名和密码后，就可以进入wordpress后台管理界面，到此便大功告成。\n","slug":"wordpress","date":"2024-07-30T07:26:13.000Z","categories_index":"开发经验","tags_index":"wordpress","author_index":"暗使开开"},{"id":"cd2b63055568c6245f89eec8be1c73ff","title":"Winsodws","content":"Windows安装C语言图形库Easyx安装安装easyx\n网易云音乐狗都不用，从现在开始退坑了，害我找了半个小时错误\n#include &lt;graphics.h&gt;#include &lt;MMSystem.h&gt; //播放音乐的头文件,不能放在最上面#include &lt;stdlib.h&gt;#pragma comment(lib,&quot;winmm.lib&quot;)//pragma编程 用来加载winmm.lib库文件int main(void)&#123;\t//创建一个图形界面\tinitgraph(600, 400);\t//0表示把图片加载到默认窗口，默认输出设备是控制台\tloadimage(0,&quot;bg.jpg&quot;);//项目字符集改成使用多字节字符集\t//播放音乐\t//mciSendString(&quot;open bg.mp3 alias song&quot;, NULL, 0, NULL);\t mciSendString(&quot;play bg1.mp3 repeat&quot;,0,0,0);//如返回277可能是MP3的解码器出了问题，下载解码器解码MP3，finalcodecs        \t\t\t\t\t\t\t\t\t\t  //网易云下载的音乐虽然是MP3格式的但是在这个函数是播放不了的，因为下载的音乐其实是flac格式，所以播放不了，要在qq音乐下载才可以播放。\t\tsystem(&quot;pause&quot;);//把窗口暂停查看运行\t\tclosegraph();//把当前窗口关闭\treturn 0;&#125;\n\n\n\n\n\nnvm安装\n目录不要有空格\ncmd要用管理员启动 \nnvm list\nNvm  install\nNvm  use\n\n\n\n问题Office激活错误Error Code: 0x80080005解决方法office甚至没有提供0x80080005错误码的含义，最后在Office-Tool的Issues中找到了解决方法：https://github.com/YerongAI/Office-Tool/issues/216#issue-836891168\n删除注册表中的 KEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\SppExtComObj.exe, 重新激活即可\n清除office激活秘钥方法1、CMD管理员身份运行2、找到OFFICE安装目录C:\\Program Files (x86)\\Microsoft Office\\Office16 回车3、cmd窗口内运行CD C:\\Program Files (x86)\\Microsoft Office\\Office1 6回车4、cmd窗口运行cscript ospp.vbs &#x2F;dstatus 回车，查看激活秘钥秘钥后5位5、cmd窗口运行cscript ospp.vbs &#x2F;unpkey:XXXXX 回车（X代表秘钥后5位）6、cmd窗口运行cscript ospp.vbs &#x2F;remhst 回车，刷新激活状态7、cmd窗口运行cscript ospp.vbs &#x2F;dstatus 回车，重新查看激活状态若有多个秘钥需要卸载可重复上述步骤\nHexo报错解决运行Hexo报错hexo : 无法加载文件hexo.ps1，因为在此系统上禁止运行脚本\n设置-&gt;隐私和安全性-&gt;开发者选项-&gt;允许本地PowerShell脚本在为签名的情况下运行\n知识查看ipipconfig\n\n查看端口占用查看占用端口netstat -aon|findstr &quot;port&quot;  查看占用端口号的程序tasklist|findstr &quot;PID&quot;   杀死占用端口程序 taskkill /F /IM 进程名.exetaskkill /F /PID PID\n\n\n\n添加启动自动运行应用\n选择“开始”按钮 ，然后滚动查找你希望在启动时运行的应用。\n右键单击该应用，选择“更多”，然后选择“打开文件位置”。此操作会打开保存应用快捷方式的位置。如果没有“打开文件位置”选项，这意味着该应用无法在启动时运行。\n文件位置打开后，按 Windows 徽标键 + R，键入“shell:startup”，然后选择“确定”。这将打开“启动”文件夹。\n将该应用的快捷方式从文件位置复制并粘贴到“启动”文件夹中。\n\n光标移动快捷键1、基本操作快捷键Ctrl + Z：  撤销Ctrl + Y：  重做Ctrl + S：  保存Ctrl + F：  查找Ctrl + F3：  查找上一个F3：  查找下一个Ctrl + R：  替换\n2、光标选中快捷键Shift + ← &#x2F; → (方向键)：  光标向左&#x2F;向右选中一个字符Ctrl + Shift + ← &#x2F; → (方向键)：  光标向左&#x2F;向右选中一个单词Shift + Home：  光标从当前位置一直选中到行首Shift + End：  光标从当前位置一直选中到行尾\n3、光标跳转快捷键Home：  光标跳转至行首End：   光标跳转至行尾PgUp：  光标跳转至首行PgDn：  光标跳转至末行Ctrl + ← &#x2F; → (方向键)：  光标向左&#x2F;向右跳转一个单词Ctrl + Home：  光标跳转至首行首个字符前面(文件开头)Ctrl + End：  光标跳转至末行最后一个字符后面(文件结尾)\ncapsLock键切换中英文使用autohotkey 做了热键配置\n.ahk文件代码如下：\nSetStoreCapslockMode, offCapsLock::If StartTime    returnStartTime := A_TickCountreturnCapsLock up::TimeLength := A_TickCount - StartTimeif (TimeLength &gt;= 1 and TimeLength &lt; 200)&#123;    Send, ^&#123;Space&#125;&#125;else if (TimeLength &gt;= 200)&#123;    Send, &#123;CapsLock&#125;&#125;StartTime := &quot;&quot;return\n\n上述代码效果是：长按CapsLock键锁定大写,敲击CapsLock进行切换中英文（替代了ctrl+空格的效果）\n设置步骤：\n1：下载并安装autohotkey；\n2：将中英文切换按键设置改为ctrl+space（即ctrl+空格），shift切换勾选去掉；\n3：保存上述代码为.ahk文件设置为开机启动（以管理员执行）；\n以上。\nVSCode 添加右键菜单命令第一步：win+R 输入regedit，打开注册表编辑器第二步：添加右键文件VSCode打开命令\n依次找到 HKEY_CLASSES_ROOT &gt; * &gt; shell &gt; VSCode(若无手动新建.项),点击VSCode文件夹，双击右侧默认在弹出对话框的数值数据选项中键入命令名称，如 Open with VSCode\n添加命令图标，右键VSCode文件夹，新建字符串值，双击修改新值名称为 Icon(首字母大写i)，数值数据选项粘贴上VSCode文件所在位置路径，如 D:\\develop\\VSCode-win32-x64-1.46.1\\Code.exe\n右键VSCode，新建项，名称为 command ,双击默认，在数值数据中键入VSCode文件所在位置+空格+”%1” 如 D:\\develop\\VSCode-win32-x64-1.46.1\\Code.exe “%1”\n此时右键文件查看命令是否好用，是否有图标\n\n第三步：添加右键文件夹VSCode打开命令\n依次找到 HKEY_CLASSES_ROOT &gt; Directory &gt; shell &gt; VSCode\n添加操作同上\n\n第四步：添加右键桌面VSCode打开命令\n依次找到 HKEY_CLASSES_ROOT &gt; Directory &gt; Background &gt; shell &gt; VSCode\n添加操作同上\n注意：command的数值数据中空格后面要用”%V”\n\n关闭Win10自动更新一、禁用Windows Update服务1、同时按下键盘 Win + R，打开运行对话框，然后输入命令 services.msc ，点击下方的“确定”打开服务。\n2、找到 Windows Update 这一项，并双击打开。\n\n3、双击打开它，点击“停止”，把启动类型选为“禁用”，最后点击应用。\n4、接下再切换到“恢复”选项，将默认的“重新启动服务”改为“无操作”，然后点击“应用”“确定”。\n二、在组策略里关闭Win10自动更新相关服务1、同时按下Win + R 组合快捷键打开运行命令操作框，然后输入“gpedit.msc”，点击确定。\n2、在组策略编辑器中，依次展开 计算机配置 -&gt; 管理模板 -&gt; Windows组件 -&gt; Windows更新\n\n3、然后在右侧“配置自动更新”设置中，将其设置为“已禁用”并点击下方的“应用”然后“确定”。\n4、之后还需要再找到“删除使用所有Windows更新功能的访问权限”，选择已启用，完成设置后，点击“应用”“确定”。\n三、禁用任务计划里边的Win10自动更新1、同时按下 Win + R 组合快捷键打开““运行”窗口，然后输入“taskschd.msc”，并点击下方的“确定”打开任务计划程序。\n\n2、在任务计划程序的设置界面，依次展开 任务计划程序库 -&gt; Microsoft -&gt; Windows -&gt; WindowsUpdate，把里面的项目都设置为 [ 禁用 ] 就可以了。(我这里边只有一个任务，你的电脑里可能会有2个或者更多，全部禁用就行了)\n四、在注册表中关闭Win10自动更新1、同时按下 Win + R 组合快捷键，打开运行对话框，然后输入命名 regedit，然后点击下方的「 确定 」打开注册表。\n2、在注册表设置中，找到并定位到 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\UsoSvc]。然后在右侧找到“Start”键。\n\n3、点击修改，把start值改成16进制，值改为“4”，然后点击「 确定 」保存数据\n4、继续在右侧找到“FailureActions”键，右键点击修改该键的二进制数据，将“0010”、“0018”行的左起第5个数值由原来的“01”改为“00”，完成后，点击下方的“确定”即可。\n\n至此彻底关闭win10自动更新的操作步骤就全部完成了\ngit上传图片到GitHub 得到cdn连接加速\ngit clone ssh链接需要电脑公钥 &#x2F;&#x2F;关联GitHub库\n上传图片文件\ngit status &#x2F;&#x2F;查看状态\ngit add\ngit commit -m ‘提交信息’\ngit push\n在GitHub上发布版本\nhttps://cdn.jsdelivr.net/gh/user/库名@版本号/文件路径\n文件不能超过50M\n\n","slug":"winsodws","date":"2024-07-30T07:24:24.000Z","categories_index":"操作系统","tags_index":"Windows","author_index":"暗使开开"},{"id":"aa27a901d34fd36607694c5571971888","title":"Mac","content":"Mac安装​\tsudo spctl –master-disable\nMac安装MySQL8vi ~/.bash_profileexport PATH=$&#123;PATH&#125;:/usr/local/mysql/bin/\n\nsource ~/.zshrc   # If you use Oh-My-Zshsource ~/.bashrc  # If you use Default Bash\n\n\n\nMac10.14.6安装Xcode11.3.1把系统时间设定为距离今日的前一个月或者更多，然后再去解压，注意在解压成功，并install 这段时间里不要把系统时间调回去，等install完成后，再把系统时间还原，否则install会报错。\nMac安装brewhttps://brew.sh/\n/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;\n\n\n\nMac安装dartbrew tap dart-lang/dartbrew install dartbrew info dart\n\nIdea 安装插件 dart\nMac安装electronnpm install -g cnpm --registry=https://registry.npmmirror.comcnpm install --save-dev electron\n\n\n\n\n\nMac安装Flask,requests进行节点间的通讯\npipenv install flask==0.12.2\n\n请求和发送包的库\npipenv install requests==2.18.4\n\n\n\n\n\nMac使用gitbrew install gitgitgit config --global user.name &quot;AsherJw&quot;git config --global user.email &quot;china_lijialin@outlook.com&quot;git config --list\n\n\n\nMac安装使用nvmbrew install nvmecho &quot;source $(brew --prefix nvm)/nvm.sh&quot; &gt;&gt; .bash_profile. ~/.bash_profile常用命令1. nvm list 是查找本电脑上所有的node版本    - nvm list 查看已经安装的版本    - nvm list installed 查看已经安装的版本    - nvm list available 查看网络可以安装的版本2. nvm install &lt;version&gt; 安装指定版本node3. nvm use &lt;version&gt; 切换使用指定的版本node4. nvm ls 列出所有版本5. nvm current显示当前版本6. nvm alias &lt;name&gt; &lt;version&gt; ## 给不同的版本号添加别名7. nvm unalias &lt;name&gt; ## 删除已定义的别名8. nvm reinstall-packages &lt;version&gt; ## 在当前版本node环境下，重新全局安装指定版本号的npm包9. nvm on 打开nodejs控制10. nvm off 关闭nodejs控制11. nvm proxy 查看设置与代理12. nvm node_mirror [url] 设置或者查看setting.txt中的node_mirror，如果不设置的默认是 https://nodejs.org/dist/　　nvm npm_mirror [url] 设置或者查看setting.txt中的npm_mirror,如果不设置的话默认的是： https://github.com/npm/npm/archive/.13. nvm uninstall &lt;version&gt; 卸载制定的版本14. nvm use [version] [arch] 切换制定的node版本和位数15. nvm root [path] 设置和查看root路径16. nvm version 查看当前的版本\n\nMac安装node.jsnvm install 14.19.3nvm alias default vnode -vnpm get registrynpm config set registry http://registry.npm.taobao.org\n\n\n\n\n\nMac安装pipenvpip使用来安装python包的工具\npipenv为每一个项目提供一个单独的python运行环境\npip3 install pipenv使用pipenv --python=python3\n\n\n\nMac安装配置Java环境安装jdk后\nvim .bash_profileexport JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_281.jdk/Comtents/Homejava -version\n\n\n\n\n\n问题Mac关闭chrome更新提示cd ~/Library/Google  sudo chown root:wheel GoogleSoftwareUpdate\n\n\n\nMac解决系统更新提示终端输入：\nsudo softwareupdate --ignore &quot;macOS Mojave”defaults write com.apple.systempreferences AttentionPrefBundleIDs 0killall Dock\n\n强制永久解决方案如果想永久生效，我们必须把每次开机加载的系统自动更新进程干掉才行。\n​\t\t\t此方案采用禁止权限的思路，在终端输入以下命令，强制吊销系统更新通知权限。但是这样会禁用系统更新的自启权限，阻碍正常的系统更新通知，请慎用。\nsudo mount -uw /sudo chmod 600 /System/Library/PrivateFrameworks/SoftwareUpdate.framework/Versions/A/Resources/SoftwareUpdateNotificationManager.app/Contents/MacOS/SoftwareUpdateNotificationManagerdefaults write com.apple.systempreferences AttentionPrefBundleIDs 0killall Dock\n\n注意提示:Operation not permitted，解决方式是\n\n重启同时按cmd+r 在恢复模式中打开终端， 执行 csrutil disable 关闭SIP功能\n再次正常重新启动，就可以执行「sudo mount -uw &#x2F;」 和后面的命令了\n执行完之后，别忘记再次重启进入恢复模式，执行csrutil enable，把SIP功能打开\n\n系统自动更新如果你已经禁止了系统自动更新提示进程的权限，又后悔了，想要恢复，只需要输入以下命令即可：\nsudo mount -uw /sudo chmod 777 /System/Library/PrivateFrameworks/SoftwareUpdate.framework/Versions/A/Resources/SoftwareUpdateNotificationManager.app/Contents/MacOS/SoftwareUpdateNotificationManagerdefaults write com.apple.systempreferences AttentionPrefBundleIDs 0killall Dock\n\n\n\n\n\n知识查看ipifconfig\n\n\n\nMac的SIP系统完整性查看是否开启​\t\t打开终端​\t\t\tcsrutil status​\t\t已打开​\t\t\tSystem Integrity Protection status: enabled.​\t\t已关闭​\t\t\tSystem Integrity Protection status: disabled\n开关\n重启电脑，开机过程中按住 Command + R 组合键，直到出现苹果Logo\n点击「实用工具」，选择「终端」csrutil disable           csrutil enable\n\n启用root用户​\t用户群租，登陆选项，网络账户服务器，打开实用工具，top栏编辑，启用root用户\n文件操作​\t文件路径复制​\t\toption+command+c​\t文件路径搜索​\t\tshift+command+g​\t文件详情​\t\tcommand+i​\t隐藏文件​\t\tshift+command+.\n输入法​\t翻页选词：{ }​\t中英文数字混合输入：shift+字母 option+数字​\t拆字输入：输入拆字后 shift+空格​\t标志声调：添加ABC扩展，在这种输入法下 先输入option+AEV～是四个声调 ā​\tEmoji：command+空格+control😍\n三指拖拽​\t辅助功能，鼠标触控板，触控板选项，启动拖拽，三指拖拽\n任意来源​\tsudo spctl –master-disable\n删除1、使用键盘快捷键Command+Delete将直接删除文件而不用确认，使用该快捷键删除的文件可以从废纸篓恢复。\n2、使用键盘快捷键Command+Option+Delete立即删除文件。使用此快捷方式删除选定文件而不将其发送到废纸篓。该项目将立即被删除，无法撤消。\n3、使用键盘快捷键Command+Shift+Delete清空废纸篓。使用此快捷方式清空垃圾箱文件夹。\n4、功能 (Fn) + Delete –此键允许您删除光标后或光标右侧的文本（向前删除）。\n5、Control + D –如果您的键盘没有Delete键，请使用此组合。这将删除光标后的文本（向前删除）。\n6、**功能 (Fn)+Option +Delete-**此组合键删除光标后的整个单词（仅单词）（向前删除）。\n隐藏文件defaults write com.apple.finder AppleShowAllFiles -boolean false;killall Finderdefaults write com.apple.finder AppleShowAllFiles -boolean true;killall Finder\n\nMac终端设置zsh引入bash_profile执行vi ~/.zshrc打开.zshrc,将 source ~/.bash_profile 粘贴到最下面，保存即可\n\n终端隐藏计算机名称若shell为zshsudo vi /etc/zshrc# PS1=&quot;%n@%m %1~ %# &quot;PS1=&quot;%1~ %# &quot;:wq!若shell为bashsudo vim /etc/bashrc# PS1=&#x27;\\h:\\W \\u\\$ &#x27;PS1=&#x27;\\W \\$ &#x27;:wq!\n\nShell更改为Bashchsh -s /bin/bashchsh -s /bin/zsh\n\n\n\n\n\nMac tips签名xcode-select –installsudo codesign –force –deep –sign -输入法翻页选词：{ }中英文数字混合输入：shift+字母option+数字  \n拆字输入：输入拆字后 shift+空格标志声调：添加ABC扩展，在这种输入法下 先输入option+AEV～是四个声调 āEmoji：command+空格+control😍任意来源sudo spctl –master-disable解决系统更新提示终端输入：sudo softwareupdate –ignore “macOS Mojave”defaults write com.apple.systempreferences AttentionPrefBundleIDs 0killall Dock强制永久解决方案如果想永久生效，我们必须把每次开机加载的系统自动更新进程干掉才行。此方案采用禁止权限的思路，在终端输入以下命令，强制吊销系统更新通知权限。但是这样会禁用系统更新的自启权限，阻碍正常的系统更新通知，请慎用。sudo mount -uw &#x2F;sudo chmod 600 &#x2F;System&#x2F;Library&#x2F;PrivateFrameworks&#x2F;SoftwareUpdate.framework&#x2F;Versions&#x2F;A&#x2F;Resources&#x2F;SoftwareUpdateNotificationManager.app&#x2F;Contents&#x2F;MacOS&#x2F;SoftwareUpdateNotificationManagerdefaults write com.apple.systempreferences AttentionPrefBundleIDs 0killall Dock注意提示:Operation not permitted，解决方式是1. 重启同时按cmd+r  在恢复模式中打开终端， 执行 csrutil disable 关闭SIP功能2. 再次正常重新启动，就可以执行「sudo mount -uw &#x2F;」  和后面的命令了3. 执行完之后，别忘记再次重启进入恢复模式，执行csrutil enable，把SIP功能打开如果你已经禁止了系统自动更新提示进程的权限，又后悔了，想要恢复，只需要输入以下命令即可：sudo mount -uw &#x2F;sudo chmod 777 &#x2F;System&#x2F;Library&#x2F;PrivateFrameworks&#x2F;SoftwareUpdate.framework&#x2F;Versions&#x2F;A&#x2F;Resources&#x2F;SoftwareUpdateNotificationManager.app&#x2F;Contents&#x2F;MacOS&#x2F;SoftwareUpdateNotificationManagerdefaults write com.apple.systempreferences AttentionPrefBundleIDs 0killall Dock文件操作文件路径复制option+command+c文件路径搜索shift+command+g文件详情command+i隐藏文件shift+command+.SIP系统完整性查看是否开启打开终端csrutil status已打开System Integrity Protection status: enabled.已关闭System Integrity Protection status: disabled开关重启电脑，开机过程中按住 Command + R 组合键，直到出现苹果Logo点击「实用工具」，选择「终端」csrutil disablecsrutil enableJava环境配置第一次配置环境变量touch .bash_profileopen -e .bash_profileJAVA_HOME&#x3D;&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_40.jdk&#x2F;Contents&#x2F;HomePATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH:.CLASSPATH&#x3D;$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:.export JAVA_HOMEexport PATHexport CLASSPATH  \nsource .bash_profileecho $JAVA_HOME三指拖拽辅助功能，鼠标触控板，触控板选项，启动拖拽Mac启用root用户用户群租，登陆选项，网络账户服务器，打开实用工具，top栏编辑，启用root用户","slug":"mac","date":"2024-07-30T07:22:11.000Z","categories_index":"操作系统","tags_index":"MacOS","author_index":"暗使开开"},{"id":"3fe1ee3f3830128bf539e5f4ed9fbbe9","title":"Linux","content":"Linux知识开机自启动vi /etc/rc.local#giteasu - git -c &quot;GITEA_WORK_DIR=/var/lib/gitea/ /usr/local/bin/gitea web -c /etc/gitea/app.ini&quot;chmod +x /etc/rc.d/rc.local\n\n\n\n解压缩gzip&#x2F;gunzip 指令gzip 用于压缩文件， gunzip 用于解压的\ngzip 文件 （功能描述：压缩文件，只能将文件压缩为*.gz 文件）\ngunzip 文件.gz （功能描述：解压缩文件命令）\n案例 1: gzip 压缩， 将 &#x2F;home 下的 hello.txt 文件进行压缩\ngzip &#x2F;home&#x2F;hello.txt\n案例 2: gunzip 压缩， 将 &#x2F;home 下的 hello.txt.gz 文件进行解压缩\ngunzip &#x2F;home&#x2F;hello.txt.gz\nzip&#x2F;unzip 指令zip 用于压缩文件， unzip 用于解压的，这个在项目打包发布中很有用的\nzip [选项] XXX.zip 将要压缩的内容（功能描述：压缩文件和目录的命令）\nunzip [选项] XXX.zip （功能描述：解压缩文件）\nzip 常用选项\n-r：递归压缩，即压缩目录\nunzip 的常用选项\n-d&lt;目录&gt; ：指定解压后文件的存放目录\n应用实例\n案例 1: 将 &#x2F;home 下的 所有文件&#x2F;文件夹进行压缩成 myhome.zip\nzip -r myhome.zip &#x2F;home&#x2F; [将 home 目录及其包含的文件和子文件夹都压缩] 案例 2: 将 myhome.zip 解压到 &#x2F;opt&#x2F;tmp 目录下\nmkdir &#x2F;opt&#x2F;tmp\nunzip -d &#x2F;opt&#x2F;tmp &#x2F;home&#x2F;myhome.zip\ntar 指令tar 指令 是打包指令，最后打包后的文件是 .tar.gz 的文件。\ntar [选项] XXX.tar.gz 打包的内容 (功能描述：打包目录，压缩后的文件格式.tar.gz)\n\n\n\n选项\n功能\n\n\n\n-e\n产生.tar打包文件\n\n\n-v\n显示详细信息\n\n\n-f\n指定压缩后的文件名\n\n\n-z\n打包同时压缩\n\n\n-x\n解包.tar文件\n\n\n案例 1: 压缩多个文件，将 &#x2F;home&#x2F;pig.txt 和 &#x2F;home&#x2F;cat.txt 压缩成 pc.tar.gz tar -zcvf pc.tar.gz &#x2F;home&#x2F;pig.txt &#x2F;home&#x2F;cat.txt\n案例 2: 将&#x2F;home 的文件夹 压缩成 myhome.tar.gz tar -zcvf myhome.tar.gz &#x2F;home&#x2F;\n案例 3: 将 pc.tar.gz 解压到当前目录\ntar -zxvf pc.tar.gz\n案例4: 将myhome.tar.gz 解压到 &#x2F;opt&#x2F;tmp2 目录下 (1) mkdir &#x2F;opt&#x2F;tmp2 (2) tar -zxvf &#x2F;home&#x2F;myhome.tar.gz -C &#x2F;opt&#x2F;tmp2\n静态库和动态库https://blog.csdn.net/Pxx520Tangtian/article/details/122931769\n帮助指令man 获得帮助信息基本语法：man [命令或配置文件]（功能描述：获得帮助信息）\nhelp 指令基本语法：help 命令 （功能描述：获得 shell 内置命令的帮助信息）\n软链接 ln 指令软链接也称为符号链接，类似于 windows 里的快捷方式，主要存放了链接其他文件的路径ln -s [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接）\n案例 1: 在&#x2F;home 目录下创建一个软连接 myroot，连接到 &#x2F;root 目录\nln -s &#x2F;root &#x2F;home&#x2F;myroot\n案例 2: 删除软连接 myroot\nrm &#x2F;home&#x2F;myroot\n当我们使用 pwd 指令查看目录时，仍然看到的是软链接所在目录。\n搜索文件和文件中的内容findfind 目录名 -name 文件名 -print\n从&#x2F;tmp目录开始搜索，把全部的*.c文件显示出来。\nfind &#x2F;tmp -name *.c -print\n\n\n\n选项\n功能\n\n\n\n-name\n按照指定的文件名查找模式查找文件\n\n\n-user\n查找属于指定用户名的所有文件\n\n\n-size\n按照指定的囚犯们大小查找文件\n\n\n案例 1: 按文件名：根据名称查找&#x2F;home 目录下的 hello.txt 文件\nfind &#x2F;home -name hello.txt\n案例 2：按拥有者：查找&#x2F;opt 目录下，用户名称为 nobody 的文件\nfind &#x2F;opt -user nobody\n案例 3：查找整个 linux 系统下大于 200M 的文件（+n 大于 -n 小于 n 等于, 单位有 k,M,G）find &#x2F; -size +200M\nlocateyum -y install mlocate\nlocate 指令可以快速定位文件路径。locate 指令利用事先建立的系统中所有文件名称及路径的 locate 数据库实现快速定位给定的文件。Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新 locate 时刻\nupdatedb\nlocate 搜索文件\n由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库。\n案例 1: 请使用 locate 指令快速定位 hello.txt 文件所在目录\nwhich可以查看某个指令在哪个目录下，比如 ls 指令在哪个目录\nwhich ls\ngrep 和 管道符号 |grep 过滤查找 ， 管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。\ngrep [选项] 查找内容 源文件\n-n 显示匹配行及行号\n-i 忽略字母大小写\n案例 1: 请在 hello.txt 文件中，查找 “yes” 所在行，并且显示行号\n写法 1: cat &#x2F;home&#x2F;hello.txt | grep “yes”\n写法 2: grep -n “yes” &#x2F;home&#x2F;hello.txt\n显示文本文件的内容catcat 文件名\nmoremore 文件名\n按空格键显示下一页，按b键显上一页，按q键退出。\ntailtail 文件 （功能描述：查看文件尾 10 行内容）\ntail -n 5 文件 （功能描述：查看文件尾 5 行内容，5 可以是任意行数）\ntail -f 文件 （功能描述：实时追踪该文档的所有更新）\nheadhead 文件 (功能描述：查看文件头 10 行内容)\nhead -n 5 文件 (功能描述：查看文件头 5 行内容，5 可以是任意行数)\nlessless 文件名\n\n\n\n操作\n功能说明\n\n\n\n空格\n向下翻动一页\n\n\npagedown\n向下翻动一页\n\n\npageup\n向上翻动一页\n\n\n&#x2F;或者？字符\n向下搜索字串，n向下找，N向上找\n\n\nq\n离开less这个程序\n\n\nwc统计文本文件的行数、单词数和字节数\nwc 文件名\n文件行数 文件字数 文件大小\nlinux修改ssh端口centos修改ssh端口vi /etc/ssh/sshd_configPort 端口号systemctl restart sshd\n\ndebian修改ssh端口vi /etc/ssh/sshd_configPort 端口号service ssh restart \n\nubuntu修改ssh端口vi /etc/ssh/sshd_configPort 端口号service ssh restart \n\n\n\n\n\nRPM、YUM、wgetrpm 包的管理rpm 用于互联网下载包的打包及安装工具，它包含在某些 Linux 分发版中。它生成具有.RPM 扩展名的文件。RPM 是 RedHat Package Manager（RedHat 软件包管理工具）的缩写，类似 windows 的 setup.exe，这一文件格式名称虽然打上了 RedHat 的标志，但理念是通用的。\nLinux 的分发版本都有采用（suse,redhat, centos 等等），可以算是公认的行业标准了。\nrpm 包的简单查询指令查询已安装的 rpm 列表\nrpm –qa|grep xx\n\n举例： 看看当前系统，是否安装了 firefox 指令: rpm -qa | grep firefox\nrpm 包名基本格式一个 rpm 包名：firefox-60.2.2-1.el7.centos.x86_64 名称:firefox\n版本号：60.2.2-1\n适用操作系统: el7.centos.x86_64\n表示 centos7.x 的 64 位系统\n如果是 i686、i386 表示 32 位系统，noarch 表示通用\nrpm 包的其它查询指令：rpm -qa :查询所安装的所有 rpm 软件包\nrpm -qa | more\nrpm -qa | grep X [rpm -qa | grep firefox ]\nrpm -q 软件包名 :查询软件包是否安装案例：rpm -q firefox\nrpm -qi 软件包名 ：查询软件包信息案例: rpm -qi firefox\nrpm -ql 软件包名 : 查询软件包中的文件比如： rpm -ql firefox\nrpm -qf 文件全路径名 查询文件所属的软件包\nrpm -qf &#x2F;etc&#x2F;passwd rpm -qf &#x2F;root&#x2F;install.log\n卸载rpm 包：\n基本语法\n\nrpm -e RPM 包的名称 &#x2F;&#x2F;erase\n\n应用案例\n\n删除 firefox 软件包\nrpm -e firefox\n\n细节讨论\n\n\n如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息。如： $ rpm -e foo\n\nremoving these packages would break dependencies:foo is needed by bar-1.0-1\n\n如果我们就是要删除 foo 这个 rpm 包，可以增加参数 –nodeps ,就可以强制删除，但是一般不推荐这样做，因为依赖于该软件包的程序可能无法运行。如：$ rpm -e –nodeps foo\n\n安装rpm 包\n基本语法\n\nrpm -ivh RPM 包全路径名称\n\n参数说明\n\ni&#x3D;install 安装\nv&#x3D;verbose 提示\nh&#x3D;hash 进度条\n\n应用实例\n\n演示卸载和安装 firefox 浏览器\nrpm -e firefox\nrpm -ivh firefox\nyumYum 是一个 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。\nyum 的基本指令查询 yum 服务器是否有需要安装的软件\nyum list|grep xx 软件列表\n安装指定的yum 包yum install xxx 下载安装\nyum -y install xxx 自动同意询问\nyum 应用实例：案例：请使用 yum 的方式来安装 firefox\nrpm -e firefox\nyum list | grep firefox\nyum install firefox\nwgetwget 链接 下载文件\nubuntu系统ssh服务终端输入ifconfig查看ip\n\n进入root用户模式：\n执行命令： apt-get install ssh（安装ssh服务）\napt-get install vim（安装vim编辑器）\nvi &#x2F;etc&#x2F;ssh&#x2F;sshd_config (更改SSH服务的配置文件，允许远程登录root)\n将PermitRootLogin 的值设为 yes\n\nubuntu终端下MySQL输入中文\n编辑mysql.cnf文件首先编辑&#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;mysql.cnf文件,应当无内容\n\n编辑mysqld.cnf文件\n\n\nvi &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf\n在[mysqld]下加入character-set-server&#x3D;utf8\n\n重启服务器sudo &#x2F;etc&#x2F;init.d&#x2F;mysql restart\n\nubuntu的默认root密码设置一、Ubuntu的默认root密码是随机的，即每次开机都有一个新的root密码。可以在终端输入命令 sudo passwd，然后输入当前用户的密码，enter.\n二、终端会提示输入新的密码并确认，此时的密码就是root新密码。修改成功后，输入命令 su root，再输入新的密码就ok了。\n找回Linux root密码\n启动系统，进入开机界面，在界面中按“e”进入编辑界面。\n进入编辑界面，使用键盘上的上下键把光标往下移动，找到以““Linux16”开头内容所在的行数”，在行的最后面输入：init&#x3D;&#x2F;bin&#x2F;sh。\n输入完成后，直接按快捷键：Ctrl+x 进入单用户模式。\n在光标闪烁的位置中输入：mount -o remount,rw &#x2F;（注意：各个单词间有空格），完成后按键盘的回车键（Enter）。\n在新的一行最后面输入：passwd， 完成后按键盘的回车键（Enter）。输入密码，然后再次确认密码即可, 密码修改成功后，会显示passwd…..的样式，说明密码修改成功\n在鼠标闪烁的位置中（最后一行中）输入：touch &#x2F;.autorelabel（注意：touch与 &#x2F;后面有一个空格），完成后按键盘的回车键（Enter）\n继续在光标闪烁的位置中，输入：exec &#x2F;sbin&#x2F;init（注意：exec与 &#x2F;后面有一个空格），完成后按键盘的回车键（Enter）,等待系统自动修改密码，完成后，系统会自动重启, 新的密码生效了\n\nLinux运行级别基本介绍运行级别说明：\n0 ：关机\n1 ：单用户【找回丢失密码】\n2：多用户状态没有网络服务\n3：多用户状态有网络服务\n4：系统未使用保留给用户\n5：图形界面\n6：系统重启\n常用运行级别是 3 和 5 ，也可以指定默认运行级别\n命令：init [0123456] 通过 init 来切换不同的运行级别\ncentos7 后运行级别说明在 centos7 以前， &#x2F;etc&#x2F;inittab 文件中 .\n进行了简化 ，如下:\nmulti-user.target: analogous to runlevel 3 graphical.target: analogous to runlevel 5 # To view current default target, run: systemctl get-default# To set a default target, run:systemctl set-default TARGET.target\n\n\n\nLinux目录结构在 Linux 世界里，一切皆文件\n\n&#x2F;bin [常用] (&#x2F;usr&#x2F;bin 、 &#x2F;usr&#x2F;local&#x2F;bin) 是 Binary 的缩写, 这个目录存放着最经常使用的命令\n\n&#x2F;sbin (&#x2F;usr&#x2F;sbin 、 &#x2F;usr&#x2F;local&#x2F;sbin) s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。\n\n&#x2F;home [常用] 存放普通用户的主目录，在 Linux 中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名\n\n&#x2F;root [常用] 该目录为系统管理员，也称作超级权限者的用户主目录\n\n&#x2F;lib 系统开机所需要最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库\n\n&#x2F;lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件\n\n&#x2F;etc [常用] 所有的系统管理所需要的配置文件和子目录, 比如安装 mysql 数据库 my.conf\n\n&#x2F;usr [常用] 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与 windows 下的 program files 目录。\n\n&#x2F;boot [常用] 存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件\n\n&#x2F;proc [不能动] 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息\n\n&#x2F;srv [不能动] service 缩写，该目录存放一些服务启动之后需要提取的数据\n\n&#x2F;sys [不能动]这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs &#x3D;》【别动】\n\n&#x2F;tmp 这个目录是用来存放一些临时文件的\n\n&#x2F;dev 类似于 windows 的设备管理器，把所有的硬件用文件的形式存储\n\n&#x2F;media [常用] linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下\n\n&#x2F;mnt [常用] 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看里的内容了。 d:&#x2F;myshare\n\n&#x2F;opt 这是给主机额外安装软件所存放的目录。如安装 ORACLE 数据库就可放到该目录下。默认为空\n\n&#x2F;usr&#x2F;local [常用]这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序\n\n&#x2F;var [常用]这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件\n\n&#x2F;selinux [security-enhanced linux]SELinux 是一种安全子系统,它能控制程序只能访问特定文件, 有三种工作模式，可以自行设置.\n\n\n安装centos安装使用Ftp安装ftp在CentOS7中，采用yum来安装ftp软件包，包括ftp服务器和ftp客户端。如果已经安装，再次执行yum就会把软件包升级到最新版本。\n1、安装ftp服务器yum -y install vsftpd\n2、安装ftp客户端yum -y install ftp\n配置ftp服务器ftp的传输模式有被动模式和主动式两种，缺省是被动模式，主动模式的应用场景极少，为了方便表达，在接下来的内容中只介绍被动模式，主动模式在本文中也有介绍。\n1、关闭SELINUXvi /etc/selinux/configSELINUX =disabledsetenforce 0\n\n2、配置ftp数据端口参数ftp的数据端口也称为高端口，在&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf文件中配置，由pasv_min_port和pasv_max_port两个参数指定，如果文件中没有这两个参数，手工的加进去。\nvi /etc/vsftpd/vsftpd.conflisten=YES listen_ipv6=NOpasv_address=&lt;EIP&gt;pasv_min_port=5000  # 高端口范围的最小值。pasv_max_port=5500  # 高端口范围的最大值。\n\n3、开通防火墙开通防火墙的方法有两种：\n1）开通ftp服务。\nfirewall-cmd –zone&#x3D;public –add-service&#x3D;ftp –permanent\n2）开通ftp服务需要的端口，21是控制端口，5000-5500是数据端口范围，也就是上一节中在&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf文件中配置的pasv_min_port和pasv_max_port参数。\nfirewall-cmd –zone&#x3D;public –add-port&#x3D;21&#x2F;tcp –permanent\nfirewall-cmd –zone&#x3D;public –add-port&#x3D;5000-5500&#x2F;tcp –permanent\n重启防火墙：\nsystemctl restart firewalld.service\n4、启动vsftpd服务ftp服务器的服务名是vsftpd，相关的操作如下：\nsystemctl start  vsftpd  # 启动服务。systemctl stop  vsftpd  # 停止服务。systemctl restart vsftpd  # 重启服务。systemctl status vsftpd  # 查看服务状态。systemctl enable vsftpd  # 启用开机自动动vsftpd服务。systemctl disable vsftpd  # 禁用开机自动动vsftpd服务。\n\n5、云平台访问策略配置如果您购买的是云服务器上，需要登录云服务器提供商的管理平台开通访问策略（或安全组），开通21和高端口的访问策略。\n不同云服务器提供商的管理平台操作方法不同，具体操作方法阅读操作手册、或者百度，或者咨询云服务器提供商的客服。\n如果云服务器的ftp服务不能建立数据会话，在百度中输入“被动模式下FTP不能建立数据会话问题“可以找到解决问题的方法，目前的阿里云服务器就存在这个问题。\nftp开发示例：\nvi ftpclient.cpp#include  &quot;_ftp.h&quot;Cftp ftp;int main()&#123;  if (ftp.login(&quot;127.0.0.1:21&quot;,&quot;lijialin&quot;,&quot;mima&quot;)==false)  &#123;    printf(&quot;ftp.login(127.0.0.1:21) failed.\\n&quot;); return -1;  &#125;  printf(&quot;ftp.login(127.0.0.1:21) success.\\n&quot;);  if (ftp.mtime(&quot;/home/lijialin/text.cpp&quot;)==false)  &#123;    printf(&quot;ftp.mtime(/home/lijialin/text.cpp) failed.\\n&quot;); return -1;  &#125;  printf(&quot;ftp.mtime(/home/lijialin/text.cpp) success,mtime=%s.\\n&quot;,ftp.m_mtime);  if (ftp.size(&quot;/home/lijialin/text.cpp&quot;)==false)  &#123;    printf(&quot;ftp.size(/home/lijialin/text.cpp) failed.\\n&quot;); return -1;  &#125;  printf(&quot;ftp.size(/home/lijialin/text.cpp) success,size=%d.\\n&quot;,ftp.m_size);  if (ftp.nlist(&quot;/home/lijialin&quot;,&quot;/tmp/lijialin.lst&quot;)==false)  &#123;    printf(&quot;ftp.nlist(/home/lijialin) failed.\\n&quot;); return -1;  &#125;  printf(&quot;ftp.nlist(/home/lijialin) success.\\n&quot;);  if (ftp.get(&quot;/home/lijialin/text.cpp&quot;,&quot;/tmp/text.cpp.bak&quot;,true)==false)  &#123;    printf(&quot;ftp.get() failed.\\n&quot;); return -1;  &#125;  printf(&quot;ftp.get() success.\\n&quot;);/*  if (ftp.put(&quot;/root/ftpclient.cpp&quot;,&quot;/home/zhangkun/bbb/ftpclient.cpp&quot;,true)===false)  &#123;    printf(&quot;ftp.put() failed.\\n&quot;); return -1;  &#125;  printf(&quot;ftp.put() success.\\n&quot;);*/  ftp.logout();  return 0;&#125;\n\n\n\ng++ -g -o ftpclient ftpclient.cpp /project/public/_ftp.cpp /project/public/_public.cpp -I/project/public -L/project/public -lftp -lm -lc\n\n动态链接库问题./ftpclient: error while loading shared libraries: libftp.so: cannot open shared object file: No such file or directoryexport LD_LIBRARY_PATH=/project/public:.\n\n\n\nftp.nlist(/home/lijialin) failed. \n\n\n\n\n\ncentos安装使用nginxsudo yum -y install nginx nginx  ps -ef|grep nginxyum install lsoflsof -i:80nginx -s signal // quit/stop/reload/reopen\n\n配置文件nginx -V  //--conf-path=/etc/nginx/nginx.conf 配置文件位置//--prefix=/usr/share/nginx   nginx根目录nginx -t //检查配置文件内容是否正确nginx -s reload vi /etc/nginx/nginx.conf//全局块 配置worker进程的数量、指定运行服务的用户等worker_processes auto; //配置worker进程的数量//events块 配置服务器和客户端网络连接的配置events &#123;    worker_connections 1024; //每个worker进程可以接收网络连接的数量&#125;//http块     配置虚拟主机（server块）、 反向代理、负载均衡等等  http &#123;    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;    access_log  /var/log/nginx/access.log  main;    sendfile            on;    tcp_nopush          on;    tcp_nodelay         on;    keepalive_timeout   65;    types_hash_max_size 4096;    include             /etc/nginx/mime.types; \t//包含其他配置文件    default_type        application/octet-stream;    # Load modular configuration files from the /etc/nginx/conf.d directory.    # See http://nginx.org/en/docs/ngx_core_module.html#include    # for more information.    include /etc/nginx/conf.d/*.conf;    server &#123;        listen       80; //监听端口        listen       [::]:80;        server_name  _;\t//服务名        root         /usr/share/nginx/html; //配置根目录文件夹        # Load configuration files for the default server block.        include /etc/nginx/default.d/*.conf;        error_page 404 /404.html;        location = /404.html &#123;        &#125;        error_page 500 502 503 504 /50x.html;        location = /50x.html &#123;        &#125;    &#125;        include servers/* //把servers目录下的所有配置文件都包含进来，每个虚拟主机（server块）的配置放在一个单独的文件里 &#125; \n\n网站部署例如：Hexo，基于Node.js的博客框架\nnpm install hexo-cli -gmkdir ~/nginxcd ~/nginxhexo init blogcd blog/publiccp -rf * /usr/share/nginx/html //把public下的文件都复制到nginx配置的server的根目录中hexo使用：npm install hexo-cli -ghexo init bloghexo s //运行一下hexo d //自动部署 需要配置config文件\n\n例如：Vue \n可以修改配置文件server块实现一个服务器代理多个域名访问\nnpm create vitecd vite-projectnpm install//打包一下npm run build把打包后的dist文件放在一个有权限访问的位置 在servers文件夹中添加配置文件 name.conf 写上server块server &#123;        listen       80;        listen       [::]:80;        server_name  _;        root         /usr/share/nginx/dist;        # Load configuration files for the default server block.        include /etc/nginx/default.d/*.conf;        error_page 404 /404.html;        location = /404.html &#123;        &#125;        error_page 500 502 503 504 /50x.html;        location = /50x.html &#123;        &#125;    &#125;    nginx -s reloadvite使用：npm create vitenpm installnpm run buildnpm run dev //运行一下\n\n\n\n反向代理、负载均衡vi /etc/nginx/nginx.conf在http块中添加反向代理配置upstream name357&#123;\tip_hash;\t//这个负载均衡策略会对客户端的ip进行哈希，同一个客户端的请会分配到同一个服务器上可以解决一些session的问题\t//另一种负载均衡策略weight\tserver 127.0.0.1（ip）:8000 weight=5 //这个服务器性能好，就配置权重（weight）大点，能分配到的请求次数越多\tserver 127.0.0.1（ip）:8001\tserver 127.0.0.1（ip）:8002&#125;访问localhost/app 就相当于 轮流（默认）或负载均衡（weight分配的权重） 的访问对应ip服务器的对应8000/8001/8002端口得到的内容server&#123;\tlocation /app&#123;//所有以app开头的请求都被代理到upstream中访问8000，8001......\t\tproxy_pass http://name357  //地址要和upstream中的名字保持一致\t&#125;&#125;\n\nHTTPShttp+ssl&#x3D;https\nssl证书可以通过云平台获取\n在nginx中配置\nvi /etc/nginx/nginx.conf在server中 server &#123;        listen       443 ssl http2;        listen       [::]:443 ssl http2;        server_name  url; //网站域名        root         /usr/share/nginx/html;\t\t#证书文件名称        ssl_certificate &quot;/root/nginx/cacert.pem&quot;;        #证书私钥文件名称        ssl_certificate_key &quot;/root/nginx/private.key&quot;;        #ssl_session_cache shared:SSL:1m;        #ssl验证配置        ssl_session_timeout  10m;        #配置加密套件/算法加密，写法遵循openssl标准        ssl_ciphers HIGH:!aNULL:!MD5;        #使用服务器端的首选算法        ssl_prefer_server_ciphers on;        #安全链接可选加密协议        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;        # Load configuration files for the default server block.        include /etc/nginx/default.d/*.conf;        error_page 404 /404.html;            location = /40x.html &#123;        &#125;        error_page 500 502 503 504 /50x.html;            location = /50x.html &#123;        &#125;    &#125;\n\n\n\n\n\ncentos安装gityum -y install gitgit --version\n\ncentos安装使用nvmgit clone git://github.com/creationix/nvm.git ~/nvmorwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bashcommand -v nvmecho &quot;source ~/nvm/nvm.sh&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc常用命令1. nvm list 是查找本电脑上所有的node版本    - nvm list 查看已经安装的版本    - nvm list installed 查看已经安装的版本    - nvm list available 查看网络可以安装的版本2. nvm install &lt;version&gt; 安装指定版本node3. nvm use &lt;version&gt; 切换使用指定的版本node4. nvm ls 列出所有版本5. nvm current显示当前版本6. nvm alias &lt;name&gt; &lt;version&gt; ## 给不同的版本号添加别名7. nvm unalias &lt;name&gt; ## 删除已定义的别名8. nvm reinstall-packages &lt;version&gt; ## 在当前版本node环境下，重新全局安装指定版本号的npm包9. nvm on 打开nodejs控制10. nvm off 关闭nodejs控制11. nvm proxy 查看设置与代理12. nvm node_mirror [url] 设置或者查看setting.txt中的node_mirror，如果不设置的默认是 https://nodejs.org/dist/　　nvm npm_mirror [url] 设置或者查看setting.txt中的npm_mirror,如果不设置的话默认的是： https://github.com/npm/npm/archive/.13. nvm uninstall &lt;version&gt; 卸载制定的版本14. nvm use [version] [arch] 切换制定的node版本和位数15. nvm root [path] 设置和查看root路径16. nvm version 查看当前的版本\n\ncentos安装node.jsnvm install 16node -v\n\n\n\n\n\ncentos7升级GCChttps://blog.csdn.net/b_ingram/article/details/121569398\nyum install -y gcc gcc-c++gcc --versiong++ --version切换用户：su - root安装centos-release-scl：sudo yum install -y http://mirror.centos.org/centos/7/extras/x86_64/Packages/centos-release-scl-rh-2-3.el7.centos.noarch.rpmsudo yum install -y http://mirror.centos.org/centos/7/extras/x86_64/Packages/centos-release-scl-2-3.el7.centos.noarch.rpm安装devtoolset：sudo yum install -y devtoolset-9-gcc-c++激活对应的devtoolset:scl enable devtoolset-9 bashsource /opt/rh/devtoolset-9/enablegcc --version1.直接替换旧版本的gcc:mv /usr/bin/gcc /usr/bin/gcc-4.8.5ln -s /opt/rh/devtoolset-9/root/bin/gcc /usr/bin/gcc2.启动gcc（永久）echo &quot;source /opt/rh/devtoolset-9/enable&quot; &gt;&gt;/etc/profile\n\n\n\ncentos安装g++yum install gcc-c++ libstdc++-devel \n\n\n\ncentos安装tomcatmkdir /opt/tomcatapache-tomcat-8.5.59.tar.gz上传到/opt/tomcatcd /opt/tomcattar -zxvf apache-tomcat-8.5.59.tar.gzcd apache-tomcat-8.5.59/bin/./startup.sh\n\n开放端口（防火墙或安全组） 8080\nfirewall -cmd --permanent add-port=8080/tcpfirewall -cmd --reloadfirewall -cmd --query-port=8080/tcp\n\n\n\nubuntu安装mysql1、#查看有没有安装MySQL：\ndpkg -l | grep mysql\n2、 安装MySQL：\nsudo apt install mysql-server\n3、检查是否安装成功：\nnetstat -tap | grep mysql\ncentos安装mysql5.7mkdir /opt/mysqlcd /opt/mysqlwget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tartar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tarrpm -qa|grep mari  原本可能有的数据库 提前删干净rpm -e --nodeps mariadb-libs 删除mari相关的所有rpm -e --nodeps marisarpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm --force --nodeps  如果失败 可能缺少依赖numactl  yum -y install libaio yum -y install numactlsystemctl start mysqld.service如果报错Job for mysqld.service failed because the control process exited with error code. See &quot;systemctl status mysqld.service&quot; and &quot;journalctl -xe&quot; for details.mkdir -p /var/run/mysqld/chown mysql.mysql /var/run/mysqld///ormkdir /var/lib/mysql/datavi /etc/my.cnfdatadir=/var/lib/mysql/datasystemctl status mysqld.servicegrep &quot;password&quot; /var/log/mysqld.logmysql -uroot -pALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;;ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;;配置远程连接USE mysql;UPDATE mysql.user SET host = &#x27;%&#x27; WHERE user = &#x27;root&#x27;;SELECT user, host, plugin, authentication_string FROM mysql.user;FLUSH PRIVILEGES;quit配置开机启动启动查看MySQL是否自启：systemctl is-enabled mysqld开启自启 ：systemctl enable mysqld关闭自启 ：systemctl disable mysqldsystemctl enable mysqld.service # 开机自启动systemctl disable mysqld.service # 禁用开机自启动\n\nmysql找回root密码1. vi /etc/my.cnf2. skip-grant-tables3. service mysqld restart4. mysql -u root -p5. show databases;6. use mysql;7. show tables;8. desc user;9. update user set authentication_string=password(&quot;lijialin&quot;)  where user=&#x27;root&#x27;;  或者改成空密码&#x27;&#x27;登录以后再修改10. flush privileges;11. exit12. vi /etc/my.cnf13. #skip-grant-tables14. service mysqld restart15. mysql -u root -p\n\n连接mysqlmysql -u root -puse mysql;update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;FLUSH PRIVILEGES;\n\n1.ping IP 查看是否开放公网 2.telnet IP port 查看端口是否开放上面不通畅登录进入服务器登录mysql root如果是docker安装docker exec -it mysql /bin/bash  执行docker容器的mysql，这里容器名是mysqlmysql -u root -p3.use mysql;4. select host,user from user;5. grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;lijialin&#x27;; //5.7 GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; WITH GRANT OPTION; //8.06. flush privileges;\n\n一、查看3306端口是否开放netstat -an|grep 3306\n\n如果看到下图这样的，说明端口并未打开：\n\n二、修改访问权限cd /etc/mysql/mysql.conf.d/sudo vim mysqld.cnf# \n\n# bind-address = 127.0.0.1\n\nCentOS ‘mysql&#x2F;mysql.h‘: No such file or directoryyum install mysql-devel\n然后\nmysql_config\n查看-lmysqlclient这个库 在哪个目录\n然后只需要把之前的编译命令- lmysqlclient替换成 -L&#x2F;usr&#x2F;lib64&#x2F;mysql -lmysqlclient（目录）这个就好了，就能编译过了。\n意思是 不从默认的文件夹&#x2F;usr&#x2F;lib里边取动态库-lmysqlclient从绝对目录里边取。\n所以也可以分析出来出现这个 找不到这个库的原因不是 因为linux机器上没有这个库。\n而是 找错了 位置，如果嫌加绝对目录太麻烦，直接复制一份到&#x2F;usr&#x2F;lib一份就行了\ncentos安装 JDKmkdir /opt/jdkjdk-8u261-linux-x64.tar.gz上传到 /opt/jdk 下cd /opt/jdktar -zxvf jdk-8u261-linux-x64.tar.gzmkdir /usr/local/javamv /opt/jdk/jdk1.8.0_261 /usr/local/javavim /etc/profileexport JAVA_HOME=/usr/local/java/jdk1.8.0_261export PATH=$JAVA_HOME/bin:$PATHsource /etc/profilejava -version\n\n\n\ncentos安装Hexocd nginxnpm install hexo-cli -ghexo init blogcd blog;npm installhexo server / hexo s\n\n\n\nubuntu安装redisapt update\n\napt install redis-server\n\ncentos安装redisgcc -vyum install -y gcccd /opt# 下载，我是在root下执行的下载，所以我的下载目录为：/root/redis-6.2.6，这里按照自己的实际情况调整wget https://download.redis.io/releases/redis-6.2.6.tar.gz# 解压tar -zxvf redis-6.2.6.tar.gz# 进入解压目录cd redis-6.2.6# 编译makeyum install tcl tcl-devel -ymake testmake install 通过守护进程方式启动vi redis.conf# 修改内容如下：daemonize 的值从 no 修改成 yesredis-server redis.confps -ef |grep redisredis-cli设置开机自动启动cd /lib/systemd/system/vi redis.serviceredis.service--------------------------------------------------------[Unit]Description=redis-serverAfter=network.target[Service]Type=forking# ExecStart需要按照实际情况修改成自己的地址ExecStart=/usr/local/bin/redis-server /opt/redis-6.2.6/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target--------------------------------------------------------# 开机自动启动systemctl enable redis.service# 启动redis服务systemctl start redis.service# 查看服务状态systemctl status redis.service# 停止服务systemctl stop redis.service# 取消开机自动启动(卸载服务)systemctl disabled redis.service\n\n\n\nubuntu安装webbenchsudo apt-get install exuberant-cTagswget  http://home.tiscali.cz/cz210552/distfiles/webbench-1.5.tar.gztar -zvxf webbench-1.5.tar.gzcd webbench-1.5make &amp;&amp; sudo make installwebbench --version\n\n使用\n用法：webbench -c 100 -t 10 http://www.iteye.com/ \n其中：-c表示并发数，-t表示时间(秒)\n 注意url结尾一定要加上&#x2F;\nubuntu16.04 安装boost1.65参考：https://blog.csdn.net/jiandanjinxin/article/details/65632653\n1. 下载源码https://www.boost.org/users/history/version_1_65_1.html\ntar -zxvf boost_1_65_1.tar.gzcd boost_1_65_1./bootstrap.sh --with-python=PYTHON./bootstrap.sh –with-libraries=all会生成 b2和bjam文件。可查看使用方法./bootstrap.sh -help\n\n2. 编译 boostsudo ./b2 install ./b2 cxxflags=-fPIC cflags=-fPIC --c++11\n\n\n\n\n\n问题ubuntu系统“软件中心”闪退或者打不开解决方法sudo apt-get updatesudo apt-get dist-upgradesudo apt-get install --reinstall software-center\n\n\n\nkillall: command not found解决：centos 执行如下安装命令：\nyum install psmisc\n\n\n\nCentOS ‘mysql&#x2F;mysql.h‘: No such file or directory解决：yum install mysql-devel\n然后\nmysql_config\n查看-lmysqlclient这个库 在哪个目录\n然后只需要把之前的编译命令- lmysqlclient替换成 -L&#x2F;usr&#x2F;lib64&#x2F;mysql -lmysqlclient（目录）这个就好了，就能编译过了。\n意思是 不从默认的文件夹&#x2F;usr&#x2F;lib里边取动态库-lmysqlclient从绝对目录里边取。\n所以也可以分析出来出现这个 找不到这个库的原因不是 因为linux机器上没有这个库。\n而是 找错了 位置，如果嫌加绝对目录太麻烦，直接复制一份到&#x2F;usr&#x2F;lib一份就行了\n命令linux共享内存查看当前共享内存ipcs -m\n删除指定共享内存ipcrm -m 32575(shmid)\n进程操作查看进程ps -ef |grep procctl(程序名)\n\n开机启动进程用root登录 看看有没有这个文件ls -l /etc/rc.d/rc.localvi /etc/rc.d/rc.local需要开机启动什么直接在后面加，例如#!/bin/bash# THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES## It is highly advisable to create own systemd services or udev rules# to run scripts during boot instead of using this file.## In contrast to previous versions due to parallel execution during boot# this script will NOT be run after all other services.## Please note that you must run &#x27;chmod +x /etc/rc.d/rc.local&#x27; to ensure# that this script will be executed during boot.touch /var/lock/subsys/local#启动守护进程/project/tools1/bin/procctl 30 /project/tools1/bin/checkproc#启动后台服务程序# su -lijialin -c &quot;/bin/sh /project/idc1/c/start.sh&quot;chmod +x /etc/rc.d/rc.local\n\n时间操作1）查看时间。date （功能描述：显示当前时间）\ndate +%Y （功能描述：显示当前年份）\ndate +%m（功能描述：显示当前月份）\ndate +%d （功能描述：显示当前是哪一天）\ndate “+%Y-%m-%d %H:%M:%S”（功能描述：显示年月日时分秒）\n2）设置时区为中国上海时间（注意不是北京时间）。cp &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime\n3）设置时间。date -s “yyyy-mm-dd hh:mi:ss”\n4）cal 指令查看日历指令 cal\ncal [选项] （功能描述：不加选项，显示本月日历）\n案例 1: 显示当前日历 cal\n案例 2: 显示 2020 年日历 : cal 2020\n重启和关机1）重启\ninit 6 或 reboot\n2）关机\ninit 0 或 halt\n清屏clear\n查看服务器的ip地址ip addr\n查看当前工作目录pwd\n改变当前工作目录cd 目录名\n列出目录和文件信息ls -lt 目录或文件名\n正则表达式\nls &#x2F;tmp&#x2F;exp*.dmp\n创建目录文件mkdir 目录名touch 文件名\n删除目录和文件rm -rf 目录或文件列表\nrm -f .*.*.swp\n\n移动目录和文件mv 旧目录或文件名 新目录或文件名\n复制目录和文件cp -r 旧目录或文件名 新目录或文件名\n判断网络是否连通Windows系统：\nping -n 包的个数 ip地址或域名\nLinux系统：\nping -c 包的个数 ip地址或域名\n用户管理查询用户信息id 用户名whoami&#x2F;who am I\n用户和组相关文件\n&#x2F;etc&#x2F;passwd 文件用户（user）的配置文件，记录用户的各种信息每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 Shell\n\n&#x2F;etc&#x2F;shadow 文件口令的配置文件每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志\n\n&#x2F;etc&#x2F;group 文件组(group)的配置文件，记录 Linux 包含的组的信息每行含义：组名:口令:组标识号:组内用户列表\n\n\n增加&#x2F;删除用户组1）增加用户组\ngroupadd 组名\n2）删除用户组\ngroupdel 组名\n增加&#x2F;删除用户1）增加用户\nuseradd 用户名useradd -d 指定目录 用户名useradd -g 用户组 用户名passwd 用户名\nuseradd -n 用户名 -g 组名 -d 用户的主目录\n2）删除用户\n&#x2F;&#x2F;保留用户主目录userdel 用户名&#x2F;&#x2F;删除用户以及主目录userdel -r 用户名\nuserdel 用户名\n修改用户的组usermod –g 用户组 用户名\n修改用户的密码passwd 用户名\n切换用户su - 用户名\nexit&#x2F;logout\n从root用户切换到其它普通用户不需要输入密码\n修改目录和文件的主人和组chown [-R] 用户名:组名 目录或文件名列表\n-R 选项表示处理各及子目录。\n1）把&#x2F;oracle&#x2F;home和&#x2F;oracle&#x2F;base及其子目录的主人改为oracle，组改为dba。\nchown -R oracle:dba &#x2F;oracle&#x2F;home &#x2F;oracle&#x2F;base\n查看系统磁盘空间df [-h] [-T]\n-h 以方便阅读的方式显示信息。\n-T 列出文件系统类型。\necho 指令echo 输出内容到控制台\n\n基本语法\n\necho [选项] [输出内容]\n","slug":"linux","date":"2024-07-30T07:18:43.000Z","categories_index":"操作系统","tags_index":"Linux","author_index":"暗使开开"},{"id":"0c28c8671cbf680a33a46ee0d16608fc","title":"IDEA","content":"IDEA代码编辑\nctrl+shift+V 粘贴复制历史\nctrl+shift+alt+V 不带格式的粘贴\nctrl +alt+L 代码格式化\nalt+鼠标左键并拖动 纵向选中多行文字\nctrl+d 复制粘贴一行或多行\nalt+shift+上下键 移动选中行行\nshift+上&#x2F;下 选中多行 \nalt+insert generater\n\n快速跳转\nctrl+鼠标左键 进入方法\nctrl+alt+鼠标左键 回到刚才的位置\nhome 行首，end行尾 行内跳转或选中\nctrl+左右 光标一个单词的跳\nctrl+g 跳到指定行\nalt+左右 tab切换到上一个下一个\nctrl+e 查看最近打开的文件\nshow in explorer快速打开文件所在的文件夹\n\n快速查找和替换\nctrl+f 内容查找\nctrl+r 内容替换\nctrl+shift+f&#x2F;r 项目中的内容查找&#x2F;替换（全局）\nctrl+shift+n 查找文件&#x2F;操作菜单&#x2F;…\n\n万能快捷键\nalt+enter 提示&#x2F;引入&#x2F;补全&#x2F; 加入字典&#x2F;生成构造方法&#x2F;getset方法&#x2F;…\n\n插件\ngit\n\n自定义代码模板Live Templatesetting-》Editor-》Live Templates\ngtr,ptr,ptrp\npostfix先打变量，表达式，后打快捷键\ni==1.ifuser.nulluser.sout\n\n\n\n热部署 自动编译setting-》Compiler-》Build project automatically\nhelp-》find action-》Registry\n","slug":"idea","date":"2024-07-30T07:17:06.000Z","categories_index":"开发工具","tags_index":"IDEA","author_index":"暗使开开"},{"id":"58b7f561a82cc9dd7c27d8845a6fb9dd","title":"git","content":"使用github搜索awesome xxx &#x2F;&#x2F;找百科全书\nxxx sample &#x2F;&#x2F;找例子\nxxx starter &#x2F;xxx boilerplate &#x2F;&#x2F;找空项目架子\nxxx tutorial &#x2F;&#x2F;找教程\ngitignore不生效git rm -r --cached .git add .git commit -m &quot;update .gitignore&quot;\n\n\ngit基本操作设置查询配置信息git config --global user.name &quot;govk&quot;git config --global user.email &quot;china.lijialin@outlook.com&quot;克隆代码git clone查看状态git status告诉新建的文件夹要用git管理git init 提交代码//全部提交到缓冲区 暂存区git add . //单次提交 git add 2.py提交代码到仓库git commit -m &quot;加备注&quot; 推送代码git push拉取代码git pull查看git提交日志git log  回滚git reset HEAD //reset定向到git chackout HEAD main.py //回退到main.py最后一次提交的版本git chackout main.py //没有提交前 从缓冲区退回到工作区从当前分支为基础新建分支//创建分支a bgit checkout -b a git checkout -b b切换回master主分支git checkout master合并分支agit merge a合并有冲突自己难以决策时 放弃当前合并git merge --abort看当前有哪些分支git branch完成的分支删除git branch -D a\n\n\n\n连接githubgithub新建仓库有提示\n…or create a new repository on the command lineecho &quot;# -&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git branch -M maingit remote add origin https://github.com/govk/-.gitgit push -u origin main\n\n…or push an existing repository from the command linegit remote add origin https://github.com/govk/-.gitgit branch -M maingit push -u origin main\n\n…or import code from another repositoryYou can initialize this repository with code from a Subversion, Mercurial, or TFS project.\nvscode插件下载 gitlens\ngithub最常用的便是SSH和HTTP(S)协议。git关联远程仓库可以使用http协议或者ssh协议。HTTPS优缺点\n优点1: 相比 SSH 协议，可以使用用户名／密码授权是一个很大的优势，这样用户就不必须在使用 Git 之前先在本地生成 SSH 密钥对再把公钥上传到服务器。 对非资深的使用者，或者系统上缺少 SSH 相关程序的使用者，HTTP 协议的可用性是主要的优势。 与 SSH 协议类似，HTTP 协议也非常快和高效优点2: 企业防火墙一般会打开 80 和 443 这两个常见的http和https协议的端口，使用http和https的协议在架设了防火墙的企业里面就可以绕过安全限制正常使用git，非常方便缺点: 使用http&#x2F;https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令. 但是现在操作系统或者其他git工具都提供了 keychain 的功能，可以把你的账户密码记录在系统里，例如OSX 的 Keychain 或者 Windows 的凭证管理器。\nSSH的优缺点\n优点1: 架设 Git 服务器时常用 SSH 协议作为传输协议。 因为大多数环境下已经支持通过 SSH 访问 —— 即时没有也比较很容易架设。 SSH 协议也是一个验证授权的网络协议；并且，因为其普遍性，架设和使用都很容易。\n缺点1: SSH服务端一般使用22端口，企业防火墙可能没有打开这个端口。缺点2: SSH 协议的缺点在于你不能通过他实现匿名访问。 即便只要读取数据，使用者也要有通过 SSH 访问你的主机的权限，这使得 SSH 协议不利于开源的项目。 如果你只在公司网络使用，SSH 协议可能是你唯一要用到的协议。 如果你要同时提供匿名只读访问和 SSH 协议，那么你除了为自己推送架设 SSH 服务以外，还得架设一个可以让其他人访问的服务。\n总结HTTPS利于匿名访问，适合开源项目可以方便被别人克隆和读取(但他没有push权限)；毕竟为了克隆别人一个仓库学习一下你就要生成个ssh-key折腾一番还是比较麻烦，所以github除了支持ssh协议必然提供了https协议的支持。而SSH协议使用公钥认证比较适合内部项目。 当然了现在的代码管理平台例如github、gitliab，两种协议都是支持的，基本上看自己喜好和需求来选择就可以了。\ngit将一个项目同时push到多个仓库使用以下命令添加远程仓库地址\ngit remote set-url --add origin https://github.com/demo.git\n\n查看所有远程仓库信息\ngit remote -v\n\n此时同步所有仓库\ngit push\n\n\n\n\n\n\n\nGit init和Git init –bare的区别\ninit：适用于本地仓库初始化，有完整的Git命令集，可以提交工作空间的代码和文件。\ninit –bare:：适用于远程仓库初始化，默认没有工作空间。\n\ngit init –bare适用于远程仓库“裸”仓库创建工作空间很简单，配合hook使用，hook就是一些在Git特点动作时候，触发的事件。\npost-receive我们要在裸仓库内，看到用户提交的工作空间很简单。只需要编写post-receive\n# 当前在裸仓库内cd hooks# 创建并编辑post-receivevim post-receive#!/bin/shgit --work-tree=#工作空间# --git-dir=#Git仓库地址# checkout -f\n\n工作空间：服务器上空目录地址，git用户需要有读写权限。Git仓库地址：服务器上本仓库地址。\n最后赋予执行权限）\nchmod +x post-receive\n","slug":"git","date":"2024-07-30T07:15:25.000Z","categories_index":"开发工具","tags_index":"git","author_index":"暗使开开"},{"id":"4122a09df2e4f3d18921791a0dcc0507","title":"docker","content":"Docker真心不推荐使用\n\n高度集成，仓库消失等于白费，个人最不喜欢把心放在别人那里，自己掌握技术才是最好的。\n对技术提升没帮助，直接跳过环境部署会让你对使用的开发软件永远处于小白阶段，自己都做开发了还怕这点麻烦，其实也不麻烦，所谓难者不会，会者不难。\n\n启动 Dockersudo systemctl start dockersudo systemctl restart docker\n\n镜像管理查看镜像docker image lsdocker images检索镜像docker search [image]docker search nginx拉取镜像docker pull [image]上传镜像docker push [image]docker push hello-docker保存镜像docker save [image] -o FILE /docker save [image] &gt; FILEdocker save hello-docker &gt; hello-docer.tar导入镜像docker load -i FILEdocker load -i hello-docer.tar查看镜像历史docer history [image]删除镜像docker rmi [image]docker image rm [image]\n\n\n\n容器管理容器运行安装docker卸载旧版本sudo yum remove docker \\        docker-client \\         docker-client-latest \\         docker-common \\         docker-latest \\         docker-latest-logrotate \\         docker-logrotate \\         docker-engine\n\n设置仓库在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。之后，可以从仓库安装和更新 Docker。\nsudo yum install -y yum-utils\n\n官方源地址sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n阿里云sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n安装 Docker Engine-Community安装最新版本的 Docker Engine-Community 和 containerd，或者转到下一步安装特定版本：\nsudo yum install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin\n\n启动 Docker\nsudo systemctl start docker\n\n卸载 docker删除安装包：\nyum remove -y docker \\           docker-client \\           docker-client-latest \\           docker-common \\           docker-latest \\           docker-latest-logrotate \\           docker-logrotate \\           docker-selinux \\           docker-engine-selinux \\           docker-engine\n\n删除镜像、容器、配置文件等内容：\nyum remove -y docker-ce \\           docker-ce-cli \\           containerdrm -rf /etc/systemd/system/docker.service.drm -rf /etc/systemd/system/docker.servicerm -rf /var/lib/dockerrm -rf /var/run/dockerrm -rf /usr/local/dockerrm -rf /etc/dockerrm -rf /usr/bin/docker* /usr/bin/containerd* /usr/bin/runc /usr/bin/ctr\n\n","slug":"docker","date":"2024-07-30T07:12:50.000Z","categories_index":"开发工具","tags_index":"docker","author_index":"暗使开开"},{"id":"487367ff609355e6216873e9408d459b","title":"雅思","content":"IELTS\n剑雅真题8-16\n考点词538\nSIMON雅思课\n慎小嶷写作素材库\n\n软件\n\n雅思哥\n雅思考满分\n每日英语听题\n\npart1\n一般加特殊\n设置条件，一定要简单\n 平常怎么样，当什么时候，就怎么样，原因\n 开不开心，忙不忙，周日平时\n\n过去加现在\nlike之类的，过去怎么现在怎么，原因\n\n老年人年轻人男人女人\n一类人怎么样，原因\n\n\npart2\n题库\n\n想一个旅游的故事（尽量小众的地方）\nlonelyplanet.com\n\n在哪\n什么样\n做的一件事\n遇见的一个人\n看到的一个物品\n\n\n应用到题库\n\n\n小作文图表题20min 150词（注意时态）\n\nIntroduction\n一句话 介绍图表\n\nOverview\n两句话 选两个特点\n不要提到具体的（数字），不需要主观内容\n\nDetails\n第一句话 说明本段哪个图表\n\nDetails\n第一句话 说明本段哪个图表\n\n\n小作文 各图表句式Introduction\n\nGiven is a&#x2F;are two\ndiagram illustrating the process by which [thing] is [done]&#x2F;Interaction between …\ngraphs&#x2F;figures&#x2F;pie charts&#x2F;line graphs&#x2F;column graphs&#x2F;bar\ngraphs concerning&#x2F;comparing&#x2F;providing a comparison [of&#x2F;between something] in[place] in [year]&#x2F;during the period from… to… as well as… in these regions.\n\n\nA glance at the (two) graph&#x2F;figure&#x2F;pie chart&#x2F;table(s) provided reveals\nthe relative popularity of [thing] among [ppl] in [place] in [year].\nsome&#x2F;a number of striking similarities&#x2F;clear differences between [thing] in termsof [length&#x2F;age&#x2F;scale] in [place] during the period from… to…\n\n\nThe chart&#x2F;graph gives information regarding…\nDIAGRAM - The [thing] is&#x2F;are denoted by [symbol], while the [thing] is&#x2F;are marked as[symbol].\n\nparaphrase tips:between 1980 and 2012 &#x3D; over a period of 32 years&#x2F;over the period shownthe figure for…\nBody 正文\n\nOpening Sentences\nIt is evident&#x2F;apparent from the information supplied that …\nFrom the information supplied, it is evident that …\nAs shown in the figure, …\nWhile …, it seems that …\nOne particular interesting fact highlighted by the figure is that …\nAlso evident&#x2F;noteworthy is the fact that …\nNot surprisingly, … Equally predictable is the fact that …\nAs for&#x2F;with regard to {thing}, …\nIt is also interesting to note that …\nIn stark contrast, however, …\nIn contrast to [party], …\nYet, by far the most significant change to take place during the period in question was …\nThere were also considerable decreases in …\n\n\nLine Graph 折线图\n现在时 - From a negligible [value], the [figure] soars to [value] among …\n过去式 - From [value] in [yr], [figure] climbed steadily to [figure] in [yr], before soaringto a staggering [value] in [yr].\nIncreasing from approximately [value] in [year] to [value] in [year], [thing] then plungedto a low of just [value] in the [time].\nThe [figure&#x2F;thing], meanwhile, fluctuated at somewhere between [value n value] priorto [time], before dropping sharply to less than [value] in [time].\nThis is&#x2F;was followed by an exponential growth, with [thing&#x2F;figure] reaching a peak of[value].\nThe [time, eg. latter half of the century; following 5 yrs; subsequent decades], however,saw a sustained decline&#x2F;rapid growth in this figure, to somewhere in the vicinity of[value] in [time], followed by a steady fall&#x2F;rise.\nSecond in terms of [thing] was [party]. This [party] saw a threefold increase during theperiod in question, from [value] in [yr] to [value] in [yr].\nJust one year later, A overtook B as the primary source of…\n… increased by progressively small amounts and reached…\n… rose at an increasingly rapid rate, reaching [number] by [year] and [number] in [year].\n\n\nPie Chart 饼状图\nAs for [figure], men outnumber women 24 to 1.\nOverall, the number of [thing, eg. men and women studying part time] outnumberedthose [studying full-time] by a significant margin.\nSome 70% of the [thing] are [what], while the remainder are [what].\nOf these [things], [thing] is&#x2F;was the most …\nNot a single respondent to the survey rated [thing] as … in [yr]. However, by [yr] thisfigure stood at [value] — the second highest overall.\nAlso more popular is [thing], at [value] in [yr] compared to [value] a decade earlier.\n[Thing] — which was the second most [what] in [yr], accounting for [percent] ofrespondents — slipped to a mere [percent] in [yr].\n[Thing] was far more common in [party] than in any other [party] listed.\nThe prevalence of [thing] in [party] was double that of [party] and triple that of [party].\n[Party], meanwhile, had moderate levels of [thing].\nspending on A varied widely in the 3 year and was in the range of 7-16% of the totalbudget.\nin [year], x% of A did …, while the equivalent figure for B was y%.\nBoth UK and USA saw an increase in …, from x1% to x2% in UK and from y1% to y2%in USA.\nSth account for the highest proportion of UK … in both years, but only the third highestproportion in USA.\nBritish spent only half as much in relative terms on X as US residents.\nIn both countries, A and B took roughly x% and y% of the budgets respectively.\nthe majority of … were over 40 years of age. To be precise, …% of them were aged 50 ormore, and …% aged between 40 and 49. Younger adults were in the minority, with…\nIn Poland, however, studies take almost half the expenditure at 43%, followed bytransport at 26%.\ntake the vast majority\n\n\n\nvocab: account for&#x2F;make up x%\n\nColumn&#x2F;bar Graph 柱状图\nBy far the most common [thing] for this group, [thing] and [thing], were [done] astaggering [value] and [value] respectively.\nNumbering (some) [value], [thing] was the second for this group.\nThird (in terms of …) was [thing]\n, at approximately [value].\n. An approximate [value] of [thing] were [done] on [party] during the year inquestion.\n[Thing] and [thing] were considerably less common, at [value] and [value] respectively.\n[Thing] doubled from around [eg100] in [yr] to well over [eg200] in [yr].\nThe number of [thing] over the [eg.3] periods fluctuated, dropping from approximately[value] to [value]. (When X axis is time)\nFor [party], the trajectory was less consistent rising sharply in the [time, eg. first decade]and then tapering off to an almost identical level to that of [party] in [time].\nThe … partially follow this pattern.\n[figure] lies roughly between these two extremes.\n\n\n\n大作文\n议论文40min 250词\n4段13句\n\nIntroduction 2句\n介绍主题\n给出态度\n\n\n正文 5句\n中心句\n3个分论点\n一个例子\n\n\n正文 5句\n一个论点\n3句解释\n1句总结\n\n\nConclusion 1句\n第一段第二句话\n\n\n\n大作文 6种句型\nSimple sentences\nSugar makes people unhealthy.\nSugar harms people’s teeth.\n\n\nCompound sentences\nSugar makes people unhealthy and it harms their teeth.\n\n\nComplex sentences (一篇作文中至少用5句)\nWhile some people will support the tax, others will be against it.\nAlthough people will benefit, companies will suffer.\n\n\nPassive sentences\nSugary drinks are known to be addictive.\n\n\nQuestion sentences (一篇作文中最多用一次)\nBut would a sugary tax really work?\n\n\nConditional sentences (&#x3D;if)\nIf the government had taxed sugary drinks earlier then we would not have anobesity issue now.\n\n\n\n听力用耳朵背单词\n精听：听一句写一句\n\n材料：100个词最多1-2个不认识的单词\n不要多思考，多模仿\n一般5min音频听写在1个多小时左右\n\n\n加1.5&#x2F;2倍速练习\n每天练习3个五分钟托福音频 复习-0，-1，-3，-7\n\n口语全文背诵，不怕慢，有感情读一句读几遍，背一句\n阅读找长难句练习\n外功，分割句子，标点-连接词-主谓语\n内功，反复有感情的读分析后的句子\n背单词复习时间和背单词时间应该是持平，规划好时间，复习和学习都不能放松，不求快\n\n合适的时间\n\n饥饿记忆\n来回走动\n温度低\n睡前（要输出的学习）\n运动后\n\n\n学习动机\n\n创造意义\n开始学习困难给自己一个中间态适应\n奖励回路\n\n\n背新单词 100&#x2F;d\n\n不要经常换书\n联想\n快速反复\n\n\n复习\n\n复习时间 -0，-1，-3，-7\n复习要用功不能放松\n输出的复习，讲出来讲给别人也行\n\n\n拼写 10&#x2F;d\n\n重复回忆拼写，不要老看\n\n\n\n写作原则\n重要的事情先说\n分解(比如你要写大象，就可以按大象的种类，年龄进行分类，然后对每一类的进行单独描写)\n链接词(转折however，but，yet nonetheless，承接 moreover，furthermore，举例，for example，for instance，总结 in conclusion)\n小模板 (比较关系(a比b好，或两者相差不大)，时间顺序，因果关系(因为前者发生，导致后者))\n\n模仿\n懂了原则还要看他人如何运用(母语者或者是英文写作水平高的人如何运用\n光有原则不行，不能按照自己的理解来运用原则\n光模仿不行，需要知道别人运用了什么原则，为什么写得好\n\n模仿与原则的关系模仿是练习，需要将原则转化为自己的本能这样才能提升自己的写作能力。练习方法：全文背诵，翻译，写作反馈再写作业(加群)\n反馈\n写作能力的提高的前提是鉴赏能力的提高，只有知道什么是好的文章，才能朝着那个方向努力\n提升鉴赏能力和写作能力非常好的办法是有一个写作水平高出你很多的人告诉你，你写的东西哪里不好，为什么。\n反馈见效——1个月 有兴趣，有写作感觉\n\n翻译\n找主干（谁 是 什么，谁 做 什么， 什么 被 做）\n添加修饰成分\n检查回读\n\n有：hava&#x2F;has\n There be(is&#x2F;are&#x2F;was&#x2F;were)\n曾有现在没了：there has been&#x2F;there have been\n将会有：there will be\n伴随的一种状态：with\n了：完成时标志，用have&#x2F;has done\n的：of—A of B B的A\n听力\n做题\n\n\n听前：预读题目勾选关键词–预测读音 预测意思 不听问题\n听中：勾画听到的东西–对应程度高的为正确选项的几率大\n\n\n练习\n听一句写一句，写出来为止\n\n\n新闻报道长对话篇章写作能力的重要性Directions： For this part, you are allowed 30 minutes to write a short essay on the importance of writing ability and how to develop it. you should write at least 120 words but no more than 180 words.\n范文： Tsinghua University’s decision to make Writing and Communication a required course has sparked a heated debate recently.\n Many people regard writing as a must-have skill only for certain professions, on which they don’t have to put much emphasis. But writing, as I see it, is a basic ability everyone can’t do without. From composing a well-organized paper, to giving a sharply-focused work report, and even posting a sentiment on WeChat Moments, all aspects of life just require this ability. On top of communications, writing sharpens out logic and cognitive thinking, for it requires reflection, analysis and artful presentation of information and views. So it’s no surprise that top-ranking universities like Harvard made writing a compulsory course even for science majors.\n Then how to improve writing skills? Certainly there is a shortcut to learning layout and word choice. For example, you can read and imitate excellent works, learning skills from them like expression, rhetoric and coherence. But tricks aren’t enough. Since language is mind-based, one can hardly become a good writer without reading extensively and thinking deeply. Hone your thinking skills while reading, and your writing can be really improved.\n写作储备：\nBe it a school, college, workplace or a society, writing has become a vital yardstick to assess one’s knowledge and intellectuality.\n不管是在中小学，大学，职场还是在社会上，写作已经成为评估一个人知识和智力的重要标尺。\n\nWriting improves the thinking process and contributes to the development of critical thinking skills because an individual has to clearly state ideas and lay out arguments in such a way as to cultivate higher order thinking.\n写作能够改善思维过程，并有助于培养批判性思维能力，因为（写作中）个人需要清楚地表述观点并展开论证，这种方法能使我们培养起高阶推理思维。\n\nTaking the time to polish your writing skills is likely to pay off in the longer term, and learning how to write specific types of documents will also be useful. For example, being able to prepare a strong summary is a skill that is extremely useful for briefing senior managers.\n花时间完善你的写作技巧从长远来看可能很有价值，学习写作一些特定类型的公文也很有用。举个例子，在给主管作简报时，搞定一份有说服力的概要就是个相当有用的技巧。\n\nThe ability to write the better sentence or choose the better word does not come from a book, the way grammar can come from a book. It comes with experience. With grammar, you can study the rules, memorize them, and then apply them to your writing almost immediately. The subtler aspects of writing can be learned, but they are usually learned over time through a combination of reading, studying the craft of writing, and practicing.\n写出更好的句子或恰当选择字词的能力并不像语法那样来自书本，而是来源于经验。对于语法，你可以学习规则、记住规则，并且可以几乎马上就将其运用到写作中去。但你要学到写作中一些更微妙的东西，往往需要通过一段时间的阅读，学打写作草稿、练笔实践相结合的方式才行。\n\nMake your advice more practical by demonstrating your tips with lively examples.\n通过生动的例子来论述你的建议，是指更加切实可行。\n\n\n选词填空\n标词性 adj n v adv\n看空 名词单复数，动词时态\n\nthe&#x2F;a&#x2F;adj&#x2F;one’s&#x2F;more&#x2F;+(形容词)+名词\nof 前后是名词\nTo&#x2F;情态动词(would could can should…)+动词原形\nHas&#x2F;have&#x2F;had&#x2F;+过去完成时\n","slug":"雅思","date":"2024-07-30T03:56:53.000Z","categories_index":"英语","tags_index":"","author_index":"暗使开开"},{"id":"5b5d08436835575fd066ad5ca75118aa","title":"gitea","content":"gitea数据库mysql -uroot -pCREATE USER &#x27;gitea&#x27; IDENTIFIED BY &#x27;password&#x27;;GRANT ALL PRIVILEGES ON *.* TO &#x27;gitea&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27; WITH GRANT OPTION;CREATE DATABASE giteadb CHARACTER SET &#x27;utf8mb4&#x27; COLLATE &#x27;utf8mb4_unicode_ci&#x27;; GRANT ALL PRIVILEGES ON giteadb.* TO &#x27;gitea&#x27;;FLUSH PRIVILEGES;exit\n\n安装Gitea下载二进制包gitea-1.21.4-linux-amd64\nhttps://dl.gitea.com/gitea/1.21.4/gitea-1.21.4-linux-amd64\nchmod +x gitea-1.21.4-linux-amd64\n\n添加用户groupadd --system gitadduser \\   --system \\   --shell /bin/bash \\   --comment &#x27;Git Version Control&#x27; \\   --gid git \\   --home-dir /home/git \\   --create-home \\   git\n\n创建工作路径mkdir -p /var/lib/gitea/&#123;custom,data,log&#125;chown -R git:git /var/lib/gitea/chmod -R 750 /var/lib/gitea/mkdir /etc/giteachown root:git /etc/giteachmod 770 /etc/gitea\n\n配置Gitea工作路径export GITEA_WORK_DIR=/var/lib/gitea/\n\n复制二进制文件到全局位置cp gitea-1.21.4-linux-amd64 /usr/local/bin/gitea\n\n启动Giteagitea不允许使用root用户运行\nsu gitGITEA_WORK_DIR=/var/lib/gitea/ /usr/local/bin/gitea web -c /etc/gitea/app.ini\n\n\n\n配置Gitea在浏览器输入IP地址+3000端口，访问Gitea的Web界面\n云服务器安全组端口3000要打开，反向代理后可以关闭\ngitea关闭用户注册找到gitea的配置文件gitea&#x2F;conf&#x2F;app.ini，把下面的设置改为true即可:\nROOT_URL = https://git.eviwbh.com/DISABLE_REGISTRATION  = true\n\n\n\nnginx反向代理上传ssl证书\nserver &#123;        listen       443 ssl http2;        listen       [::]:443 ssl http2;    server_name git.eviwbh.com;    location / &#123;        client_max_body_size 512M;        proxy_pass http://localhost:3000;        proxy_set_header Connection $http_connection;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;    &#125;        #证书文件名称        ssl_certificate &quot;/etc/nginx/cert/eviwbh_com.pem&quot;;        #证书私钥文件名称        ssl_certificate_key &quot;/etc/nginx/cert/eviwbh_com.key&quot;;        #ssl_session_cache shared:SSL:1m;        #ssl验证配置        ssl_session_timeout  10m;        #配置加密套件/算法加密，写法遵循openssl标准        ssl_ciphers HIGH:!aNULL:!MD5;        #使用服务器端的首选算法        ssl_prefer_server_ciphers on;        #安全链接可选加密协议        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;&#125;\n\n\n\ngitea自启动vi /etc/rc.local#giteasu - git -c &quot;GITEA_WORK_DIR=/var/lib/gitea/ /usr/local/bin/gitea web -c /etc/gitea/app.ini&quot;chmod +x /etc/rc.d/rc.local\n\n","slug":"gitea","date":"2024-07-30T03:50:33.000Z","categories_index":"开发经验","tags_index":"","author_index":"暗使开开"},{"id":"222b440dd80fa4c997be1565560f0d77","title":"C++面试题","content":"C++面试题简述下 C++ 语言的特点\nC++ 在 C 语言基础上引入了面对对象的机制，同时也兼容C语言。\n\nC++ 有三大特性（1）封装（2）继承（3）多态。\n\nC++ 语言编写出的程序结构清晰、易于扩充，程序可读性好。\n\nC++ 生成的代码质量高，运行效率高，仅比汇编语言慢 10%～20%；\n\nC++ 更加安全，增加了 const常 量、引用、四类 cast 转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try—catch 等等；\n\nC++ 可复用性高，C++ 引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL（StandardTemplate Library）。\n\n同时，C++ 是不断在发展的语言。C++ 后续版本更是发展了不少新特性，如 C++11 中引入了 nullptr、auto变量、Lambda 匿名函数、右值引用、智能指针。\n\n\nC 语言和 C++ 的区别\nC 语言是 C++ 的子集，C++ 可以很好兼容C语言。但是 C++ 又有很多新特性，如引用、智能指针、auto 变量等。\nC++ 是面对对象的编程语言；C 语言是面对过程的编程语言。\nC 语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而 C++ 对此增加了不少新特性来改善安全性，如 const 常量、引用、cast转换、智能指针、try—catch 等等；\nC++ 可复用性高，C++ 引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++ 的STL 库相对于 C 语言的函数库更灵活、更通用。\n\nC++ 结构体和 C 结构体的区别\nC 的结构体内不允许有函数存在，C++ 允许有内部成员函数，且允许该函数是虚函数。\n\nC 的结构体对内部成员变量的访问权限只能是 public，而 C++ 允许 public,protected,private 三种。\n\nC语言的结构体是不可以继承的，C++ 的结构体是可以从其他的结构体或者类继承过来的。\n\nC 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用。\n\n使用区别\nC 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用，例如：\nstruct Student&#123; int iAgeNum; string strName; &#125;typedef struct Student Student2; \t\t// C 中取别名struct Student stu1; \t\t\t\t\t// C 中正常使用Student2 stu2; \t\t\t\t\t\t// C 中通过取别名的使用Student stu3; \t\t\t\t\t\t// C++ 中使用\n\n静态局部变量，全局变量，局部变量的特点\n从作用域考虑\nC++ 里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。\n\n\n从所在空间考虑\n除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。\n\n\n从生命周期考虑\n局部变量在栈上，出了作用域就回收内存。全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。\n\n\n\ni++ 和 ++i 的区别代码示例：\n#include &lt;iostream&gt;int main()&#123; int i = 2; int j = 2; j += i++; // 先赋值后加 std::cout &lt;&lt; &quot;i= &quot; &lt;&lt; i &lt;&lt; &quot;, j = &quot; &lt;&lt; j &lt;&lt; std::endl; //i= 3, j = 4 i = 2; j = 2; j += ++i; // 先加后赋值 std::cout &lt;&lt; &quot;i= &quot; &lt;&lt; i &lt;&lt; &quot;, j = &quot; &lt;&lt; j &lt;&lt; std::endl; //i= 3, j = 5&#125;\n\n\n赋值顺序不同：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。\n\n效率不同：后置 ++ 执行速度比前置的慢。\n\ni++ 不能作为左值，而++i 可以，示例如下：\n\n\nint i = 0;int* p1 = &amp;(++i); // 正确int* p2 = &amp;(i++); // 错误++i = 1; \t  \t   // 正确i++ = 1; \t\t   // 错误\n\n 4.两者都不是原子操作。\n\n结构体和类的区别\nC++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能。struct能包含成员函数吗？ 能！struct能继承吗？ 能！！struct能实现多态吗？ 能！！！\n既然这些它都能实现，那它和class还能有什么区别？\n最本质的一个区别就是默认的访问控制：\n默认的继承访问权限\nstruct是public的，class是private的。\n\nC++面向对象\n\nstatic的作用\n静态分配方式下的内存在程序编译的时候就已经分配好了且存在于程序的整个运行过程。例如 static 变量，其生命周期随程序的结束而结束，而非像一般变量随函数或作用域的结束而结束。\n除了 static 变量，还有一种全局对象 static object，也可以存放在静态存储区。\nstatic是C++中很常用的修饰符，它被用来控制变量的存储方式和可见性。、\n需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见。\n\n变量的声明和定义有什么区别为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但是只在一个地方定义。加入 extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。\n\nextern是什么\nextern int i; //声明，不是定义int i; //声明，也是定义\n\n\n\n","slug":"cpp面试题","date":"2024-07-30T03:50:33.000Z","categories_index":"","tags_index":"C++","author_index":"暗使开开"},{"id":"ce97a94626317b127a6da02030ff4c21","title":"shell","content":"shell编程shell脚本\n开头，以什么shell执行 &#x2F;bash\n#!&#x2F;bin&#x2F;bash\n\n执行\n\nchmod u+x\n.&#x2F;xxx.sh\n\nsh xxx.sh\n\n\n\n\n输出echoecho xxx\necho “xxx”\necho xxx&#x3D;$变量名\n系统变量\nHOME $PWD $SHELL $USER等\n\n显示当前shell中所有变量 set\n\n\n自定义变量\n通常变量名大写\n\n定义变量：变量名&#x3D;值\n值：`函数`或$(函数)  都能得到函数返回值\necho a&#x3D;$(date)\n\n输出变量：echo $变量名\n\n撤销变量：unset 变量\n\n声明静态变量：readonly变量，注意不能unset\n\n\n设置环境变量vim &#x2F;etc&#x2F;profile\n\n把shell变量输出成环境变量&#x2F;全局变量：export 变量名&#x3D;变量值\n\n让修改的配置信息立即生效：source 配置文件\n\n\n多行注释:&lt;&lt;！\nxxxx\nxxxx \n！\n","slug":"shell编程","date":"2024-07-30T03:50:33.000Z","categories_index":"编程语言","tags_index":"shell","author_index":"暗使开开"},{"id":"70249c996b97118912dc8a290aa9ed6e","title":"PHP","content":"PHPphp语法PHP 脚本以 &lt;?php 开头，以 ?&gt; 结尾：\n&lt;?php // 此处是 PHP 代码 ?&gt;&lt;?php// 此处是 PHP 代码?&gt;\n\nPHP 语句以分号结尾（;）\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;PHP页面&lt;/h1&gt;&lt;?phpecho &quot;Hello askk!&quot;;?&gt;&lt;/body&gt;&lt;/html&gt;\n\n输出方法：echo 和 print\necho - 能够输出一个以上的字符串，英文逗号隔开\nprint - 只能输出一个字符串，并始终返回 1\necho 比 print 稍快，并且开销低\n\n&lt;?phpecho &quot;&lt;h2&gt;askk123!&lt;/h2&gt;&quot;;echo &quot;Hello world!&lt;br&gt;&quot;;echo &quot;askk&quot;, &quot; string&quot;, 1, &quot; 2 &quot;;?&gt;\n\n注释&lt;?php// 单行注释# 单行注释/**/?&gt;\n\n变量$a=5;$_a = 5;$b=6;$c=$a+$b;echo $c;\n\n变量命名规则\n变量以 $ 符号开头，其后是变量的名称\n变量名称必须以字母或下划线开头\n变量名称不能以数字开头，不能有空格\n变量名称只能包含字母 数字 字符和 下划线（A-z、0-9 以及 _）\n变量名称对大小写敏感\n\n$txt=&quot;Hello world!&quot;;$a=5;$b=8.5;\n\n不必告知 PHP 变量的数据类型，php会根据它的值，自动把变量转换为正确的数据类型\n命令行的使用可以像python一样在命令行里运行php用cmd或者vscode插件\n可以获取用户输入的内容\n$input = readline(&quot;请输入内容：&quot;); echo &quot;您输入的内容是： &quot; . $input;\n\necho &quot;请输入内容：&quot;; $input = fgets(STDIN); echo &quot;您输入的内容是： &quot; . $input;\n\n\n数据类型字符串、整数、浮点数、逻辑（布尔型）、数组、对象、NULL、资源类型用var_dump() 会返回变量的数据类型和值，一般用于开发调试时使用\n只获取数据类型 echo gettype($a);\n字符串字符串是字符序列，比如 “Hello world!”。\n字符串可以是引号内的任何文本，可以使用单引号或双引号注意双引号和单引号的区别\n$x = &quot;Hello world!&quot;;echo $x;echo &quot;&lt;br&gt;&quot;; $x = &#x27;Hello world!&#x27;;var_dump($x);\n\n整数和数学里的整数有些区别\n\n整数必须有至少一个数字（0-9）\n整数不能包含逗号或空格\n整数不能有小数点\n整数正负均可\n可以用三种格式规定整数：十进制、十六进制（前缀是 0x）或八进制（前缀是 0）\n\n$x = 5985;var_dump($x);echo &quot;&lt;br&gt;&quot;; $x = -345; // 负数var_dump($x);echo &quot;&lt;br&gt;&quot;; $x = 0x8C; // 十六进制数var_dump($x);echo &quot;&lt;br&gt;&quot;;$x = 047; // 八进制数var_dump($x);\n\n浮点数浮点数是有小数点或指数形式的数字\n$x = 10.365;var_dump($x);echo &quot;&lt;br&gt;&quot;; $x = 2.4e3;var_dump($x);echo &quot;&lt;br&gt;&quot;; $x = 8E-5;var_dump($x);\n\n逻辑（布尔值）$x=true;$y=false;\n\n数组在一个变量中存储多个值分为一维数组和多维数组，认识即可，不要深究，后面会专门讲\nprint(&#x27;&lt;pre&gt;&#x27;);//可以格式化var_dump的值$cars=array(&quot;Volvo&quot;,235,&quot;SAAB&quot;);$_cars=[&quot;Volvo&quot;,&quot;BMW&quot;,&quot;SAAB&quot;];var_dump($cars);echo &quot;&lt;hr&gt;&quot;;var_dump($_cars);\n对象需要用到类和封装的知识等学到类的时候再讲\nNull特殊的 NULL 值表示变量无值。NULL 是数据类型 NULL 唯一可能的值注意：可以通过设置变量值为 NULL 来清空变量数据\n$x=&quot;Hello world!&quot;; var_dump($x);$x=null; var_dump($x);\n\nresource 资源类型等学到数据库的时候再讲\n初级实战 - 个人博客的开头部分实战目标：html简单介绍复习变量声明和输出复习注释了解变量重复赋值\nEOF(heredoc) 定界符使用说明\n以 &lt;&lt;&lt;EOF 开始标记开始，以 EOF 结束标记结束\n\n结束标记必须顶头写，独自占一行，不能有缩进和空格\n\n在结束标记末尾要有分号\n\nEOF 可以用任意其它字符代替，开始标记和结束标记相同即可，比如常用大写的 EOT、EOD、EOF 来表示，但是不只限于那几个(也可以用：JSON、HTML等)，只要保证开始标记和结束标记不在正文中出现即可。\n\n位于开始标记和结束标记之间的变量可以被正常解析，但是函数则不可以。在 heredoc 中，变量不需要用连接符 . 或 , 来拼接\n\n当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义。\n\n\n&lt;?php$name=&quot;变量会被解析&quot;;$a=&lt;&lt;&lt;EOF$name&lt;br&gt;看上面的name已经不是name啦！！！&lt;br&gt;EOF;echo $a;echo &#x27;&lt;hr&gt;&#x27;;$a=&lt;&lt;&lt;EOF&lt;a&gt;html格式会被解析&lt;/a&gt;&lt;br/&gt;你看看a标签显示了没？你看看br显示了没？&lt;br&gt;EOF;echo $a;echo &#x27;&lt;hr&gt;&#x27;;echo &lt;&lt;&lt;EOF&quot;双引号外所有被排列好的格式都会被保留&quot;&quot;但是双引号内会保留转义符的转义效果,比如table:\\t和换行：\\n下一行&quot;你看页面里有\\t吗？\\n \\t 和引号没关系吧？那单&#x27;引&#x27;号呢？&#x27;\\t \\n 是否能看到？&#x27;EOF;\n\n运算符\n\n\n\n\n\n\n\n\n注：资料来源于菜鸟教程 www.runoob.com\n算术运算符![[Pasted image 20230922152416.png]]\n&lt;?php $x=10; $y=6;echo ($x + $y); // 输出16echo &#x27;&lt;br&gt;&#x27;;  // 换行 echo ($x - $y); // 输出4echo &#x27;&lt;br&gt;&#x27;;  // 换行 echo ($x * $y); // 输出60echo &#x27;&lt;br&gt;&#x27;;  // 换行 echo ($x / $y); // 输出1.6666666666667echo &#x27;&lt;br&gt;&#x27;;  // 换行 echo ($x % $y); // 输出4echo &#x27;&lt;br&gt;&#x27;;  // 换行 echo -$x;//整数之间的整除，参数也必须是整数，向下取整var_dump(intdiv(10, 3));?&gt;\n\n赋值运算符![[Pasted image 20230922155033.png]]\n&lt;?php $x=10; echo $x; // 输出10 $y=20; $y += 100;$y = $y + 100;echo $y; // 输出120 $z=50;$z -= 25;echo $z; // 输出25 $i=5;$i *= 6;echo $i; // 输出30 $j=10;$j /= 5;echo $j; // 输出2 $k=15;$k %= 4;echo $k; // 输出3?&gt;\n\n\n递增&#x2F;递减运算符![[Pasted image 20230922160114.png]]\n&lt;?php$x=10; echo ++$x; // 输出11 $y=10; echo $y++; // 输出10 $z=5;echo --$z; // 输出4 $i=5;echo $i--; // 输出5?&gt;\n\n比较运算符![[Pasted image 20230922160145.png]]\n&lt;?php$x=100; $y=&quot;100&quot;; var_dump($x == $y);echo &quot;&lt;br&gt;&quot;;var_dump($x === $y);echo &quot;&lt;br&gt;&quot;;var_dump($x != $y);echo &quot;&lt;br&gt;&quot;;var_dump($x !== $y);echo &quot;&lt;br&gt;&quot;; $a=50;$b=90; var_dump($a &gt; $b);echo &quot;&lt;br&gt;&quot;;var_dump($a &lt; $b);?&gt;\n\n逻辑运算符![[Pasted image 20230922160442.png]]\nand 和 &amp;&amp; 的区别， or 和 || 的区别主要体现在优先级： \n\n&amp;&amp;  运算符的优先级比  and  运算符高。 \n这意味着，在一个表达式中， &amp;&amp;  运算符会先被执行，然后才是  and  运算符。\n\n&lt;?php // 在表达式中使用&amp;&amp;运算符$bool = true &amp;&amp; false; // 显示&amp;&amp;运算符的运算结果echo &quot;&amp;&amp;运算符的结果为：&quot;;if($bool)&#123;    echo &#x27;true&#x27;;&#125;else&#123;    echo &#x27;false&#x27;;&#125;echo &#x27;----&#x27;;// 在表达式中使用and运算符$bool = true and false; // 显示and运算符的运算结果echo &quot;and运算符的结果为：&quot;;if($bool)&#123;    echo &#x27;true&#x27;;&#125;else&#123;    echo &#x27;false&#x27;;&#125;?&gt;\n\n阻断效果//or-前面语句值为真，or后面不执行；否则，执行$result = 0 or var_dump(&#x27;执行我的语句&#x27;);  //输出-执行我的语句var_dump($result);  //int 0$result = 2 or var_dump(&#x27;执行我的语句&#x27;);  //不输出var_dump($result);  //int 2\n\n条件语句 (条件分支)if语句仅当指定条件成立时执行代码\nif (条件)&#123;    条件成立时要执行的代码;&#125;\n\nif…else…语句在条件成立时执行一块代码，条件不成立时执行另一块代码\nif (条件)&#123;      条件成立时执行的代码; &#125;  else  &#123;      条件不成立时执行的代码;  &#125;\n\nif…elseif….elseif (条件)&#123;    if条件成立时执行的代码;&#125;elseif (条件)&#123;    elseif条件成立时执行的代码;&#125;elseif (条件)&#123;    elseif条件成立时执行的代码;&#125;else&#123;    条件不成立时执行的代码;&#125;\n\n\nswitch注意：break很重要，不要漏掉\n&lt;?phpswitch (n)&#123;\tcase label1:\t    如果 n=label1，此处代码将执行;\t    break;\tcase label2:\t    如果 n=label2，此处代码将执行;\t    break;\tdefault:\t    如果 n 既不等于 label1 也不等于 label2，此处代码将执行;&#125;?&gt;\n\n什么时候适合用switch？适合条件比较多，并且条件单一固定值匹配时用\n循环让相同的代码块一次又一次地重复运行\nfor 循环用于预先知道脚本需要运行的次数的情况\nfor (初始值; 条件; 增量)&#123;    要执行的代码(叫循环体);&#125;\n\n参数：\n\n初始值：主要是初始化一个变量值，用于设置一个计数器（但可以是任何在循环的开始被执行一次的代码）。\n条件：循环执行的限制条件。如果为 TRUE，则循环继续。如果为 FALSE，则循环结束。\n增量：主要用于递增计数器（但可以是任何在循环的结束被执行的代码）。\n\n注释：上面的初始值和增量参数可为空，或者有多个表达式（用逗号分隔）。\nfor ($i=1,$j=0; $i&lt;=5; )&#123;    echo &quot;数字为 &quot; . $i.$j . PHP_EOL;    $i++;&#125;\n\nwhile 循环只要指定的条件成立，则循环执行代码块，直到指定的条件不成立\nwhile (条件)&#123;    要执行的代码;&#125;\n\n注意避免死循环\n$i=1;while($i&lt;=5)&#123;    echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;;    $i++;&#125;\n\n\ndo…while语句会至少执行一次代码，然后检查条件，只要条件成立，就会重复进行循环\ndo&#123;    要执行的代码;&#125;while (条件);\n\n$i=1;do&#123;    $i++;    echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;;&#125;while ($i&lt;=5);\n\ncontinue和breakcontinuefor ($i=0; $i &lt; 5; $i++) &#123;   if($i == 3)&#123;      continue;  &#125;  echo $i;&#125;\n\nbreakfor ($i=0; $i &lt; 5; $i++) &#123;     if($i&gt;3)&#123;        break;    &#125;    echo $i;&#125;\n\nbreak 2for ($i = 0; $i &lt; 3; $i++) &#123;        echo &quot;外层循环: &quot; . $i . &quot;&lt;br&gt;&quot;;            for ($j = 0; $j &lt; 5; $j++) &#123;            echo &quot;内层循环: &quot; . $j . &quot;&lt;br&gt;&quot;;                    if ($j == 2) &#123;                break 2; // 跳出两层循环            &#125;        &#125; &#125;echo &#x27;已跳出全部循环&#x27;;\n\n在while中使用continue break和break2$a = 10;while ($a &lt;= 20) &#123;    $a++;    if($a == 15)&#123;        //continue;        break;    &#125;    echo $a.&#x27;---&#x27;;&#125;\n\n$a = 10;while ($a &lt;= 20) &#123;    $a++;    if($a == 15)&#123;        for ($i=0; $i &lt; 5; $i++) &#123;             if($i==3)&#123;                break 2;            &#125;            echo &#x27;&lt;br&gt;&#x27;.$i.&#x27;&lt;br&gt;&#x27;;        &#125;    &#125;    echo $a.&#x27;---&#x27;;&#125;\nforeach 循环用于遍历数组，等学数组一起讲\n数组数组能够在单个变量中存储多个值，并且可以根据 键 访问其中的 值 \n数值数组$askk = array(&quot;askk1&quot;,&quot;askk2&quot;,&quot;askk3&quot;,&quot;askk4&quot;,&quot;askk5&quot;);$askk = [&quot;askk1&quot;,&quot;askk2&quot;,&quot;askk3&quot;,&quot;askk4&quot;,&quot;askk5&quot;];var_dump($askk[1]);var_dump($askk[5]);\n\n$askk2 = [];$askk2[3] = &#x27;3&#x27;;var_dump($askk2);\n\n\n关联数组关联数组是使用您分配给数组的指定的键的数组\n$age=[&quot;askk&quot;=&gt;&quot;35&quot;,&quot;dong&quot;=&gt;&quot;37&quot;];//或者$age[&#x27;askk&#x27;]=&quot;35&quot;;  $age[&#x27;dong&#x27;]=&quot;37&quot;;\n\n获取数组的长度 - count() 函数echo count($askk);\n\n遍历数组for($i=0;$i&lt;count($askk);$i++) &#123;\techo $askk[$i];\techo &quot;&lt;br&gt;&quot;; &#125;foreach ($askk as $value)&#123;    要执行代码;&#125;foreach ($askk as $key =&gt; $value)&#123;    要执行代码;&#125;\n\nfor可以，while也可以，但最常用的是foreach\n多维数组多维数组是包含一个或多个数组的数组\n$askkArr = [  [      &quot;免费课&quot;=&gt;[          &quot;askk课&quot;,          &quot;php&quot;,          &quot;python&quot;      ],      &quot;体验课&quot;=&gt;[          &quot;php&quot;,          &quot;js&quot;,          &quot;vue&quot;      ]  ],  [      &quot;收费课&quot;=&gt;[          &quot;油猴脚本&quot;,          &quot;浏览器插件&quot;,          &quot;666&quot;      ]  ]];print_r( $askkArr );\n\n$askkArr = [  &quot;test&quot; =&gt; [       &quot;免费课&quot;=&gt;[           &quot;askk课&quot;,           &quot;php&quot;,           &quot;python&quot;,       ],       &quot;体验课&quot;=&gt;[           &quot;php&quot;,           &quot;js&quot;,           &quot;vue&quot;,       ]   ],  &quot;product&quot; =&gt; [       &quot;免费课&quot;=&gt;[           &quot;产品1&quot;,           &quot;产品2&quot;,       ],       &quot;体验课&quot;=&gt;[           &quot;产品3&quot;,           &quot;产品4&quot;,       ]   ] ]; print_r( $askkArr );\n遍历多维数组\nforeach ($askk as $key =&gt; $value)&#123;    要执行代码;\tforeach ($value as $kk =&gt; $vv)\t&#123;\t    要执行代码;\t&#125;&#125;\n\n初级实战2 - 个人博客的开头部分实战目标：\n\n复习运算符的使用\n复习条件语句的使用\n复习循环\n学会使用数组\n\n任务：循环数组：输出顶部导航栏，输出博客标题和时间条件语句：如果为第一个导航，则给出突出显示运算：输出数字的大小从大到小排列\n函数函数是一段可重复使用的代码块，可以将一系列操作封装起来，使代码更加模块化、可维护和可重用，来大大节省我们的开发时间和代码量，提高编程效率。\n内置函数内置函数有很多，之前学的print_r() count() 就是一个内置函数，获取当前时间 time()，date(‘Y-m-d H:i:s’)\n这节我们主要讲自定义函数\n创建（定义）函数 和 调用PHP 函数准则：\n\n函数的名称应该提示出它的功能\n函数名称以字母或下划线开头（不能以数字开头）\n\nfunction functionName() &#123; // 要执行的代码 &#125;//调用functionName();\n\nfunction test()&#123;    echo &#x27;我的名字是：写代码的askk&#x27;;&#125;test();// 获取当前的时间function nowTime()&#123;\techo date(&#x27;Y-m-d H:i:s&#x27;);&#125;nowTime();\n\n添加参数为了给函数添加更多的功能，我们可以添加参数，参数类似变量\nfunction myName($name)&#123;\techo &quot;我的名字是：$name&quot;;&#125;myName(&quot;askk&quot;);\n\n// 获取当前的时间function nowTime($type)&#123;    if($type==&quot;time&quot;)&#123;        echo date(&#x27;Y-m-d H:i:s&#x27;);    &#125;    else if($type==&quot;day&quot;)&#123;        echo date(&#x27;Y-m-d&#x27;);    &#125;&#125;nowTime(&quot;time&quot;);\n\n多个参数function plus($a,$b)&#123;  echo $a+$b;&#125;plus(2,3);\n\n//严格模式declare(strict_types=1);function plus(int $a,int $b)&#123;  echo $a+$b;&#125;plus(&#x27;2&#x27;,&#x27;13&#x27;);\n\n返回值return ， 可有可无，但一般都有\nfunction plus($a,$b)&#123;  return $a+$b;&#125;echo plus(2,3);\n\n变量作用域讲完了函数，就可以学习前面提到过的变量作用域了\n变量的作用域是脚本中变量可被引用&#x2F;使用的部分。\n局部 和 全局(global) 作用域\n在所有函数外部定义的变量，拥有全局作用域\n除了函数外，全局变量可以被脚本中的任何部分访问\n要在一个函数中访问一个全局变量，需要使用 global 关键字\n函数内部声明的变量是局部变量，仅能在函数内部访问\n\n$askk=&quot;写代码的askk&quot;;function test()&#123;\tglobal $askk;\t$age=&quot;35&quot;;\techo $askk;&#125;test();echo $age;\n\nstatic 作用域当一个函数完成时，它的所有变量通常都会被删除。然而，有时候希望某个局部变量不要被删除。要做到这一点，请在第一次声明变量时使用 static 关键字\n每次调用该函数时，该变量将会保留着函数前一次被调用时的值，但是该变量仍然是函数的局部变量\nfunction myTest()&#123;    static $a=0;    echo $a;    $a++;    echo PHP_EOL;    // 换行符&#125; myTest();myTest();myTest();\n\n函数的参数作用域参数是通过调用代码将值传递给函数的局部变量\nfunction test($askk)&#123;\techo $askk;&#125;test(&#x27;askk&#x27;);var_dump($askk);\n\nunset和isset函数unset()可以删除变量，isset() 可以判断变量是否存在\n$askk=&quot;写代码的askk&quot;;function test()&#123;\t// global $askk;\t$age=&quot;35&quot;;    var_dump(isset($age));\tunset($age);    var_dump(isset($age));&#125;test();var_dump($askk);\n\n\n超级全局变量- $GLOBALS- $_SERVER- $_REQUEST- $_POST- $_GET- $_FILES- $_ENV- $_COOKIE- $_SESSION\n\n$GLOBALS是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。\nprint_r($GLOBALS);$askk=&quot;askk&quot;;$age=35;function test3()&#123;\tglobal $askk,$age;\t$age = &quot;38&quot;;    $askk = &quot;写代码的askk&quot;;&#125;test3();echo $age;echo $askk;\n\n\n$askk=&quot;askk&quot;;$age=35;function test2()&#123;    $GLOBALS[&quot;age&quot;]=&quot;38&quot;;    $GLOBALS[&quot;askk&quot;] = &quot;写代码的askk&quot;;    echo $GLOBALS[&quot;askk&quot;].&#x27;---&#x27;.$GLOBALS[&quot;age&quot;];&#125;test2();echo PHP_EOL; echo $age;echo $askk;\n\n$_SERVER\n$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。\n这个数组中的项目由 Web 服务器创建。\n不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。\n\nprint_r($_SERVER)\n\n资料来自 PHP 超级全局变量 | 菜鸟教程 (runoob.com)\n![[Pasted image 20230927152355.png]]![[Pasted image 20230927152441.png]]\n初级实战3 - 函数的使用\n编写一个函数getFactors，接受一个正整数参数，计算并返回该整数的所有因子（除了1和自身的所有正整数因子）。\n注：因子是能够整除给定数的正整数（例如，对于数值 24，它的因子包括 1、2、3、4、6、8、12 和 24。因为这些数都可以整除 24，没有余数。）\n补充知识：怎么往数组内插入数据\n要求使用函数\n\n其他运算符数组运算符\n+号运算符（合并）注意：只会保留第一个数组中的键值对，而忽略后面数组中相同键名的元素，如果想要合并两个数组并覆盖相同键名的元素，可以使用array_merge()函数\n\n$a = [  &quot;m&quot; =&gt; &quot;测试&quot;,  &quot;n&quot; =&gt; &quot;askk&quot;];$b = [  &quot;m&quot; =&gt; &quot;测试2&quot;,  &quot;o&quot;=&gt;&quot;测试o&quot;,  &quot;p&quot;=&gt;&quot;测试p&quot;,  &quot;q&quot;=&gt;[      &quot;cs&quot;=&gt;&quot;二维测试&quot;  ]];$c=[  &quot;m&quot; =&gt; &quot;测试3&quot;,  &quot;cc&quot;=&gt;123];print_r($a+$b+$c);\n\n\n&#x3D;&#x3D;\n&#x3D;&#x3D;&#x3D;  有相同的键&#x2F;值对，且顺序相同、类型相同   $a = [1,2,3];   $b = [1,2,&quot;3&quot;];var_dump($a == $b);var_dump($a === $b);   $a = [       &quot;a&quot;=&gt;123,       &quot;b&quot;=&gt;456,   ];   $b = [       &quot;b&quot;=&gt;456,       &quot;a&quot;=&gt;123,   ];   var_dump($a == $b);   var_dump($a === $b);\n!&#x3D; 和 &lt;&gt;\n!&#x3D;&#x3D;\n\n三元运算符 ?:// $name = $username?$username:&quot;测试&quot;;$name = isset($username)?$username:&quot;测试&quot;;// $name = $username?:&quot;测试&quot;;var_dump($name);\n\n空合并运算符 ??用于简化处理可能为null的变量或数组元素的情况。它的作用是判断一个变量是否未定义或者为null，如果未定义或为null，则返回指定的默认值；否则返回该变量的值\n$name = $username ?? &quot;askk&quot;;echo $name;\n组合比较符 &lt;&#x3D;&gt;可比较整型 浮点型 字符串\n$c = $a &lt;=&gt; $b; \n如果 $a &gt; $b, 则 $c 的值为 1如果 $a &#x3D;&#x3D; $b, 则 $c 的值为 0如果 $a &lt; $b, 则 $c 的值为 -1\n$a = &quot;acd&quot;;$b = &quot;ace&quot;;var_dump($a &lt;=&gt; $b);\n\n比较数据类型的比较虽然 PHP 是弱类型语言，但也需要明白变量类型及它们的意义因为我们经常需要对 PHP 变量进行比较，包含松散和严格比较。\n\n松散比较：使用两个等号 &#x3D;&#x3D; 比较，只比较值，不比较类型。\n严格比较：用三个等号（全等） &#x3D;&#x3D;&#x3D; 比较，除了比较值，也比较类型。\n\n例如，”42” 是一个字符串而 42 是一个整数。false 是一个布尔值而 “false” 是一个字符串。\n&lt;?phpif(42 == &quot;42&quot;) &#123;    echo &#x27;1、值相等&#x27;;&#125; echo PHP_EOL; // 换行符 if(42 === &quot;42&quot;) &#123;    echo &#x27;2、类型相等&#x27;;&#125; else &#123;    echo &#x27;3、类型不相等&#x27;;&#125;?&gt;\n\n问题：如果只想比较类型是否相同，怎么比较？\n比较undefined、 0、false、null、空值分析 isset() is_null() empty()的区别\nvar_dump(!isset($name));var_dump(is_null($name));\n\n$name = null;var_dump(!isset($name));var_dump(is_null($name));var_dump(empty($name));\n\nempty注意：empty() 函数对于未定义的变量也会返回true，因此在使用empty() 函数之前，应该确保变量已经被定义\n$var1 = &quot;&quot;; // 空字符串$var2 = 0; // 整数0$var3 = null; // null$var4 = false; // false$var5 = array(); // 空数组 []var_dump(empty($var1));var_dump(empty($var2));var_dump(empty($var3));var_dump(empty($var4));var_dump(empty($var5));\n\n\n字符串相关函数$strZh = &quot;我是写代码的askk&quot;;$strEn = &quot;Hello askk,I am a person who loves to share&quot;;\n\nstrlen()  获取字符串长度 \n\nstrpos() 在字符串内查找一个字符或一段指定的文本，返回第一次出现的位置或false\n\nstripos() 同上，但不区分大小写\n\nstrrpos() 同上上，返回最后一次出现的位置或false\n\nstrripos() 同上，但不区分大小写\n\nexplode()  把字符串打散成数组\n\nimplode() 把数组拼接成字符串\n\nstrtoupper() 把字符串转换为大写\n\nstrtolower() 把字符串转换为小写\n\nucfirst() 将单词的首字母转换为大写\n\nlcfirst() 将单词的首字母转换为小写\n\nucwords() 将字符串中每个单词的首字母转换为大写\n\nstr_replace($search, $replace, $string) 将字符串中的某个子字符串替换为另一个字符串\n\nstrrev()：将字符串反转\n\ntrim()：去除字符串两端的空格\n\nsubstr() 截取字符串的一部分\n\nmb_substr() 截取字符串的一部分(中文)  需要安装扩展mbstring\n\n\n初级实战4 - 字符串函数的使用编写一个函数，接受一个英文字符串参数”Hello askk, HOW Are You?”，将字符串中的每个单词的首字母转换为小写，并返回修改后的字符串。\n\n考察字符串的函数使用\n考察数组的使用\n考察循环的使用\n\n$str = &#x27;Hello askk,HOW,Are,You&#x27;;$arr = explode(&#x27; &#x27;,$str);//   print_r($arr);$newArr = [];foreach ($arr as $key =&gt; $value) &#123;  if(strpos($value,&#x27;,&#x27;) !== false)&#123;      $valueArr = explode(&#x27;,&#x27;,$value);      $newValueArr = [];      foreach ($valueArr as $kk =&gt; $vv) &#123;          $newValueArr[] = lcfirst($vv);       &#125;      $newArr[] = implode(&#x27;,&#x27;,$newValueArr);  &#125;  else&#123;      $newArr[]= lcfirst($value);   &#125;&#125;echo implode(&#x27; &#x27;,$newArr);\n\n数组相关函数$array = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;];\n\narray()：创建一个数组。 \ncount()：返回数组中元素的数量。 \narray_push($array, $newElement)：将一个或多个元素添加到数组的末尾。\narray_unshift($array, $newElement)：将一个或多个元素添加到数组的开头。 \narray_pop()：删除并返回数组中的最后一个元素。 \narray_shift()：删除并返回数组中的第一个元素。 \narray_slice()：从数组中提取一部分元素，组成新的数组。 \narray_merge()：合并两个或多个数组。 \narray_reverse()：反转数组中的元素的顺序。\nin_array()：检查数组中是否存在某个值。 \narray_key_exists()：检查数组中是否存在某个键。 \narray_keys()：返回数组中的所有键，组成新数组。 \narray_values()：返回数组中的所有值，组成新数组。 \narray_search()：在数组中搜索给定的值，并返回对应的键。 \narray_unique()：移除数组中的重复值（原数组不变）。\nmax() min() 最大值和最小值\nsort() 数组排序（升序）\nrsort() 数组排序（降序）\narray_sum() 数组求和\narray_product() 数组求乘积\n\n暂时就想到这些函数，后面如果我们遇到了会再做补充。\n初级实战5 - 数组函数的使用编写一个PHP函数 testArray($numbers) ，该函数接收一个整数数组 $numbers 作为参数，并返回一个关联数组，包含以下统计信息：\n\n“count” ：数组中的元素个数。 \n“sum” ：数组中所有元素的总和。 \n“average” ：数组中元素的平均值。 \n“max” ：数组中的最大值。 \n“min” ：数组中的最小值。 \n“sorted” ：按照从小到大排序的数组。\n\n测试数组：\n$numbers = [5, 9, 3, 2, 7, 1, 6];\n\n时间、日期相关知识函数\ntime() 获取当前时间戳（10位），例如：1697520502\n\nmicrotime(true) 返回一个浮点数时间戳（秒数和微秒数的总和）floor(microtime(true)*1000)\n\ndate(格式，时间戳) 日期格式化\n$time = time();echo date(&#x27;Y-m-d H:i:s&#x27;,$time);\nstrtotime(string) \nstrtotime(&quot;next Monday&quot;);$baseTime = strtotime(&quot;2023-10-01&quot;);echo strtotime(&quot;next Monday&quot;, $baseTime);$baseTime = time();echo strtotime(&quot;+1 day&quot;, $baseTime);\n\nmktime($hour, $minute, $second, $month, $day, $year)  生成时间戳\n\ndate_create() 来创建一个日期时间对象 date_create(&#39;2023-11-01&#39;)\n\ndate_format() 用于将日期和时间格式化为指定的字符串格式\ndate_format($date, &quot;Y-m-d H:i:s&quot;);date_format($date, &quot;Y年m月d日 H:i:s&quot;)\n\ndate_diff() 计算两个日期之间的差\n$date1 = date_create(&#x27;2023-10-20 12:00:00&#x27;);$date2 = date_create(&#x27;2023-10-21 12:00:00&#x27;);$diff = date_diff($date2, $date1);echo $diff-&gt;format(&#x27;%a 天&#x27;);echo $diff-&gt;format(&#x27;%m 月&#x27;);echo $diff-&gt;format(&#x27;%y 年 %m 月 %d 天&#x27;);-  %Y ：完整年份的差异 -  %y ：年份的差异（两位数） -  %m ：月份的差异 -  %d ：天数的差异 -  %a ：总共的天数差异 -  %H ：小时的差异 -  %h ：小时的差异（12小时制） -  %I ：分钟的差异 -  %S ：秒数的差异 -  %R ：正负-  %r ：正负(必须是负的才会显示)\n\nstrftime($format, $timestamp) ：根据指定的格式，将时间戳格式化为可读的日期和时间字符串，支持本地化的日期和时间格式 (php8已废弃)。\n$timestamp = time();$dateString = strftime(&quot;%A %Y-%m-%d %H:%M:%S&quot;, $timestamp);echo $dateString;\ngmdate($format, $timestamp) ：根据指定的格式，将GMT时间戳格式化为可读的日期和时间字符串。gmdate() 和 date()的区别gmdate() 函数使用格林威治标准时间（GMT）作为默认的日期&#x2F;时间基准，会忽略服务器的时区设置，始终返回格林威治标准时间（GMT）的日期和时间；date() 函数则使用本地时间作为基准，它会根据当前服务器的时区设置来格式化日期和时间。\n\ndate_default_timezone_set($timezone) ：设置默认的时区。\n\n\n“UTC”, “localtime”本地时区, “Asia&#x2F;Shanghai”上海\n注意：只能在脚本开始时设置默认时区，不能在运行时动态设置。\n\ntimezone_identifiers_list() ：返回所有可用时区标识符的数组。\n\nDateTime对象$dateTime = new DateTime(&quot;2023-11-01 12:34:56&quot;);//增加或减少指定的时间间隔$dateTime-&gt;modify(&#x27;+1 day&#x27;);$dateTime-&gt;modify(&#x27;-1 hour&#x27;);//设置日期部分 setDate($year, $month, $day)$dateTime-&gt;setDate(2024, 1, 3);//设置时间部分 setTime($hour, $minute, $second)$dateTime-&gt;setTime(13, 1, 5);// 设置时区$dateTime-&gt;setTimezone(new DateTimeZone(&quot;Asia/Shanghai&quot;)); // 获取时区$dateTimeZone = $dateTime-&gt;getTimezone(); print_r($dateTimeZone-&gt;getName());print_r($dateTimeZone-&gt;getLocation());//将日期时间格式化为指定的字符串格式echo $dateTime-&gt;format(&quot;Y-m-d H:i:s&quot;);//获取时间戳$timestamp = $dateTime-&gt;getTimestamp();echo $timestamp;//计算时间差$dateTime2 = new DateTime(&#x27;2023-12-05&#x27;);$diff = $dateTime-&gt;diff($dateTime2);echo $diff-&gt;format(&#x27;%R %m %d %h %i %s&#x27;);\n\n$datetime = new DateTime(&#x27;2024-01-01&#x27;);$interval = new DateInterval(&#x27;P1D&#x27;); // 一天的时间间隔$datetime-&gt;add($interval);//$datetime-&gt;sub($interval);echo $datetime-&gt;format(&#x27;Y-m-d&#x27;);\n特殊的变量写法和常量交流社区地址：https://askk.fun\n特殊的变量写法$a =&#x27;askk&#x27;;$$a = &quot;测试&quot;;echo $a;echo &#x27; ---- &#x27;;echo $$a;echo &#x27; ---- &#x27;;echo $askk;\n\n实际使用场景：\nfor ($i=0; $i &lt; 5; $i++) &#123;     $a = &quot;askk&quot;.$i;    $$a = &quot;测试-&quot;.$i;&#125;echo $askk1;echo $askk2;\n常量常量值被定义后，在脚本的其他任何地方都不能被改变。命名规则和变量类似，严格区分大小写，但无需$符注意： 默认是全局的，可以在整个运行的脚本的任何地方使用。\ndefine(&quot;askk&quot;, &quot;写代码的askk askk.fun&quot;);echo askk;echo &#x27;&lt;hr&gt;&#x27;;const askk1 = &quot;猫大叔&quot;;echo askk1;$a = 2;define(&quot;askk&quot;.$a, &quot;askk1&quot;);echo constant(&quot;askk&quot;.$a);echo &#x27;&lt;hr&gt;&#x27;;\n\n实际使用场景：\nfor ($i=0; $i &lt; 5; $i++) &#123;     $a = &quot;askk&quot;.$i;    // $$a = &quot;测试-&quot;.$i;    define($a,&#x27;测试-&#x27;.$i);&#125;echo askk1;echo askk2;\nconst和define的区别\nconst不能在条件语句中定义常量\n\n$a = 1;if($a==1)&#123;    define(&quot;askk&quot;.$a, &quot;askk1&quot;);    echo constant(&quot;askk&quot;.$a);        const askk2 = &quot;猫大叔&quot;;    echo askk2;&#125;\n\n\n\nconst用于类成员变量的定义，define不可以用于类成员变量的定义，可用于全局常量。\nconst可在类中使用，define不能\n\nclass ceshi &#123;        const Ceshi = &#x27;askk&#x27;;    public function cc()    &#123;        define(&#x27;MS&#x27;,&#x27;写代码的askk&#x27;);        echo self::Ceshi;    &#125;&#125;$c = new ceshi;$c-&gt;cc();echo &#x27;----&#x27;;echo MS;\n\n\n常量和变量的区别：\n常量前面没有美元符号($)，而且不能有\n\n常量可以不用理会变量的作用域在任何地方定义和访问\n\n常量一旦定义就不能重新定义或取消定义\n\n常量的值只能是标量（字符串、整数、浮点数、布尔值）,注意：现在也支持数组了\n\n\n获取所有的常量\nget_defined_constants()get_defined_constants(true)get_defined_constants(true)[&quot;user&quot;]\n\n魔术常量魔术常量：它的值随着它在代码中的位置改变而改变\n__LINE__文件中的当前行号\necho &#x27;这是第 &quot; &#x27; . __LINE__ . &#x27; &quot; 行&#x27;;\n__FILE__文件的完整路径和文件名，包含（盘符）根目录\necho &#x27;该文件的完整路径为 &quot; &#x27; . __FILE__ . &#x27; &quot; &#x27;;\n\n__DIR__文件所在的目录\necho &#x27;该文件位于 &quot; &#x27; . __DIR__ . &#x27; &quot; &#x27;;\n__FUNCTION__该函数被定义时的名字（区分大小写）\nfunction test() &#123;    echo  &#x27;函数名为：&#x27; . __FUNCTION__ ;&#125;test();\n\n__CLASS__该类被定义时的名字（区分大小写）\n&lt;?phpclass testClass &#123;    function test() &#123;        echo &#x27;类名为：&#x27;  . __CLASS__ . &quot;&lt;br&gt;&quot;;        echo  &#x27;函数名为：&#x27; . __FUNCTION__ ;    &#125;&#125;$t = new testClass();$t-&gt;test();?&gt;\n\n\n__NAMESPACE__命名空间\nnamespace MyProject; echo &#x27;命名空间为：&quot;&#x27;, __NAMESPACE__, &#x27;&quot;&#x27;; // 输出 &quot;MyProject&quot;\n__METHOD__包含了：命名空间 类名 函数名\nnamespace askk;class MyClass &#123;    public function myMethod() &#123;        echo __METHOD__; // 输出：askk\\MyClass::myMethod    &#125;&#125;$obj = new MyClass();$obj-&gt;myMethod();\n\n__TRAIT__当前使用的 trait 的名称\ntrait MyTrait &#123;    public function myMethod() &#123;        echo &quot;trait的名称为: &quot; . __TRAIT__;    &#125;&#125;class MyClass &#123;    use MyTrait;&#125;$obj = new MyClass();$obj-&gt;myMethod();\n\n包含文件在当前文件内引入其他PHP文件、HTML文件或文本文件等，一般用于包含公共方法，公共页面等，例如header footer sider等网页通用部分。\ninclude 和 require 语句区别：include 和 require 除了处理错误的方式不同之外，在其他方面都是相同的：\n\nrequire 生成一个致命错误（E_COMPILE_ERROR），在错误发生后脚本会停止执行。\ninclude 生成一个警告（E_WARNING），在错误发生后脚本会继续执行。\n\n因此：如果你希望被包含的文件是必需的且缺少文件会导致脚本无法正常运行，应使用require（推荐）。如果你希望被包含的文件是可选的，或者即使缺少文件也希望脚本继续执行，可以使用include。\n例如：header.php&lt;?php \t$siteTitle = &quot;askk星球(askk.fun)&quot;;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;?php echo $siteTitle;?&gt;&lt;/title&gt;&lt;/head&gt;\n\nindex.php&lt;?php include &#x27;header.php&#x27;; ?&gt;&lt;body&gt;&lt;h1&gt;欢迎来到&lt;?php echo $siteTitle;?&gt; !&lt;/h1&gt;&lt;p&gt;有问必答。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\ninclude_once 和 require_once 语句和上面的一样，但他只会调用一次，防止重复调用\n面向对象（OO）概念对象：在现实世界里我们所面对的事情都是对象，如苹果 猫 电视机等。而在面向对象的程序设计(OOP)中，对象是一个由信息及对信息进行处理的描述所组成的整体，是对现实世界的抽象。\n例如：小猫 名字：Tom，性别：公，花色：橘色；会叫，会吃饭，会打闹小狗 名字：Jack，性别：公，花色：黑色；会叫，会吃饭，会打闹\n区分：谁在叫，谁在吃饭，谁在打闹\n面向对象：\n面向对象是一种编程思想和方法，它将程序中的数据和操作数据的方法封装在一起，形成”对象”，并通过对象之间的交互和消息传递来完成程序的功能。\n面向对象编程(OOP)强调数据的封装、继承、多态和动态绑定等特性，使得程序具有更好的可扩展性、可维护性和可重用性。\n\n对象的主要三个特性：\n对象的行为：对象可以执行的操作，比如：开灯，关灯就是行为。\n对象的形态：对对象不同的行为是如何响应的，比如：颜色，尺寸，外型。\n对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同（在面向对象编程中，对象的表示通常通过类来实现）。\n\n面向对象编程的三个主要特性：\n封装：指将对象的属性和方法封装在一起，使得外部无法直接访问和修改对象的内部状态。通过使用访问控制修饰符（public、private、protected）来限制属性和方法的访问权限，从而实现封装。\n\n继承：指可以创建一个新的类，该类继承（extends）了父类的属性和方法，并且可以添加自己的属性和方法。通过继承，可以避免重复编写相似的代码，并且可以实现代码的重用。\n\n多态：指可以使用一个父类类型的变量来引用不同子类类型的对象，从而实现对不同对象的统一操作。多态可以使得代码更加灵活，具有更好的可扩展性和可维护性。在 PHP 中，多态可以通过实现接口（interface）和使用抽象类（abstract class）来实现。\n\n\n类（class）\n定义了一件事物的抽象特点。\n类的定义包含了数据的形式以及对数据的操作。\n\n类的定义和调用类的定义class Animal &#123;\tpublic $name = &quot;小猫仔&quot;;    public function eat() &#123;        echo &quot; 在吃饭.&quot;;    &#125;&#125;\n\n类的调用new 实例化对象\n$cat = new Animal;//$cat = new Animal();echo $cat-&gt;name;$cat-&gt;eat();\n\n方法和属性类方法（函数）class Animal &#123;\tpublic $name = &quot;小猫仔&quot;;    public function eat() &#123;        echo &quot; 在吃饭.&quot;;    &#125;    function say() &#123;        echo &quot; 在说话.&quot;;    &#125;&#125;\n$this代表自身的对象\nclass Animal &#123;\tpublic $name = &quot;小猫仔&quot;;    public function eat() &#123;        echo $this-&gt;name.&quot; 在吃饭.&quot;;    &#125;    function say() &#123;        echo $this-&gt;name.&quot; 在说话.&quot;;    &#125;&#125;$cat = new Animal;$cat-&gt;name = &quot;小花&quot;;$cat-&gt;say();$dog = new Animal;$dog-&gt;name = &quot;小黑&quot;;$dog-&gt;say();\n访问控制关键字 public、private、protected\n\npublic（公有）：公有的类成员可以在任何地方被访问。\nprotected（受保护）：受保护的类成员则可以被其自身以及其子类和父类访问（咱家的）。\nprivate（私有）：私有的类成员则只能被其定义所在的类访问（自己的）。\n\n__construct构造函数\n构造函数是一种特殊的方法，在创建一个新对象时，它会被自动调用。\n它可以用来 初始化 对象的属性或执行其他必要的操作\n没有返回值\n\n  class Animal &#123;\tprivate $name;\tprivate $birth;\tprivate $age;    public function __construct($name,$birth)    &#123;        $this-&gt;name = $name;        $this-&gt;birth = $birth;                $days = (time() - strtotime($this-&gt;birth))/3600/24;        $this-&gt;age = floor($days);    &#125;    public function eat() &#123;        echo  $this-&gt;name.&quot; 在吃饭.&quot;;    &#125;&#125;$cat = new Animal(&quot;猫仔&quot;,&quot;2023-05-23&quot;);echo $cat-&gt;name;echo &#x27; -- &#x27;;echo $cat-&gt;birth;echo &#x27; -- &#x27;;echo $cat-&gt;age;\n\n__destruct析构函数\n析构函数是一种特殊的方法，它在对象被销毁时自动调用\n它可以用来执行一些清理操作，例如释放资源或关闭数据库连接。\n当对象不再被引用或脚本执行结束时，析构函数会被自动调用。\n\nclass MyClass &#123;    public function say($i)    &#123;      echo &#x27;saying-&#x27;.$i;    &#125;    public function __destruct() &#123;        echo &quot;析构函数被调用\\n&quot;;    &#125;&#125;// 创建对象$obj = new MyClass();// 执行其他操作...for ($i=0; $i &lt; 4; $i++) &#123;    if($i==3)&#123;        unset($obj);    &#125;    if($obj)        $obj-&gt;say($i);&#125;\n\nstatic 静态变量 和 self「静态」指的是无需对类进行实例化，就可以直接调用这些属性和方法所有对静态变量进行的操作都会对所有对象起作用举例：小猫小狗听到指令来吃饭，指令变化，全部都要听从\npublic static $cat = &quot;askk&quot;;echo self::$cat;\n类常量静态属性与类常量相似，唯一的区分是类常量不可以更改，静态属性可以更改使用场景：所有的对象共用一个属性\nconst askk = &quot;askk&quot;;echo self::askk;\n\n\nstatic 静态方法public static function say() &#123;        echo self::$name;&#125;\n\n可以调用静态方法、静态变量可以调用非静态方法、非静态变量\npublic function eat() &#123;        echo $this-&gt;name.&quot; 在吃饭.&quot;;&#125;public static function say() &#123;        echo (new self)-&gt;eat();&#125;\n\n类的继承（extends）：指可以创建一个新的类，该类继承（extends）了父类的属性和方法，并且可以添加自己的属性和方法。通过继承，可以避免重复编写相似的代码，并且可以实现代码的重用。\n注意：继承不一定能访问\nclass Animal &#123;    public $name=&quot;小动物&quot;;    protected $age=3;    private $birth=&#x27;2023&#x27;;&#125;class Cat extends Animal &#123;&#125;var_dump(new Animal);var_dump(new Cat);\n\nclass Animal &#123;    protected $name;    public function __construct($name) &#123;        $this-&gt;name = $name;    &#125;    public function eat() &#123;        echo $this-&gt;name . &quot; 在吃饭.&quot;;    &#125;&#125;class Cat extends Animal &#123;    public function meow() &#123;        echo $this-&gt;name . &quot; 在喵呜.&quot;;    &#125;&#125;$cat = new Cat(&quot;Tom&quot;);var_dump($cat);$cat-&gt;eat();  // 继承自父类 Animal 的方法$cat-&gt;meow();  // 子类 Cat 自己的方法\n\n方法和属性重写如果从父类继承的方法或属性不能满足子类的需求，可以对其进行改写\nfinal 关键字作用：\n\n防止类被继承\n防止类的方法被重写\n\n如果在一个类前加final，那么这个类就不能被继承；\nfinal class myClass &#123;    // 类的内容&#125;\n如果在一个方法前加final，那么这个方法就不能被重写\nfinal public function eat() &#123;    echo $this-&gt;name . &quot; 在吃饭.&quot;;&#125;\n\n注意：final不能用于属性\n调用父类方法parent::parent::__construct()\n静态延迟绑定 static是指在运行时根据实际调用的类来确定静态方法或属性的绑定语法：static::$name\nclass Animal &#123;    protected static $name=&quot;小动物&quot;;    public static function eat() &#123;        echo self::$name. &quot; 在吃饭.&quot;;        echo &#x27; ---- &#x27;;        echo static::$name. &quot; 在吃饭.&quot;;    &#125;&#125;class Cat extends Animal &#123;    protected static $name=&quot;小猫&quot;;&#125;Animal::eat();Cat::eat();\n\n类的多态\n多态性允许不同类的对象对相同的消息作出不同的响应。\n多态性通过方法重写（覆盖）和方法重载来实现。\n方法重写是指子类重写父类的方法，以改变方法的实现细节。\n方法重载是指在同一个类中根据参数个数或类型不同来实现不同功能。\n需要注意的是，多态性只适用于继承关系的类。子类必须重写父类的方法才能实现多态性。\n\nclass Animal &#123;    protected $name=&quot;动物&quot;;    public function makeSound() &#123;        echo &quot;$this-&gt;name 在吼叫。&quot;;    &#125;&#125;class Dog extends Animal &#123;    protected $name=&quot;小狗&quot;;    public function makeSound() &#123;        echo &quot;$this-&gt;name 在汪汪。&quot;;    &#125;&#125;class Cat extends Animal &#123;    protected $name=&quot;小猫&quot;;    public function makeSound() &#123;        echo &quot;$this-&gt;name 在喵喵。&quot;;    &#125;&#125;$animal = new Animal();$dog = new Dog();$cat = new Cat();$animal-&gt;makeSound();$dog-&gt;makeSound();$cat-&gt;makeSound();\n\n方法重载$args = func_get_args(); $numArgs = func_num_args();function test()&#123;    $args = func_get_args();     $numArgs = func_num_args();        var_dump($args[1]);    var_dump($numArgs);&#125;test(1,2,3,4);\n\nclass Animal &#123;    public function makeSound() &#123;        echo &quot;动物在吼叫&quot;;    &#125;&#125;class Cat extends Animal &#123;    public function makeSound() &#123;        // $args = func_get_args();        $numArgs = func_num_args();                switch($numArgs)&#123;            case 2:                echo &#x27;执行参数个数为2的事件&#x27;;                break;            case 3:                echo &#x27;执行参数个数为3的事件&#x27;;                break;            default:                echo &#x27;执行默认事件&#x27;;        &#125;    &#125;&#125;// $animal = new Animal();$cat = new Cat();$cat-&gt;makeSound(&quot;测试&quot;,&quot;2&quot;);\n\n接口和抽象类interface(接口)interface Animals &#123;\tpublic function a();\tpublic function b();&#125;class Cat implements Animals &#123;\tpublic function a()&#123;\t\t&#125;;\tpublic function b()&#123;\t\t&#125;;&#125;\n接口是指一组方法的集合，不是类，不能被实例化。\n\n可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容\n只可以使用public\n通常用于定义一些规范，让代码更加有条理 不易出错。例如：小动物必须要吃饭和睡觉，否则就会死！这是必须的，每个小动物都必须有这2个方法！\n\ninterface Animals &#123;    const askk = &quot;askk&quot;;    public function eat();    public function sleep($hours);    public static function jump();&#125;  class Cat implements Animals &#123;    public function eat() &#123;        echo &quot;Cat 在吃饭.&quot;;    &#125;    public function sleep($hours) &#123;        echo &quot;Cat 要睡 $hours 小时.&quot;;    &#125;    public static function jump()&#123;        echo &#x27;跳跳跳&#x27;;    &#125;&#125;$cat = new Cat();$cat-&gt;eat();$cat-&gt;sleep(18);echo Cat::askk;echo Cat::jump();\n\n\ninterface Animals &#123;    public function eat();    public function sleep($hours);&#125;interface Sports &#123;    public function run();    public function jump();&#125;class Cat implements Animals,Sports &#123;    public function eat() &#123;        echo &quot;Cat 在吃饭&quot;;    &#125;    public function sleep($hours) &#123;        echo &quot;Cat 要睡 $hours 小时&quot;;    &#125;    public function run() &#123;        echo &quot;Cat 在跑步&quot;;    &#125;    public function jump() &#123;        echo &quot;Cat 在蹦跳&quot;;    &#125;&#125;\n抽象类和抽象方法和接口非常类似，使用它也是定义一种约束或规范，适合较大型的项目或库使用\n抽象类abstract class Animals&#123;&#125;\n\n抽象类是一种特殊的类，只能被继承，不能被实例化\n抽象类用于定义一组相关的方法，但这些方法的具体实现由继承它的子类来完成。\n子类继承抽象类后，必须实现抽象类中的所有抽象方法。\n抽象类可以包含抽象方法和普通方法\n\n抽象方法abstract public function xxx();abstract protected function xxx();\n\n抽象方法是没有具体实现的方法，只有方法的声明，而不需要方法体。\n抽象方法只能存在于抽象类中。\n可以使用protected，但不能使用private私有。abstract class Animals&#123;    abstract public function eat();    abstract protected function sleep($hours);    public function play()    &#123;      echo &#x27;玩耍&#x27;;    &#125;&#125;class Cat extends Animals&#123;    public function eat()    &#123;        echo &quot;Cat 在吃饭.&quot;;    &#125;    protected function sleep($hours)    &#123;        echo &quot;Cat 要睡 $hours 小时.&quot;;    &#125;&#125;$cat = new Cat();$cat-&gt;eat();//$cat-&gt;sleep(12);$cat-&gt;play();\n\n抽象类与接口的区别\n抽象类可以包含非抽象方法的实现，而接口只能包含方法的声明，没有方法的实现。 \n类只能继承一个抽象类，但可以实现多个接口。 \n抽象类可以有构造函数，而接口不能有构造函数。 \n抽象类中的方法可以有public、protected和private访问修饰符，而接口中的方法只能是public。 \n子类继承抽象类时，必须实现抽象类中的所有抽象方法，否则子类也必须声明为抽象类。子类实现接口时，必须实现接口中的所有方法。\n\ntrait代码复用\n解决类的单一继承问题\n可同时使用多个trait，用逗号隔开\n把常用的、通用的代码抽离出来，写成trait\n\ntrait A&#123;&#125;trait B&#123;&#125;class C &#123;\tuse A,B;&#125;\n\n和类的继承非常像，但是trait里面不能有类常量，且trait不能被实例化。根据下面类的继承来修改，对比看下他们的相同点：\nclass Animal &#123;    protected $name;    const askk=&quot;askk&quot;;    public function __construct($name) &#123;        $this-&gt;name = $name;    &#125;    public function eat() &#123;        echo $this-&gt;name . &quot; 在吃饭.&quot;;    &#125;&#125;class Cat extends Animal &#123;    public function meow() &#123;        echo $this-&gt;name . &quot; 在喵呜.&quot;;    &#125;&#125;$cat = new Cat(&quot;Tom&quot;);var_dump($cat);$cat-&gt;eat();  // 继承自父类 Animal 的方法$cat-&gt;meow();  // 子类 Cat 自己的方法\n\n\ntrait中可使用抽象方法\ntrait中可使用静态属性和静态方法\ntrait中可使用其他trait\ntrait中可使用parent\n\nclass MainClass&#123;    public function main()    &#123;      echo &#x27;这是主方法的&#x27;.__METHOD__;    &#125;&#125;trait Animal &#123;    public function eat() &#123;        parent::main();        echo $this-&gt;name . &quot; 在吃饭.&quot;;        echo __TRAIT__;    &#125;&#125;class Cat extends MainClass &#123;    use Animal;    protected $name;    public function __construct($n) &#123;        $this-&gt;name = $n;    &#125;    public function meow() &#123;        echo $this-&gt;name . &quot; 在喵呜.&quot;;        echo __TRAIT__;    &#125;&#125;$cat = new Cat(&quot;Tom&quot;);var_dump($cat);$cat-&gt;eat();  // 继承自父类 Animal 的方法echo &#x27;----&#x27;;$cat-&gt;meow();  // 子类 Cat 自己的方法\n\n同名冲突当一个类同时引入了多个Trait，并且这些Trait中存在同名方法时，就会产生方法冲突。\nuse A,B&#123;\t//A::eat insteadof B;    B::eat insteadof A;    //别名定义    A::eat as Aeat;&#125;\n\ntrait A&#123;    public function eat()&#123;        echo &#x27;这是A的&#x27;;    &#125;&#125;trait B&#123;    public function eat()&#123;        echo &#x27;这是B的&#x27;;    &#125;&#125;class T&#123;    use A,B&#123;        A::eat insteadof B;        B::eat as Beat;    &#125;&#125;$t = new T;$t-&gt;eat();$t-&gt;Beat();\n\n表单和请求主要用到了$_GET 和 $_POST超全局变量，分别对应两种不同的请求方式\n表单input select radio checkbox submit\n&lt;form action=&quot;./user.php&quot; method=&quot;post&quot;&gt;    用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;    密码: &lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;    &lt;select multiple name=&quot;arr[]&quot;&gt;        &lt;option value=&quot;&quot;&gt;请选择:&lt;/option&gt;        &lt;option value=&quot;1&quot;&gt;大猫&lt;/option&gt;        &lt;option value=&quot;2&quot;&gt;二猫&lt;/option&gt;        &lt;option value=&quot;3&quot;&gt;三猫&lt;/option&gt;    &lt;/select&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;\n关于网络请求GET请求和POST请求是两种常用的HTTP请求方法，用于从客户端向服务器发送数据\nGET请求：通过URL（网址）参数将数据附加在URL上发送给服务器。这些参数以键值对的形式出现在URL的末尾，使用问号”?”将URL和参数分隔开。\nPOST请求：将数据作为请求的主体发送给服务器，而不是附加在URL上。这使得POST请求更适合发送敏感数据或超长大段内容，例如表单中的密码、博客文本内容等。\n区别：\nGET参数对任何人都是可见的，POST参数对任何人都是不可见的\nGET对发送信息的量也有限制，不适合大型的变量值，它的值不能超过 2000 个字符；POST对发送信息的量没有限制（默认POST 发送的最大值为 8 MB，但可通过设置 php.ini 的 post_max_size 进行更改；发送的变量数最大值max_input_vars）\n可以在收藏夹中收藏GET请求页面，或者发送带参数的网址给别人可以直接访问，例如带页码的网址、带商品id的淘宝商品、带文章id的博文。这一点POST做不到。\n\n超全局变量$_REQUEST\n\n\n\n\n\n\n\n\n$_REQUEST 变量包含了 $_GET、$_POST 和 $_COOKIE 的内容$_SERVER获取请求方式\nhtmlspecialchars()函数用于将字符串中的特殊字符转换为HTML实体，以避免在HTML文档中引起解析错误或安全漏洞。\n\n&amp; （和号） 成为 &amp;amp;\n&quot; （双引号） 成为 &amp;quot;\n&#39; （单引号） 成为 &amp;#039;\n&lt; （小于） 成为 &amp;lt;\n&gt; （大于） 成为 &amp;gt;\n\nmysql数据库本课程只讲解最简单的增删改查语句，不做更深入的语句讲解。\n配置环境变量\nmysql -u root -p\n查看数据库列表：SHOW DATABASES;\n使用数据库USE xxx;\n查看数据表列表：SHOW TABLES;\n数据库工具：SQL_Front(小皮内置)、Navicat、DBeaver\n\n\n\n\n\n\n\n\n\n操作数据库的方式：MySQLi 和 PDO\nMySQLi首先要启用扩展mysqli\n面向过程\n&lt;?php$servername = &quot;localhost&quot;;$username = &quot;root&quot;;$password = &quot;root&quot;; // 创建连接$conn = mysqli_connect($servername, $username, $password); // 检测连接if (!$conn) &#123;    die(&quot;连接失败: &quot; . mysqli_connect_error());&#125;echo &quot;连接成功&quot;;//关闭mysqli_close($conn);?&gt;\n面向对象\n&lt;?php$servername = &quot;localhost&quot;;$username = &quot;root&quot;;$password = &quot;root&quot;; // 创建连接$conn = new mysqli($servername, $username, $password); // 检测连接if ($conn-&gt;connect_error) &#123;    die(&quot;连接失败: &quot; . $conn-&gt;connect_error);&#125; echo &quot;连接成功&quot;;//关闭$conn-&gt;close();?&gt;\n\nresource 资源类型\nis_resource() 是否为资源类型\nget_resource_type() 获取资源的类型名称\n\n$servername = &quot;localhost&quot;;$username = &quot;root&quot;;$password = &quot;root&quot;;$conn = mysql_connect($servername, $username, $password);var_dump(is_resource($conn));var_dump(gettype($conn));var_dump(get_resource_type($conn));\n\n$handle = fopen(&quot;test.txt&quot;, &quot;r&quot;);var_dump($handle);var_dump(is_resource($handle));var_dump(gettype($handle));var_dump(get_resource_type($handle));//$content = fread($handle, filesize(&quot;test.txt&quot;));//echo $content; fclose($handle);\n\n\n\n\n\n\n\n\n\n\n接下来将主讲面向对象方式操作\n创建数据库// 创建数据库$sql = &quot;CREATE DATABASE IF NOT EXISTS askkDB&quot;;//if (mysqli_query($conn, $sql)) &#123;if ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;数据库创建成功&quot;;&#125; else &#123;    echo &quot;数据库创建失败 &quot; . $conn-&gt;error;&#125;\n\n创建数据库表\nNOT NULL - 每一行都必须含有值（不能为空），null 值是不允许的。\nDEFAULT value - 设置默认值\nUNSIGNED - 使用无符号数值类型，0 及正数\nAUTO INCREMENT - 设置 MySQL 字段的值在新增记录时每次自动增长 1\nPRIMARY KEY - 设置数据表中每条记录的唯一标识。 通常列的 PRIMARY KEY 设置为 ID 数值，与 AUTO_INCREMENT 一起使用。\n\n每个表都应该有一个主键(本列为 “id” 列)，主键必须包含唯一的值。\n//$conn-&gt;query(&quot;USE askkDB&quot;);// 使用 sql 创建数据表$sql = &quot;CREATE TABLE IF NOT EXISTS user (  id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,   username VARCHAR(30) NOT NULL COMMENT \\&quot;用户名\\&quot;,  password VARCHAR(64) NOT NULL COMMENT &#x27;密码&#x27;,  phone VARCHAR(11),  status INT(1) NOT NULL DEFAULT 1,  create_date TIMESTAMP  ) COMMENT &#x27;用户&#x27;&quot;;//if (mysqli_query($conn, $sql)) &#123;if ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;数据表创建成功&quot;;&#125; else &#123;    echo &quot;数据表创建错误: &quot; . $conn-&gt;error;&#125;\n\n\n\n\n\n\n\n\n\n\n注：如果要加注释，那么后面加上 COMMENT 即可\n插入数据\n\n\n\n\n\n\n\n\n注意： 如果列设置 AUTO_INCREMENT (如 “id” 列) 或 TIMESTAMP (如 “create_date” 列)，我们就不需要在 SQL 语句中指定值； MySQL 会自动为该列添加值。\nINSERT INTO table_name (column1, column2, column3,...)VALUES (value1, value2, value3,...)\n\n用$conn-&gt;query($sql) === TRUE来判断是否插入成功\n$sql = &quot;INSERT INTO user (username, password, phone)VALUES (&#x27;da mao&#x27;, &#x27;123456&#x27;, 13888888888)&quot;;//if (mysqli_query($conn, $sql)) &#123;if ($conn-&gt;query($sql) === TRUE) &#123;    echo &quot;新记录插入成功&quot;;&#125; else &#123;    echo &quot;错误: &quot; . $sql . &quot;&lt;br&gt;&quot; . $conn-&gt;error;&#125;\n\n\n字符串进行转义处理$conn-&gt;real_escape_string($string);可以确保特殊字符被正确转义，从而避免了SQL注入等安全问题，并保证查询语句的语法正确性，例如：\n$name=&quot;这是一个&#x27;送命题&#x27;&quot;;\n\n插入多条数据$sql = &quot;INSERT INTO user (username, password, phone)VALUES     (&#x27;大猫&#x27;, &#x27;123456&#x27;, 13888888888),    (&#x27;小猫&#x27;, &#x27;123456&#x27;, 13888888887),    (&#x27;中猫&#x27;, &#x27;123456&#x27;, 13888888886)    &quot;;$conn-&gt;query($sql);\n\nforeach循环插入，或者使用语句：mysqli_multi_query()\n$sql = &quot;INSERT INTO user (username, password, phone)VALUES (&#x27;大猫&#x27;, &#x27;123456&#x27;, 13888888888);&quot;;$sql .= &quot;INSERT INTO user (username, password, phone)VALUES (&#x27;小猫&#x27;, &#x27;123456&#x27;, 13888888887);&quot;;$sql.= &quot;INSERT INTO user (username, password, phone)VALUES (&#x27;中猫&#x27;, &#x27;123456&#x27;, 13888888886);&quot;;//if (mysqli_multi_query($conn, $sql)) &#123;if ($conn-&gt;multi_query($sql) === TRUE) &#123;    echo &quot;新记录插入成功&quot;;&#125; else &#123;    echo &quot;错误: &quot; . $sql . &quot;&lt;br&gt;&quot; . $conn-&gt;error;&#125;\n\n\n查询数据SELECT column1,column2 FROM table_name\n\n$sql = &quot;SELECT * FROM user&quot;;$result = $conn-&gt;query($sql);//if (mysqli_num_rows($result) &gt; 0) &#123;if ($result-&gt;num_rows &gt; 0) &#123;    echo &quot;$result-&gt;num_rows 条结果&quot;;    // 输出数据    //while($row = mysqli_fetch_assoc($result)) &#123;    while($row = $result-&gt;fetch_assoc()) &#123;        echo &quot;id: &quot; . $row[&quot;id&quot;]. &quot; - Name: &quot; . $row[&quot;username&quot;]. &quot; &quot; . $row[&quot;phone&quot;]. &quot;&lt;br&gt;&quot;;    &#125;&#125; else &#123;    echo &quot;0 条结果&quot;;&#125;\n\n\n$result-&gt;num_rows 获取到的数据条数\n$result-&gt;fetch_assoc() 是一种用于从结果集中获取一行数据的函数。它以关联数组的形式返回结果，其中列名作为键，对应的值则是该行中各列的值\n除了fetch_assoc 还有 fetch_row和fetch_array和fetch_all\n\nwhile($row = $result-&gt;fetch_row()) &#123;    echo &quot;id: &quot; . $row[0]. &quot; - Name: &quot; . $row[1]. &quot; &quot; . $row[2]. &quot;&lt;br&gt;&quot;;&#125;\n\n//$datas = mysqli_fetch_all($result, MYSQLI_ASSOC);$datas = $result-&gt;fetch_all(MYSQLI_ASSOC);var_dump($datas);\n\nfree_result()\n释放结果集所占用的内存资源。在使用 query() 函数执行查询后，会返回一个结果集对象，该结果集对象占用一定的内存空间。\n//mysqli_free_result($result);$result-&gt;free_result();\nwhere 条件筛选WHERE用于在查询中指定筛选条件，来限制返回的行\nSELECT 列名FROM 表名WHERE 条件;\n\n条件判断：&gt; &lt; = != &lt;&gt; &gt;= &lt;=like &quot;%xxx%&quot; like &quot;%xxx&quot; like &quot;xxx%&quot;between and is null is not nullin (a,b,c)\nand or not 括号\norder by 排序ASC升序 、DESC降序根据两列进行排序，用逗号隔开即可，注意：只有第一列的值相同时才使用第二列\noffset limitSELECT 列名FROM 表名LIMIT 行数 OFFSET 偏移量;\n\n更新数据UPDATE 表名SET column1=value, column2=value2,...WHERE 条件\n注意：如果省去 WHERE 子句，所有的记录都会被更新\n使用计算表达式更新字段\nUPDATE 表名 SET 列名 = 列名 + 值 WHERE 条件;\n$sql = &quot;UPDATE user SET num = num*3 WHERE id = 2&quot;;$result = $conn-&gt;query($sql);\n删除数据DELETE FROM 表名WHERE 条件\n\n注意：如果省去 WHERE 子句，所有的记录都会被删除\n删除表中的重复行\nDELETE t1 FROM 表名 t1, 表名 t2 WHERE t1.列名 = t2.列名 AND t1.id &gt; t2.id;\n\n修改数据表修改数据表名：ALTER TABLE 旧表名 RENAME 新表名;重置自增起始值为1：ALTER TABLE 表名 AUTO_INCREMENT = 1;添加新的列：ALTER TABLE 表名 ADD COLUMN 列名 数据类型;修改列名和数据类型：ALTER TABLE 表名 CHANGE COLUMN 旧列名 新列名 新数据类型;修改列的默认值： ALTER TABLE 表名 ALTER COLUMN 列名 SET DEFAULT 默认值;删除列：ALTER TABLE 表名 DROP COLUMN 列名;修改列的注释：ALTER TABLE 表名 MODIFY COLUMN 列名 数据类型 COMMENT &#x27;新注释&#x27;;删除数据表：DROP TABLE IF EXISTS 表名清空数据表：TRUNCATE TABLE 表名;删除数据库：DROP database\n\n咱们只讲了最基本的mysql，关于关联查询 索引 等更深入的知识就需要专门学习了。\n预处理语句预处理语句（Prepared Statements），用于执行带有参数的SQL语句。\n\n预处理语句可以提高安全性，对于防止 SQL 注入是非常有用的\n允许重复使用相同的sql模板而只需更改参数，提高执行效率。\n\n关于sql注入当涉及到SQL查询时，注入攻击是一种常见的安全漏洞\n1. 直接执行用户输入的SQL查询：$query = $_GET[&#x27;query&#x27;];$result = $conn-&gt;query($query);\n如果用户能够直接执行他们自己构造的SQL查询，就会产生严重的安全问题。恶意用户可以执行任意的SQL语句，包括删除、修改或泄露敏感数据。\n2. 使用字符串拼接的方式构建SQL查询：$username = $_POST[&#x27;username&#x27;];$password = $_POST[&#x27;password&#x27;];$sql = &quot;SELECT * FROM user WHERE username = &#x27;&quot; . $username . &quot;&#x27; AND password = &#x27;&quot; . $password . &quot;&#x27;&quot;;$result = $conn-&gt;query($sql);\n\n这种方式存在安全风险，如果用户在输入框中输入恶意代码，可以破坏原始的SQL查询结构，例如输入 &#39; OR 1=1 -- ，会导致查询条件永远为真，从而绕过身份验证。\n\n转义特殊字符也不保险：$username = $conn-&gt;real_escape_string($_POST[&#x27;username&#x27;]);$password = $conn-&gt;real_escape_string($_POST[&#x27;password&#x27;]);$query = &quot;SELECT * FROM users WHERE username = &#x27;&quot; . $username . &quot;&#x27; AND password = &#x27;&quot; . $password . &quot;&#x27;&quot;;$result = $conn-&gt;query($query);\n我们使用 -&gt;real_escape_string() 函数对用户输入的用户名和密码进行转义，以防止SQL注入，但仍然可能存在注入漏洞。假设用户在用户名输入框中输入 admin&#39;-- ，并在密码输入框中输入任意值。由于转义字符未正确处理，生成的SQL查询语句如下SELECT * FROM users WHERE username = &#x27;admin&#x27;--&#x27; AND password = &#x27;password&#x27;\n在这种情况下， -- 是SQL注释的开始，后面的 AND password = &#39;password&#39; 将被忽略。这样，攻击者可以绕过密码验证并成功登录，即使没有提供正确的密码。\n\n预处理方法查询\n$sql = &quot;SELECT * FROM user WHERE username = ? AND password = ? &quot;;$stmt = $conn-&gt;prepare($sql);//绑定$stmt-&gt;bind_param(&quot;ss&quot;, $username, $password);//执行$stmt-&gt;execute();//获取结果$result = $stmt-&gt;get_result();print_r(&#x27;&lt;pre&gt;&#x27;);print_r($result-&gt;fetch_all());//关闭$stmt-&gt;close();\n\n插入\n// 预处理$sql = &quot;INSERT INTO user (username, password, phone)VALUES (?, ?, ?)&quot;;$stmt = $conn-&gt;prepare($sql);//绑定$stmt-&gt;bind_param(&quot;sss&quot;, $username, $password, $phone);//执行$stmt-&gt;execute();//获取结果if ($stmt-&gt;affected_rows &gt; 0) &#123;    echo &quot;插入成功&quot;;&#125; else &#123;    echo &quot;插入失败&quot;;&#125;//关闭$stmt-&gt;close();\n\n\n其中的?为占位符\n通过告诉数据库参数的数据类型，可以降低 SQL 注入的风险。参数有以下四种类型:\n\ni - integer（整型）\nd - double（双精度浮点型）\ns - string（字符串）\nb - BLOB（binary large object:二进制大对象）\n\n每个参数都需要指定类型。\nphp8新方法\n$name=&quot;这是一个&#x27;送命题&#x27;&quot;;//mysqli_execute_query$sql = &quot;INSERT INTO user (username, password, phone)VALUES (?, ?, ?)&quot;;$conn-&gt;execute_query($sql,[$name,&#x27;123456&#x27;,&#x27;13888888888&#x27;]);$conn-&gt;execute_query($sql,[$name,&#x27;123456&#x27;,&#x27;13888888888&#x27;]);\n\n\nPDO安装php_pdo_mysql扩展，用phpinfo() 函数来查看是否安装了PDO扩展\nPDO执行sql语句分为2种方法：\nexec() 方法： \n\n适用于执行不返回结果集的SQL语句，例如INSERT、UPDATE和DELETE等操作。 \nexec() 方法返回受影响的行数（即被插入、更新或删除的行数），如果没有受影响的行，返回0。 \n通常用于执行不需要获取结果集的简单操作。\n\nquery() 方法： \n\n适用于执行返回结果集的SQL语句，例如SELECT查询。 \nquery() 方法返回一个PDOStatement对象，你可以使用该对象的方法（如 fetch() 、 fetchAll() ）来获取查询结果。 \n通常用于执行需要获取结果集的查询操作。\n\n创建连接&lt;?php$dbms=&#x27;mysql&#x27;;     //数据库类型$host=&#x27;localhost&#x27;; //数据库主机名$dbName=&#x27;askkdb&#x27;;    //使用的数据库$user=&#x27;root&#x27;;      //数据库连接用户名$pass=&#x27;root&#x27;;          //对应的密码$dsn=&quot;$dbms:host=$host;dbname=$dbName&quot;;try &#123;    $conn = new PDO($dsn, $user, $pass); //初始化一个PDO对象    echo &quot;连接成功&lt;br/&gt;&quot;;\t// 关闭连接    $conn = null;&#125; catch (PDOException $e) &#123;    die (&quot;错误!: &quot; . $e-&gt;getMessage() . &quot;&lt;br/&gt;&quot;);&#125;?&gt;\n创建数据库//设置 PDO 错误模式为异常$conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);//PDO::ERRMODE_WARNING 警告//PDO::ERRMODE_SILENT 错误码//$conn-&gt;errorCode()//$conn-&gt;errorInfo()   // 创建数据库   $sql = &quot;CREATE DATABASE 数据库名&quot;;   $conn-&gt;exec($sql);   echo &quot;数据库创建成功&quot;;\n\n创建数据表$sql = &quot;CREATE TABLE IF NOT EXISTS user6 (    id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,     username VARCHAR(30) NOT NULL COMMENT \\&quot;用户名\\&quot;,    password VARCHAR(64) NOT NULL COMMENT &#x27;密码&#x27;,    phone VARCHAR(11),    status INT(1) NOT NULL DEFAULT 1,    create_date TIMESTAMP    ) COMMENT &#x27;用户&#x27;&quot;;$conn-&gt;exec($sql);\n\n查询数据// 执行查询语句   $sql = &quot;SELECT * FROM user WHERE id&lt;5&quot;;   $result = $conn-&gt;query($sql);   // 获取结果   $result = $result-&gt;fetchAll(PDO::FETCH_ASSOC);   var_dump($result);\n更新数据$sql = &quot;UPDATE user SET num = num+3 WHERE id =2&quot;;   $stmt = $conn-&gt;exec($sql);   var_dump($stmt);\n删除数据$sql = &quot;DELETE FROM user WHERE id =26&quot;;   $stmt = $conn-&gt;exec($sql);\n\n插入数据和mysqli的类似，不做特殊说明了预处理\n   // 执行插入语句   $sql = &quot;INSERT INTO 表名 (列1, 列2, 列3) VALUES (:value1, :value2, :value3)&quot;;   $stmt = $conn-&gt;prepare($sql);   // 绑定参数   $stmt-&gt;bindParam(&#x27;:value1&#x27;, $value1);   $stmt-&gt;bindParam(&#x27;:value2&#x27;, $value2);   $stmt-&gt;bindParam(&#x27;:value3&#x27;, $value3);   // 设置参数值   $value1 = &quot;值1&quot;;   $value2 = &quot;值2&quot;;   $value3 = &quot;值3&quot;;   // 执行插入语句   $stmt-&gt;execute();   // 获取插入的条数    $rowCount = $stmt-&gt;rowCount();\n\n批量插入\n$sql = &quot;INSERT INTO user (username, password, phone) VALUES (?,?,?)&quot;;$stmt = $conn-&gt;prepare($sql);// 执行插入语句$stmt-&gt;execute([&quot;test1&quot;,&quot;1234&quot;,&quot;13888888888&quot;]);$stmt-&gt;execute([&quot;test2&quot;,&quot;1232&quot;,&quot;13888888888&quot;]);\n\n事务事务（Transaction）是一组数据库操作的集合，这些操作要么全部成功执行，要么全部回滚（撤销）。事务提供了一种机制来确保数据库操作的一致性和完整性。\ntry &#123;    // 开始事务    $conn-&gt;beginTransaction();    // 执行批量插入语句    $sql = &quot;INSERT INTO user (username, password, phone) VALUES (?,?,?)&quot;;    $stmt = $conn-&gt;prepare($sql);    $data = array(        array(&quot;值1&quot;, &quot;值2&quot;, &quot;值3&quot;),        array(&quot;值4&quot;, &quot;值5&quot;, &quot;值6&quot;),        array(&quot;值7&quot;, &quot;值8&quot;, &quot;值9&quot;)    );        $insertedRows = 0;    foreach ($data as $row) &#123;        $stmt-&gt;execute($row);        $insertedRows += $stmt-&gt;rowCount();    &#125;    // 提交事务    $conn-&gt;commit();    echo &quot;批量插入成功&quot;;&#125; catch(PDOException $e) &#123;    // 回滚事务    $conn-&gt;rollback();    echo &quot;插入失败: &quot; . $e-&gt;getMessage();&#125;\n\n作业：把PDO里没有用预处理的改为预处理方式。如果有时间，可以把上面的增删改查封装为一个DB类，方便调用。后面我们实战的时候也会讲PDO类的二次封装和调用。\ncookie sessioncookiecookie 常用于识别用户。cookie 是一种服务器留在用户计算机上的小文件。每当同一台计算机通过浏览器请求页面时，这台计算机将会发送 cookie。通过 PHP，能够创建并取回 cookie 的值。\n创建cookiesetcookie(name, value, expire, path, domain);\n\n参数说明： \n\nname ：Cookie的名称。 \nvalue ：Cookie的值。 \nexpire ：Cookie的过期时间，可以是一个Unix时间戳（例如： time() + 3600  表示一小时后过期），或者是一个具体的日期时间字符串（例如： “2024-01-01 00:00:00” ）。 \npath ：可选参数，指定Cookie的有效路径。默认为当前路径。 \ndomain ：可选参数，指定Cookie的有效域名。默认为空，表示当前域名。 \nsecure ：可选参数，指定是否仅通过安全的HTTPS连接传输Cookie。默认为 false 。 \nhttponly：可选参数，指定是否仅通过HTTP协议访问Cookie。默认为 false 。 \n$expire=time()+60*60*24*7;setcookie(&quot;username&quot;, &quot;askk&quot;, $expire);setcookie(&quot;userid&quot;, &quot;1&quot;, $expire);setcookie(&quot;user[name]&quot;, &quot;askk&quot;, $expire);setcookie(&quot;user[phone]&quot;, &quot;18611112222&quot;, $expire);setcookie(&quot;user[age]&quot;, &quot;35&quot;, $expire);\n\n获取cookie// 输出 cookie 值if(isset($_COOKIE[&quot;username&quot;]))&#123;\techo $_COOKIE[&quot;username&quot;];&#125;\t// 查看所有 cookieprint_r($_COOKIE);\n\n删除 Cookiesetcookie(&quot;username&quot;, &quot;&quot;, time()-3600);\nsession\n用于在服务器上存储关于用户会话（session）的信息，并且对于程序中的所有页面都是可用的。\n会话信息是临时的，在用户离开网站后将被删除。\n它允许在同一个用户的多个请求之间保持数据的状态，便于传递数据。Session 的工作机制是：为每个访客创建一个唯一的 id (UID)，并基于这个 UID 来存储变量。UID 存储在 cookie 中，或者通过 URL 进行传导。\n\n启动session通常，将该函数放在PHP文件的顶部\nsession_start();\n\n存取 Session 变量一旦Session启动，可以使用 $_SESSION 超全局变量来存储和访问Session数据。\n// 存储 session 数据 $_SESSION[&#x27;username&#x27;]=&#x27;askk&#x27;;//取值echo $_SESSION[&#x27;username&#x27;];\n\nif(isset($_SESSION[&#x27;views&#x27;]))&#123;    $_SESSION[&#x27;views&#x27;]=$_SESSION[&#x27;views&#x27;]+1;&#125;else&#123;    $_SESSION[&#x27;views&#x27;]=1;&#125;echo &quot;浏览量：&quot;. $_SESSION[&#x27;views&#x27;];\n\n销毁 Sessionif(isset($_SESSION[&#x27;views&#x27;]))&#123;    unset($_SESSION[&#x27;views&#x27;]);&#125;//销毁session_destroy();\n\n\n\n\n\n\n\n\n\n\n注意：session_destroy() 将重置 session，您将失去所有已存储的 session 数据\nSession和Cookie的关系和区别关系： \n\nSession和Cookie都是用于在不同请求之间保持数据的状态。 \nSession使用Cookie来跟踪和标识用户，通过在Cookie中存储Session ID来关联服务器端的Session数据。\n\n区别： \n\n存储位置：Cookie数据存储在客户端的浏览器中，而Session数据存储在服务器端。 \n容量限制：Cookie的容量限制通常较小，一般为几KB，而Session的容量限制较大，通常取决于服务器的配置。 \n安全性：由于Cookie存储在客户端，可能会被篡改或窃取，因此存储敏感信息的安全性较低。相比之下，Session数据存储在服务器端，相对更安全。 \n生命周期：Cookie可以设置过期时间，可以在浏览器关闭后仍然保持，具有较长的生命周期。而Session通常在用户关闭浏览器或一段时间不活动后自动过期。 \n存储方式：Cookie以键值对的形式存储数据，可以在客户端进行读取和修改。Session数据存储在服务器端，客户端只保存了一个Session ID。\n\n在实际应用中，Cookie通常用于存储一些较小、不敏感的数据，如用户首选项、购物车信息等。而Session通常用于存储用户的身份验证信息、敏感数据等，因为Session数据存储在服务器端，相对更安全。 \n实战案例：个人中心案例介绍：我们会用最基础的原生 php 方式去做这个项目，不用任何前后端框架，考虑到一些学员没有前端基础，所以我会尽量少的使用 js，但会用到 fetch 请求等基础语句，并且 html 和 css 会有入门级的讲解（简单）；我会尽可能多的使用学到的知识，以达到学以致用的效果；我们会使用面向对象去对一些常用的方法进行封装，例如数据库操作，让大家学会在实际项目中使用类和对象。\n讲解的内容：\n\n什么是前端，什么是后端；什么是前台，什么是后台\n页面搭建 (从 0 到 1)\n什么是 json\n简单的 Api 接口和请求\nPhp 调试代码\n封装类\n文件包含\n数据库的使用\n用户状态\n\n![[Pasted image 20231116090904.png]]\n用户注册用户登录用户中心个人信息登录记录修改密码退出登录实战补充知识str_repeat() 和 rtrim () ltrim() 函数floor() 和 ceil() round() 函数md5() 加密die 和 exit 函数常量 DIRECTORY_SEPARATORPdo 补充知识$stmt-&gt;closeCursor()If($condition instanceof Closure)\ndirname ()dirname 函数用于返回指定路径的目录部分。它接受一个字符串参数，该参数是一个文件或目录的路径，并返回该路径的父级目录。\n$path = &#x27;/var/www/html/index.php&#x27;;$directory = dirname($path);echo $directory;  // 输出: /var/www/html$path = &#x27;/var/www/html/&#x27;;$directory = dirname($path);echo $directory;  // 输出: /var/www$path = &#x27;/var/www/html&#x27;;$directory = dirname($path);echo $directory;  // 输出: /var/www\n\nheader ()函数header() 函数用于发送原始的 HTTP 头信息。它通常用于在服务器响应中设置 HTTP 头，例如设置重定向、设置响应状态码、设置内容类型等。\nheader(string $header, bool $replace = true, int $http_response_code = null): void\n参数说明： \n\n$header ：要设置的 HTTP 头信息，以字符串形式表示。 \n$replace （可选）：指定是否替换之前设置的相同类型的 HTTP 头信息。默认为  true ，表示替换。 \n$http_response_code（可选）：指定要设置的响应状态码。\n\n//重定向header(&quot;Location: ./login.php&quot;);//设置响应状态码：header(&quot;HTTP/1.1 404 Not Found&quot;);//设置内容类型header(&quot;Content-Type: application/json&quot;);\n注意： header() 函数必须在发送任何实际输出之前调用，包括 HTML 标记、空格、换行符等。如果在输出之后调用 header() 函数，将会导致 “headers already sent” 错误。\n静态变量的使用与类或函数相关联，而不是与对象或函数的实例相关联。静态变量在整个脚本的执行过程中保持其值不变。\n类class MyClass &#123;    public static $count = 0;    public static function toObj()    &#123;      return new self;    &#125;    public function plusCount() &#123;        self::$count++;        echo self::$count.PHP_EOL;    &#125;&#125;MyClass::toObj()-&gt;plusCount();MyClass::toObj()-&gt;plusCount();MyClass::toObj()-&gt;plusCount();echo MyClass::$count;\n普通函数\n\n\n\n\n\n\n\n\n静态变量只在函数的作用域内有效，不同函数中的同名静态变量是相互独立的\nfunction myFunction() &#123;    static $count = 0;        $count++;    echo $count.PHP_EOL;&#125;function mySecond() &#123;    static $count = 0;    echo $count.PHP_EOL;&#125;myFunction();myFunction();myFunction();mySecond();\n关于phpinfo()","slug":"php","date":"2024-07-30T03:50:33.000Z","categories_index":"编程语言","tags_index":"PHP","author_index":"暗使开开"},{"id":"8b6d795d3d1df2df98884f634fbf74f5","title":"鬼谷子","content":"鬼谷子鬼谷子 捭阖　　粤若稽古，圣人之在天地间也，为众生之先。观阴阳之开阖以命物，知存亡之门户，筹策万类之终始，达人心之理，见变化之眹焉，而守司其门户。故圣人之在天下也，自古及今，其道一也。变化无穷，各有所归。或阴或阳，或柔或刚，或开或闭，或弛或张。是故圣人一守司其门户，审察其所先后，度权量能，校其伎巧短长。\n　　夫贤不肖、智愚、勇怯、仁义有差，乃可捭，乃可阖；乃可进，乃可退；乃可贱，乃可贵，无为以牧之。审定有无与其实虚，随其嗜欲以见其志意，微排其所言而捭反之，以求其实，贵得其指；阖而捭之，以求其利。或开而示之，或阖而闭之。开而示之者，同其情也；阖而闭之者，异其诚也。可与不可，审明其计谋，以原其同异。离合有守，先从其志。即欲捭之贵周，即欲阖之贵密。周密之贵微，而与道相追。捭之者，料其情也；阖之者，结其诚也。皆见其权衡轻重，乃为之度数，圣人因而为之虑。其不中权衡度数，圣人因而自为之虑。故捭者，或捭而出之，或捭而内之；阖者，或阖而取之，或阖而去之。\n　　捭阖者，天地之道。捭阖者，以变动阴阳，四时开闭，以化万物。纵横、反出、反覆、反忤，必由此矣。捭阖者，道之大化。说之变也，必豫审其变化，吉凶大命系焉。口者，心之门户也；心者，神之主也。志意、喜欲、思虑、智谋，此皆由门户出入，故关之以捭阖，制之以出入。捭之者，开也，言也，阳也；阖之者，闭也，默也，阴也。阴阳其和，终始其义。故言长生、安乐、富贵、尊荣、显名、爱好、财利、得意、喜欲为阳，曰始。故言死亡、忧患、贫贱、苦辱、弃损、亡利、失意、有害、刑戮、诛罚为阴，曰终。诸言法阳之类者，皆曰始，言善以始其事；诸言法阴之类者，皆曰终，言恶以终其谋。捭阖之道，以阴阳试之。故与阳言者依崇高，与阴言者依卑小。以下求小，以高求大。由此言之，无所不出，无所不入，无所不可。可以说人，可以说家，可以说国，可以说天下。为小无内，为大无外。\n　　益损、去就、倍反，皆以阴阳御其事。阳动而行，阴止而藏；阳动而出，阴隐而入，阳还终阴，阴极反阳。以阳动者，德相生也；以阴静者，形相成也。以阳求阴，苞以德也；以阴结阳，施以力也；阴阳相求，由捭阖也。此天地阴阳之道，而说人之法也，为万事之先，是谓圆方之门户。\n鬼谷子 反应　　古之大化者，乃与无形俱生。反以观往，覆以验来；反以知古，覆以知今；反以知彼，覆以知此。动静虚实之理，不合来今，反古而求之。事有反而得覆者，圣人之意也，不可不察。 \n　　人言者，动也；己默者，静也。因其言，听其辞。言有不合者，反而求之，其应必出。言有象，事有比。其有象比，以观其次。象者象其事，比者比其辞也。以无形求有声，其钓语合事，得人实也。若张置网而取兽也，多张其会而司之。道合其事，彼自出之，此钓人之网也。常持其网驱之，其言无比，乃为之变，以象动之，以报其心，见其情，随而牧之。己反往，彼覆来，言有象比，因而定基。重之袭之，反之覆之，万事不失其辞，圣人所诱愚智，事皆不疑。 \n　　古善反听者，乃变鬼神以得其情。其变当也，而牧之审也。牧之不审，得情不明；得情不明，定基不审。变象比，必有反辞，以还听之。欲闻其声反默，欲张反敛，欲高反下，欲取反与。欲开情者，象而比之，以牧其辞，同声相呼，实理同归。或因此，或因彼，或以事上，或以牧下，此听真伪、知同异，得其情诈也。动作言默，与此出入，喜怒由此以见其式，皆以先定为之法则。以反求复，观其所托。故用此者，己欲平静，以听其辞，察其事，论万物，别雄雌。虽非其事，见微知类。若探人而居其内，量其能，射其意。符应不失，如腾蛇之所指，若羿之引矢。 \n　　故知之始己，自知而后知人也。其相知也，若比目之鱼。其伺言也，若声之与响；见其形也，若光之与影；其察言也不失，若磁石之取铁，如舌之取燔骨。其与人也微，其见情也疾。如阴与阳，如阳与阴；如圆与方，如方与圆。未见形，圆以道之；既见形，方以事之。进退左右，以是司之。己不先定，牧人不正。事用不巧，是谓忘情失道。己审先定以牧人，策而无形容，莫见其门，是谓天神。\n鬼谷子 内楗　　君臣上下之事，有远而亲，近而疏；就之不用，去之反求；日进前而 不御，遥闻声而相思。事皆有内楗，素结本始。或结以道德，或结以党友，或结以财货，或结以采色。用其意，欲入则入，欲出则出；欲亲则亲，欲疏则疏；欲 就则就；欲去则去；欲求则求，欲思则思。若蚨母之从子也；出无间 ，入无朕。独往独来，莫之能止。\n　　内者，进说辞也。楗者，楗所谋也。欲说者务隐度，计事者务循顺。 阴虑可否，明言得失，以御其志。方来应时，以和其谋。详思来楗， 往应时当也。夫内有不合者，不可施行也。乃揣切时宜，从便所为， 以求其变。以变求内者，若管取楗。言往者，先顺辞也；说来者，以 变言也。善变者审知地势，乃通于天，以化四时，使鬼神，合于阴阳 ，而牧人民。见其谋事，知其志意。事有不合者，有所未知也。合而不结者，阳亲 而阴疏。事有不合者，圣人不为谋也。故远而亲者，有阴德也。近而疏者，志不合也。就而不用者，策不得 也。去而反求者，事中来也。日进前而不御者，施不合也。遥闻声而 相思者，合于谋待决事也。故曰：不见其类而为之者，见逆。不得其情而说之者，见非。必得其情，乃制其术，此用可出可入，可楗可开。\n​\t\t故圣人立事，以此先知而楗万 物。由夫道德、仁义、礼乐、忠信、计谋。先取《诗》、《书》，混说损益，议论去就。欲 合者用内，欲去者用外。外内者，必明道数。揣策来事，见疑决之。 策无失计，立功建德，治名入产业，曰楗而内合。上暗不治，下乱不窹，楗而反之。内自得而外不留，说而飞之，若命自来，己迎而御之 。若欲去之，因危与之。环转因化，莫知所为，退为大仪。\n鬼谷子 抵巇​\t\t物有自然，事有合离。有近而不可见，有远而可知。近而不可见者， 不察其辞也；远而可知者，反往以验来也。\n巇者，罅也。罅者，涧也。涧者，成大隙也。巇始有朕，可抵而塞， 可抵而却，可抵而息，可抵而匿，可抵而得，此谓抵巇之理也。事之危也，圣人知之，独保其用；因化说事，通达计谋，以识细微。经起秋毫之末，挥之于太山之本。\n其施外，兆萌牙蘖之谋，皆由抵巇。抵巇之隙，为道术用。天下纷错，上无明主，公侯无道德，则小人谗贼，贤人不用，圣人窜匿，贪利诈伪者作，君臣相惑，土崩瓦解而相伐射，父子离散，乖乱反目，是谓萌牙巇罅。圣人见萌牙巇罅，则抵之以法。世可以治，则抵而塞之；不可治，则抵而得之；或抵如此，或抵如彼；或抵反之， 或抵覆之。五帝之政，抵而塞之；三王之事，抵而得之。诸侯相抵， 不可胜数，当此之时，能抵为右。\n自天地之合离终始，必有巇隙，不可不察也。察之以捭阖，能用此道 ，圣人也。圣人者，天地之使也。世无可抵，则深隐而待时；时有可抵，则为之谋；可以上合，可以检下。能因能循，为天地守神。\n","slug":"鬼谷子","date":"2024-07-29T16:00:00.000Z","categories_index":"修身养性","tags_index":"修身养性","author_index":"暗使开开"},{"id":"2d728caa47af746573cb7fba96b85d4f","title":"C++","content":"C++中map与unordered_map的区别头文件\nmap: #include &lt;map&gt;\nunordered_map: #include &lt;unordered_map&gt;\n\n内部实现机理\nmap： map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。\nunordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的\n\nunordered_map和map类似，都是存储的key-value的值，可以通过key快速索引到value。不同的是unordered_map不会根据key的大小进行排序，存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。\n所以使用时map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator==。但是很多系统内置的数据类型都自带这些，那么如果是自定义类型，那么就需要自己重载operator&lt;或者hash_value()了。\n优缺点以及适用处\n\n\n\nmap\nunordered_map\n\n\n\n优点\n有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作红黑树，内部实现一个红黑书使得map的很多操作在lgnlgn的时间复杂度下就可以实现，因此效率非常的高\n因为内部实现了哈希表，因此其查找速度非常的快\n\n\n缺点\n空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红&#x2F;黑性质，使得每一个节点都占用大量的空间\n哈希表的建立比较耗费时间\n\n\n适用处\n对于那些有顺序要求的问题，用map会更高效一些\n对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map\n\n\n结论如果需要内部元素自动排序，使用map，不需要排序使用unordered_map\nnote:对于unordered_map或者unordered_set容器，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照哈希表从前往后依次遍历的\n参考\nc++中map与unordered_map的区别\nC++11 新特性： unordered_map 与 map 的对比\n\nC++ 11之Lambda表达式C++11的一大亮点就是引入了Lambda表达式。利用Lambda表达式，可以方便的定义和创建匿名函数,用以替换独立函数或者函数对象，并且使代码更可读。但是从本质上来讲，lambda表达式只是一种语法糖，因为所有其能完成的工作都可以用其它稍微复杂的代码来实现。但是它简便的语法却给C++带来了深远的影响。如果从广义上说，lamdba表达式产生的是函数对象。在类中，可以重载函数调用运算符()，此时类的对象可以将具有类似函数的行为，我们称这些对象为函数对象（Function Object）或者仿函数（Functor）。对于C++这门语言来说来说，“Lambda表达式”或“匿名函数”这些概念听起来好像很深奥，但很多高级语言在很早以前就已经提供了Lambda表达式的功能，如C#，Python等。今天，我们就来简单介绍一下C++中Lambda表达式的简单使用。\n声明Lambda表达式Lambda表达式完整的声明格式如下：\n[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125; \n\n各项具体含义如下\n\ncapture list：捕获外部变量列表\nparams list：形参列表\nmutable指示符：用来说用是否可以修改捕获的变量\nexception：异常设定\nreturn type：返回类型\nfunction body：函数体\n\n此外，我们还可以省略其中的某些成分来声明“不完整”的Lambda表达式，常见的有以下几种：\n\n\n\n序号\n格式\n\n\n\n1\n[capture list] (params list) -&gt; return type {function body}\n\n\n2\n[capture list] (params list) {function body}\n\n\n3\n[capture list] {function body}\n\n\n其中：\n\n格式1声明了const类型的表达式，这种类型的表达式不能修改捕获列表中的值。\n格式2省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型： （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定； （2）：如果function body中没有return语句，则返回值为void类型。\n格式3中省略了参数列表，类似普通函数中的无参函数。\n\nLambda表达式的一个实例\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(int a, int b)&#123;    return  a &lt; b;&#125;int main()&#123;    vector&lt;int&gt; myvec&#123; 3, 2, 5, 7, 3, 2 &#125;;    vector&lt;int&gt; lbvec(myvec);    sort(myvec.begin(), myvec.end(), cmp); // 旧式做法    cout &lt;&lt; &quot;predicate function:&quot; &lt;&lt; endl;    for (int it : myvec)        cout &lt;&lt; it &lt;&lt; &#x27; &#x27;;    cout &lt;&lt; endl;    sort(lbvec.begin(), lbvec.end(), [](int a, int b) -&gt; bool &#123; return a &lt; b; &#125;);   // Lambda表达式    cout &lt;&lt; &quot;lambda expression:&quot; &lt;&lt; endl;    for (int it : lbvec)        cout &lt;&lt; it &lt;&lt; &#x27; &#x27;;&#125;\n\n在C++11之前，我们使用STL的sort函数，需要提供一个谓词函数。如果使用C++11的Lambda表达式，我们只需要传入一个匿名函数即可，方便简洁，而且代码的可读性也比旧式的做法好多了。\n下面，我们就重点介绍一下Lambda表达式各项的具体用法。\n捕获外部变量Lambda表达式可以使用其可见范围内的外部变量，但必须明确声明（明确声明哪些外部变量可以被该Lambda表达式使用）。那么，在哪里指定这些外部变量呢？Lambda表达式通过在最前面的方括号[]来明确指明其内部可以访问的外部变量，这一过程也称过Lambda表达式“捕获”了外部变量。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    int a = 123;    auto f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;     f(); // 输出：123    //或通过“函数体”后面的‘()’传入参数    auto x = [](int a)&#123;cout &lt;&lt; a &lt;&lt; endl;&#125;(123); &#125;  \n\n上面这个例子先声明了一个整型变量a，然后再创建Lambda表达式，该表达式“捕获”了a变量，这样在Lambda表达式函数体中就可以获得该变量的值。\n类似参数传递方式（值传递、引入传递、指针传递），在Lambda表达式中，外部变量的捕获方式也有值捕获、引用捕获、隐式捕获。\n1、值捕获值捕获和参数传递中的值传递类似，被捕获的变量的值在Lambda表达式创建时通过值拷贝的方式传入，因此随后对该变量的修改不会影响影响Lambda表达式中的值。\n示例如下：\nint main()&#123;    int a = 123;    auto f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;     a = 321;    f(); // 输出：123&#125;  1 2 3 4 5 6 7 int main() &#123;    int a = 123;    auto f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;     a = 321;    f(); // 输出：123 &#125;   \n\n*这里需要注意的是，如果以传值方式捕获外部变量，则在Lambda表达式函数体中不能修改该外部变量的值。*\n2、引用捕获使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符 &amp;。如下：\nint main()&#123;    int a = 123;    auto f = [&amp;a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;     a = 321;    f(); // 输出：321&#125;   \n\n从示例中可以看出，引用捕获的变量使用的实际上就是该引用所绑定的对象。\n3、隐式捕获上面的值捕获和引用捕获都需要我们在捕获列表中显示列出Lambda表达式中使用的外部变量。除此之外，我们还可以让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获。隐式捕获有两种方式，分别是[=]和[&amp;]。[=]表示以值捕获的方式捕获外部变量，[&amp;]表示以引用捕获的方式捕获外部变量。\n隐式值捕获示例：\nint main()&#123;    int a = 123;    auto f = [=] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    // 值捕获    f(); // 输出：123&#125;  \n\n隐式引用捕获示例：\nint main()&#123;    int a = 123;    auto f = [&amp;] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    // 引用捕获    a = 321;    f(); // 输出：321&#125;  \n\n4、混合方式上面的例子，要么是值捕获，要么是引用捕获，Lambda表达式还支持混合的方式捕获外部变量，这种方式主要是以上几种捕获方式的组合使用。\n到这里，我们来总结一下：C++11中的Lambda表达式捕获外部变量主要有以下形式：\n\n\n\n捕获形式\n说明\n\n\n\n[]\n不捕获任何外部变量\n\n\n[变量名, …]\n默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp; 说明符）\n\n\n[this]\n以值的形式捕获this指针\n\n\n[&#x3D;]\n以值的形式捕获所有外部变量\n\n\n[&amp;]\n以引用形式捕获所有外部变量\n\n\n[&#x3D;, &amp;x]\n变量x以引用形式捕获，其余变量以传值形式捕获\n\n\n[&amp;, x]\n变量x以值的形式捕获，其余变量以引用形式捕获\n\n\n修改捕获变量前面我们提到过，在Lambda表达式中，如果以传值方式捕获外部变量，则函数体中不能修改该外部变量，否则会引发编译错误。那么有没有办法可以修改值捕获的外部变量呢？这是就需要使用mutable关键字，该关键字用以说明表达式体内的代码可以修改值捕获的变量，示例：\nint main()&#123;    int a = 123;    auto f = [a]()mutable &#123; cout &lt;&lt; ++a; &#125;; // 不会报错    cout &lt;&lt; a &lt;&lt; endl; // 输出：123    f(); // 输出：124&#125;   \n\nLambda表达式的参数Lambda表达式的参数和普通函数的参数类似，那么这里为什么还要拿出来说一下呢？原因是在Lambda表达式中传递参数还有一些限制，主要有以下几点：\n\n\n参数列表中不能有默认参数\n\n\n\n不支持可变参数\n\n\n\n所有参数必须有参数名\n\n\n\n常用举例：\n&#123;　　　　 int m = [](int x) &#123; return [](int y) &#123; return y * 2; &#125;(x)+6; &#125;(5);        std::cout &lt;&lt; &quot;m:&quot; &lt;&lt; m &lt;&lt; std::endl;            　　//输出m:16        std::cout &lt;&lt; &quot;n:&quot; &lt;&lt; [](int x, int y) &#123; return x + y; &#125;(5, 4) &lt;&lt; std::endl;            //输出n:9                auto gFunc = [](int x) -&gt; function&lt;int(int)&gt; &#123; return [=](int y) &#123; return x + y; &#125;; &#125;;        auto lFunc = gFunc(4);        std::cout &lt;&lt; lFunc(5) &lt;&lt; std::endl;        auto hFunc = [](const function&lt;int(int)&gt;&amp; f, int z) &#123; return f(z) + 1; &#125;;        auto a = hFunc(gFunc(7), 8);        int a = 111, b = 222;        auto func = [=, &amp;b]()mutable &#123; a = 22; b = 333; std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl; &#125;;        func();        std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl;        a = 333;        auto func2 = [=, &amp;a] &#123; a = 444; std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl; &#125;;        func2();        auto func3 = [](int x) -&gt;function&lt;int(int)&gt; &#123; return [=](int y) &#123; return x + y; &#125;; &#125;;    　　　　　　 std::function&lt;void(int x)&gt; f_display_42 = [](int x) &#123; print_num(x); &#125;;\tf_display_42(44);　　&#125;  \n\n详细的使用方式可以参考cppreference.com的Lambda 表达式 (C++11 起)的文档说明。\n参考\nC++ 11 Lambda表达式\nLambda 表达式 (C++11 起)\n\nC++ 阻止类被继承（继承类被实例化）的几种常用办法不时会留意到有人问起如何阻止 C++ 中的类被继承，但多数人都没有把这个问题问对。\n在 C++11 标准之前，阻止类被继承在语法上是做不到的，大家通常做到的只是继承而来的类不能被实例化了。这样一来，继承得到的类就完全没有用了。虽然最终的效果一致，但对问题的理解其实是有差异的。\n从 C++11 标准开始，C++ 引入了一个新的关键字 final，只有被 final 修饰的类才能真正做到不能被继承。\n下面举例实现常用的以达到“不能被继承&#x2F;继承类不能被实例化”的几种手段。\n私有化构造函数class Demo1&#123;public:    static Demo1* Create()    &#123;        return new Demo1;    &#125;private:    // 注意：私有掉构造函数    Demo1() &#123;&#125;    Demo1(const Demo1&amp;);    void operator=(const Demo1&amp;);&#125;;class Test1 : public Demo1&#123;&#125;;int main()&#123;//  Demo1*      pd1 = new Demo1;        // 错误：不能调用私有构造    Demo1*      pd1 = Demo1::Create();//  Test1*      pt1 = new Test1;        // 错误：不能调用基类私有构造&#125;\n\n使用 虚继承 + 私有基类构造函数template&lt;typename T&gt;class SealedT&#123;    // 注意：不是 friend class T;    friend T;private:    SealedT() &#123;&#125;&#125;;// 注意：是虚继承class Demo2 : virtual SealedT&lt;Demo2&gt;&#123;&#125;;int main()&#123;    Demo2*      pd2 = new Demo2;//  Test2*      pt2 = new Test2;        // 错误：不能访问间接虚基类&#125;  \n\n使用 虚继承 + 受保护的基类构造函数这个其实与前面一种形式是类似的。\nclass Sealed&#123;protected:    Sealed() &#123;&#125;&#125;;class Demo3 : virtual Sealed&#123;&#125;;class Test3 : public Demo3&#123;&#125;;int main()&#123;    Demo3*      pb3 = new Demo3;//  Test3*      pt3 = new Test3;        // 错误：不能访问间接虚基类&#125;   \n\n使用 final 关键字这个是最简单、最直接、最完美的。C++ 标准为啥如此晚才推出此功能。\nclass Demo4 final&#123;&#125;;// 不能从被 final 修饰的类继承，编译失败/*class Test4 : public Demo4&#123;&#125;;*/  \n\n参考\nPrevent class inheritance in C++\nVirtual inheritance\n\nVector初始化(1): vector ilist1;\n默认初始化，vector为空， size为0，表明容器中没有元素，而且 capacity 也返回 0，意味着还没有分配内存空间。这种初始化方式适用于元素个数未知，需要在程序中动态添加的情况。\n(2): vector ilist2(ilist);\nvector ilist2  &#x3D; ilist; \n两种方式等价 ，ilist2 初始化为ilist 的拷贝，ilist必须与ilist2 类型相同，也就是同为int的vector类型，ilist2将具有和ilist相同的容量和元素\n(3): vector ilist &#x3D; {1,2,3.0,4,5,6,7};\n vector ilist {1,2,3.0,4,5,6,7};\nilist 初始化为列表中元素的拷贝，列表中元素必须与ilist的元素类型相容，本例中必须是与整数类型相容的类型，整形会直接拷贝，其他类型会进行类型转换。\n(4): vector ilist3(ilist.begin()+2,ilist.end()-1);\nilist3初始化为两个迭代器指定范围中元素的拷贝，范围中的元素类型必须与ilist3 的元素类型相容，在本例中ilist3被初始化为{3,4,5,6}。注意：由于只要求范围中的元素类型与待初始化的容器的元素类型相容，因此迭代器来自不同的容器是可能的，例如，用一个double的list的范围来初始化ilist3是可行的。另外由于构造函数只是读取范围中的元素进行拷贝，因此使用普通迭代器还是const迭代器来指出范围并没有区别。这种初始化方法特别适合于获取一个序列的子序列。\n(5): vector ilist4(7);\n默认值初始化，ilist4中将包含7个元素，每个元素进行缺省的值初始化，对于int，也就是被赋值为0，因此ilist4被初始化为包含7个0。当程序运行初期元素大致数量可预知，而元素的值需要动态获取的时候，可采用这种初始化方式。\n(6):vector ilist5(7,3);\n指定值初始化，ilist5被初始化为包含7个值为3的int\n排序\nsort(vec.rbegin(), vec.rend());\n&#x2F;&#x2F;逆向排序 即按照从大到小的顺序进行排序   \n\nsort(vec.begin(), vec.end());\n&#x2F;&#x2F;正向排序 即按照从小到大的顺序排序\n\n\n合并​\tvector vec3;&#x2F;&#x2F;vec3是空的​    vec3.insert(vec3.end(),vec1.begin(),vec1.end())&#x2F;&#x2F;将vec1压入​    vec3.insert(vec3.end(),vec2.begin(),vec2.end())&#x2F;&#x2F;继续将vec2压入\n","slug":"cpp11","date":"2024-07-29T16:00:00.000Z","categories_index":"编程语言","tags_index":"C++","author_index":"暗使开开"},{"id":"7a98e4c3a6f8e8837400bb412e020029","title":"typecho","content":"centos安装typechohttps://github.com/typecho/typechoyum -y install unziptar -zxvf typecho-1.2.1.tar.gz mv typecho-1.2.1/ /usr/share/nginxcd /usr/share/nginxmv typecho-1.2.1/ amshadow/配置ngxinvi /etc/nginx/servers/amshadow.conf--------------------------------------------------------server &#123;\tlisten       443 ssl http2;    listen       [::]:443 ssl http2;    server_name  amshadow.com www.amshadow.com; \troot         /usr/share/nginx/amshadow; \t\t\t\t#证书文件名称        ssl_certificate &quot;/etc/nginx/cert/amshadow.pem&quot;;        #证书私钥文件名称        ssl_certificate_key &quot;/etc/nginx/cert/amshadow.key&quot;;        #ssl_session_cache shared:SSL:1m;        #ssl验证配置        ssl_session_timeout  10m;        #配置加密套件/算法加密，写法遵循openssl标准        ssl_ciphers HIGH:!aNULL:!MD5;        #使用服务器端的首选算法        ssl_prefer_server_ciphers on;        #安全链接可选加密协议        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;\t\t    access_log /var/log/nginx/typecho_access.log main;        if (!-e $request_filename)&#123;            rewrite ^(.*)$ /index.php$1 last;        &#125;\t\tlocation / &#123;\t\t\tindex index.php index.html index.htm;\t\t\tif (!-e $request_filename)&#123;\t\t\t    rewrite . /index.php last;\t\t\t&#125;\t\t&#125;\t\t\tlocation ~ \\.php$ &#123;\t\t\tfastcgi_pass 127.0.0.1:9000;\t\t\tfastcgi_index index.php;\t\t\tfastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info;\t\t\tfastcgi_split_path_info ^((?U).+\\.php)(/?.+)$;\t\t\tfastcgi_param PATH_INFO $fastcgi_path_info;\t\t\tfastcgi_param SCRIPT_NAME $fastcgi_script_name;\t\t\tfastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\t\t\tinclude fastcgi_params;\t\t&#125;\t&#125;--------------------------------------------------------chmod -R 777 /usr/share/nginx/amshadow/mysql -uroot -pcreate database typecho_amshadow character set utf8mb4 collate utf8mb4_unicode_ci;安装主题cd /usr/share/nginx/amshadow/usr/themes/https://github.com/HaoOuBa/Joeunzip Joe-master.zip\n\n","slug":"centos安装typecho","date":"2024-07-29T16:00:00.000Z","categories_index":"开发经验","tags_index":"","author_index":"暗使开开"},{"id":"cbb09a7d07164fc708d0a80c33389535","title":"PhotoShop","content":"PS操作ctrl &#x3D; command\n保存 ctrl shift s 或 ctrl s\n导出图片 ctrl shift alt s\n新建 ctrl n\n打开 ctrl o 或者 拖拽图片到导航栏\n隐藏工具栏参数栏 tab\n撤销 ctrl z\n画布放缩 ctrl  -+ \n增加画布分辨率 ctrl alt i\n扩大画布空间 ctrl alt c 或用 c 裁剪\n平滑缩放 z 鼠标拖动\n铺满屏幕 ctrl 0\n拖动画布 空格 鼠标拖动\n旋转画布 r 鼠标拖动\n摆正画布 r 点击复位试图\n全屏画布 ff\n水平翻转画布 图像 -》图像旋转 -》水平翻转画布\n显示画面全貌 窗口 -》导航器 或者 窗口 -》排列 -》为。新建窗口&#x2F;双联水平\n笔刷笔刷 b\n橡皮 e\n移动工具 v\n缩放 [ ]\n粗犷： 不透明度\n柔和： 流量\n图层新建图层 ctrl shift n\n选中图层编入组 ctrl g\n向下合并图层 ctrl e\n索套工具索套 L\n截切 ctrl x\n选择性粘贴 ctrl shift v\n自由变换 ctrl t\n修改好 enter\n液化滤镜-》液化 ctrl shift x\n向前变形工具 w\n膨胀 b\n褶皱 s\n","slug":"photoshop","date":"2024-07-29T16:00:00.000Z","categories_index":"工具","tags_index":"Photoshop","author_index":"暗使开开"},{"id":"59d08af7bf67b272e6c3678eec727abd","title":"股票","content":"一定要记住，交易不是打卡上班，不是工地搬砖，不是多搬一块，就多赚一块，大多数时候，你做的越多，亏的越多。\n 交易的最高艺术，就是等待。一直等下去。时间，是交易最大的秘密。\n赚钱效应\n少于5只票跌停，大于50只涨停。\n大量连板涨停股，且没有天地板。\n大多数板块开始止跌并放量有资金进入。\n\n衰竭反转2B理论基础：趋势衰竭，吸筹急迫，猎杀止损。要点\n确定周期（极为重要），按周期止损止盈，大周期2B很少，小周期较多\n第二根K线必须拉起（越快概率越高）\n量价配合过滤\n5浪模型过滤\n前期支撑压力过滤\n\n衰竭型2B与普通2B（威科夫理论中的弹簧）区别（讲完弹簧再讲）\n趋势线理论基础：惯性，任何股价或者趋势一旦形成，将持续下去，直到外力导致其发生改变。要点\n最少要穿越两个点高或者低点\n\n触点越多越有效，时间越长越有效\n\n\n用法\n提示趋势转折可能信号\n分批止盈\n新入场机会提示\n\n错误用法\n直接用于判断支撑，压力\n\n突破就开仓\n\n\n其它方法搭配\n趋势线+巨量&#x2F;M头&#x2F;W底&#x2F;缺口&#x2F;2B&#x2F;盘口等（上证30年日K线复盘）\n  趋势线+W\\M形态双突破趋势线+支撑 压力互换线\n\n\n头肩顶和头肩底理论基础：趋势转折，市场情绪变弱。要点\nABCD四步，每一步都配合量能\n头肩底：左肩到右肩不断缩量，突破头肩放量（理想状态）\n头肩顶：左肩头部巨量，右肩缩量，突破放量（理想状态）\n\n\n顺大逆小是关键的关键（核心的核心）\n趋势线突破（衰竭反转）\n箱体弹簧（中继头肩）\n钻石形变异（大底大顶）\n\n支撑与压力测试理论基础：行为金融学和市场情绪 持仓成本。要点\n前期高低点位（存在的就是合理的）\n前期成交密集区（机构建仓区）\n前期量能密集区（机构建仓区）\n趋势线与切线交叉点（趋势惯性）\n均线，布林线，通道线\n机构订单流的地方（波动剧烈十字星）\n\n用法\n支撑与压力互换，找开仓点\n用于计算沽压，盈亏比\n时间越长越有效，但突破后力度也越大\n\n其它方法搭配\n趋势线+形态＋量价+盘口\n\n缺口理论缺口就是没有成交量和成交数据的跳空价格移动区域。\n形成原因主要是开盘价的资金操纵，因为基本面或者消息面的利空或者利好，在开盘用资金操纵了价格的跳空。1分钟行情一般都会缺只但5M,15M.，30M，1D是否能形成，则要等这一个周期的行情走完才可以。\n缺口分类为：\n普通缺口（无意义）\n突破缺口&#x2F;区间形态跳空缺口（重大意义）\n中继形缺口（突破后的跳空缺口）\n衰竭缺口（和量能相配合，最后乏力跳空）\n岛形反转\n\n趋势线交易用趋势线交易发的重点100%错过最高点卖出，该卖就卖，不要等再拉上去\n买入时间：\n第一波巨量拉升和第二波巨量拉伸一般间隔在三个月左右，大概率可能是第一波资金没出完\n一字板涨停股途中巨量第一根跌停打开第二根接近跌停的巨量可以进，注意止损和基本面\n拉升涨停股途中巨量打开跌停，后面两天巨量调整价格被跌停阴线包住，可以买\n集合竞价高开但不高太多\n集合竞价买入的一定龙虎榜\n\n\n涨停排队\n下午中午做低吸\n大盘前一天做了一个巨量十字星\n顺大逆小（早上）\n箱体下沿买入\n日k下跌，下午买在分时追涨冲破趋势，要大盘有好转\n\n\n尾盘买入，不追高，不要买早盘套牢的股\n2：30 行业+概念+主题+新闻+龙虎榜+业内点评+股东+研报\n\n\n\n趋势不好：坚定止损，绝不亏损加仓\n形态突破买入，不要贪心，财不入急门，怎么吃的怎么吐出来\n次日走高卖出，早上开盘冲高超过3%可以卖，然后进行低吸\n次日走低止损，开盘回落跌过支撑位或者跌超过3%可以止损。不要等跌破，止损设小点，大概率回调不要着急\n\n\n超跌反弹，连续两三天大阴k线跌破15日均线，跌的特别快特别猛，一定要是加速，跌停也可买\n2B第二天入 第二个B尾盘买，第三天早盘卖\n只做短线，今天买明天卖，特别是第二天高开一点点2%以内和第二天低开超过1.5%，必须一开盘就卖，集合竞价不要以跌停价卖出\n一字涨停要强势有主题\n买入后，一定当天设条件单，两个止盈止损，风险压力卖出位\n反弹止损1.8%\n不做普通反弹\n不做垃圾股\n\n选股：新故事出现在主流热点，有一定持续性\n\n主流热点：板块，主题\n\n道氏+k线组合\n\n看龙虎榜，机构+威科夫\n\n设止盈止损（坚定止盈止损，不贪心。放下我执，节奏踏对）\n\n\n新故事：重组，利好，政策，业绩，突发性\n持续性：赚钱效应，龙头不倒，整体板块涨多跌少，连板数量多\n长期低位盘整，巨量开始\n交易手法：尽量右侧交易,上升趋势 心中无定底\n\n一字涨停+放量形态突破+缺口位置（第二天低开，回抽就走 高开早盘卖出）\n顺大逆小的超跌+支撑压力位 低吸（左侧交易也行）\n运势突破+分时共振 日线和分时上涨 (下午两点以后收盘前一分钟)早盘不追高，除非是一字涨停去排队\n\n左侧交易 超跌机会（远离15日均线）\n大盘初期跌 龙头会回抽 中期跌 龙头补跌 弱势超跌 后期新题材\n买弱势的超跌 ，不买强势的主跌\n买入机会 卖出风险 不存在止盈止损赚钱亏钱\n买入时间：机会\n集合竞价\n涨停排队\n盘中，盘尾低吸&#x2F;尾盘分时突破\n\n卖出时间：风险\n开盘涨停，打开1.5%，行情好可以做套\n\n做套时间（超出预定止损就不要再做套了，坚定出来，不要买入）：集合竞价结束后开盘的五分钟：行情不好时，又有热点的股，集合竞价打开跌停，25-30分坚定设单（当日下跌1%左右），然后做套，不要犹豫，形势好做套2%左右\n\n2024&#x2F;2&#x2F;1 000068 开盘该挂4.87，犹豫不决 少10%的套\n\n早盘做套：10点左右如果出现买盘衰竭就卖出，行情好做套3%-5%，尾盘如果没上来不要买\n短线仓位1&#x2F;3，不要超过 1&#x2F;2 不拿10%，行情好5%-8%，行情不好2%-5%\n节奏一定要走对，走错先止损出来\n","slug":"stock","date":"2024-07-29T16:00:00.000Z","categories_index":"stock","tags_index":"股票经验教训","author_index":"暗使开开"},{"id":"a46ecae7f41acb35c93608332eb0101a","title":"软件使用技巧","content":"软件使用技巧批量重命名文件、文件夹、拓展名EverythingEverything是一款好用的文件搜索定位工具，能够帮助我们在电脑中快速找到想要的文件，体积小巧，界面简洁易用。\n此外，它也可以批量重命名文件、文件夹、拓展名。\n打开软件后，找到“搜索——高级搜索”，找到我们想要重命名的文件所在文件夹。\n选择部分文件或全选文件后，按F2键，会弹出重命名的框，可以直接在新表达式中输入，也可以选择系统识别到的规则表达式输入，之后点击“确定”即可。\nCMD:内网发送信息MSG /server:内网ip * &quot;找你没事情，下午出去玩吧&quot;\n\n查看当前所有连接过的wifi密码netsh wlan show profilesnetsh wlan show profile name=&quot;&quot; key=clear\n\n查看ip和自己的外网地址ipconfig /allcurl -L ip.tool.lu\n\n远程控制mstsc\n\n修改字体颜色color allcolor a永久修改regedit编辑查找DefaultColor数据数值改成a\n\n查看电脑上的用户防入侵net usernet user name /del\n\n电脑卡检查系统完整性sfc /SCANNOW\n\n\n\n网络ipcip.cc\n\n\n\ntypora设置图片相对路径\n\npr打不开 报错Application Specific Information:C:\\Program Files\\Adobe\\Adobe Premiere Pro CC 2018\\ZXPSignLib-minimal.dllThread 0 Crashed:\t[18148]\tTHREAD_PRIORITY_NORMAL0\tZXPSignLib-minimal  0x00000000056473e3 ? Unknown - (Symbols generated from a DLL export table)\t[  Error:487 试图访问无效的地址。 ]1\t ???? (  Error: 126 找不到指定的模块。 ) 0x00000000527a4d77 ? Unknown - ()\t[  Error:126 找不到指定的模块。 ]\n\n把pr中的文件复制到安装目录替换\n","slug":"tips","date":"2024-07-29T16:00:00.000Z","categories_index":"工具","tags_index":"","author_index":"暗使开开"},{"id":"d9fc71ed043887014cb753078e35703f","title":"数据库规范","content":"数据库规范表名 T_ +表名大写英文字母  T_TABLENAME字段名 统一小写英文字母  name表索引 IDX_ + 表名 +_1 索引数字 IDX_TABLENAME_1主键 PK_+表名PK_TABLENAME外键 FK_当前表名_主键表名FK_SHOWLOG_GIRLS键 表名_字段名 大写TABLENAME_KEYID视图 V_ +表名备注结束要加。姓名。\n\n\n\n","slug":"数据库规范","date":"2024-07-29T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"暗使开开"},{"id":"42a37c99055000ceaa62b8305cac08db","title":"要唱就唱","content":"","slug":"唱歌","date":"2024-07-29T16:00:00.000Z","categories_index":"爱好","tags_index":"","author_index":"暗使开开"},{"id":"2d728caa47af746573cb7fba96b85d4f","title":"C++","content":"滑动窗口控制流量滑动窗口是什么，用c++写一个例子说明滑动窗口是一种常用的算法技术，它可以在数组或列表中查找子数组或子列表，以解决各种问题。滑动窗口通常从数组的一端开始，然后向另一端移动，同时保持窗口的大小不变，或者根据某些条件增大或缩小窗口的大小。\n以下是一个使用C++编写的滑动窗口的例子，该例子用于找出数组中和为给定值的连续子数组：\n#include &lt;iostream&gt;#include &lt;vector&gt;std::vector&lt;int&gt; slidingWindow(std::vector&lt;int&gt;&amp; nums, int target) &#123;    int left = 0;    int sum = 0;    std::vector&lt;int&gt; result;    for (int right = 0; right &lt; nums.size(); right++) &#123;        sum += nums[right];        while (sum &gt; target) &#123;            sum -= nums[left];            left++;        &#125;        if (sum == target) &#123;            result.assign(nums.begin() + left, nums.begin() + right + 1);            break;        &#125;    &#125;    return result;&#125;int main() &#123;    std::vector&lt;int&gt; nums = &#123;1, 2, 3, 4, 5&#125;;    int target = 9;    std::vector&lt;int&gt; result = slidingWindow(nums, target);    std::cout &lt;&lt; &quot;Subarray with sum &quot; &lt;&lt; target &lt;&lt; &quot;: &quot;;    for (int num : result) &#123;        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;\n\n\n\n这个程序首先定义了一个名为slidingWindow的函数，该函数接受一个整数向量和一个目标值作为输入。然后，它使用两个指针left和right来表示滑动窗口的边界，并使用变量sum来跟踪窗口中的数字之和。当sum大于目标值时，它会从sum中减去left指向的数字，并将left向右移动一位。当sum等于目标值时，它会将滑动窗口中的数字添加到结果向量中，并结束循环。最后，main函数中的代码创建了一个示例数组和目标值，并调用slidingWindow函数来找到和为目标值的子数组。然后，它打印出这个子数组的内容。这就是滑动窗口算法的一个基本应用。\n如何使用话动窗口控制客户端与服务端之间的流量控制滑动窗口是一种常用的流量控制技术，它可以有效地控制客户端和服务器之间的数据传输速率，以防止网络拥塞。在计算机网络中，滑动窗口协议是一种流量控制协议，TCP（传输控制协议）就是使用滑动窗口协议来进行流量控制的。\n以下是滑动窗口如何用于流量控制的基本步骤：\n\n初始化窗口大小：在连接建立时，服务器会告诉客户端它的接收窗口大小，这个大小通常是根据服务器当前的网络状况和处理能力来设定的。\n数据传输：客户端在发送数据时，会根据服务器告知的窗口大小来确定一次可以发送多少数据。例如，如果窗口大小为5，那么客户端一次最多可以发送5个数据包。\n确认接收：当服务器接收到数据后，会发送一个确认消息给客户端，告诉客户端已经接收到了哪些数据，并告知新的窗口大小。\n调整窗口大小：如果网络状况良好，服务器可以增大窗口大小，允许客户端发送更多的数据。如果网络状况变差，服务器可以减小窗口大小，减少客户端的数据发送速率。\n处理丢包：如果客户端发送的某个数据包在服务器端没有被确认接收，客户端会认为这个数据包丢失，然后重新发送这个数据包。\n\n通过这种方式，滑动窗口协议可以动态地调整数据的传输速率，有效地控制了客户端和服务器之间的流量，防止了网络拥塞。希望这个解释能帮助你理解滑动窗口是如何用于流量控制的。\n用c++写一个滑动窗口来控制流量的例子在实际的网络编程中，滑动窗口通常用于TCP协议的流量控制，这涉及到底层的网络编程和操作系统的API调用，可能比较复杂。但是，我可以给你一个简化的例子，来模拟滑动窗口的基本工作原理。\n这个例子中，我们将创建一个SlidingWindow类，用于模拟滑动窗口的行为。这个类有一个windowSize成员变量，表示窗口的大小，还有一个sendData成员函数，用于发送数据。\n#include &lt;iostream&gt;#include &lt;queue&gt;class SlidingWindow &#123;public:    SlidingWindow(int size) : windowSize(size) &#123;&#125;    void sendData(int data) &#123;        if (window.size() &lt; windowSize) &#123;            window.push(data);            std::cout &lt;&lt; &quot;Data &quot; &lt;&lt; data &lt;&lt; &quot; sent.\\n&quot;;        &#125; else &#123;            std::cout &lt;&lt; &quot;Window is full. Data &quot; &lt;&lt; data &lt;&lt; &quot; is waiting.\\n&quot;;        &#125;    &#125;    void acknowledge() &#123;        if (!window.empty()) &#123;            std::cout &lt;&lt; &quot;Data &quot; &lt;&lt; window.front() &lt;&lt; &quot; acknowledged.\\n&quot;;            window.pop();        &#125;    &#125;private:    int windowSize;    std::queue&lt;int&gt; window;&#125;;int main() &#123;    SlidingWindow sw(3);    for (int i = 1; i &lt;= 5; ++i) &#123;        sw.sendData(i);    &#125;    sw.acknowledge();    sw.sendData(6);    return 0;&#125;\n\n\n\n在这个例子中，我们首先创建了一个滑动窗口，窗口大小为3。然后，我们尝试发送5个数据。由于窗口大小为3，所以前3个数据可以立即发送，但是第4个和第5个数据需要等待。然后，我们确认了一个数据，这会使窗口向前滑动一位，从而为新的数据腾出空间。最后，我们发送了第6个数据。\n这个例子虽然简单，但是展示了滑动窗口的基本工作原理：当窗口满时，新的数据需要等待；当有数据被确认时，窗口会向前滑动，为新的数据腾出空间。在实际的网络编程中，滑动窗口的工作原理也是类似的，只是会涉及到更多的细节和复杂性。希望这个例子能帮助你理解滑动窗口是如何工作的。\n","slug":"滑动窗口控制流量","date":"2024-07-29T16:00:00.000Z","categories_index":"","tags_index":"C++","author_index":"暗使开开"},{"id":"e5520f8a714d72e3ef4686fea1f51fcb","title":"混合开发","content":"混合开发个人观点：混合开发推荐Flutter、Electron 和Qt\nElectron背景：Electron 由 GitHub 开发，因其使用 HTML、CSS 和 JavaScript 等 Web 技术构建跨平台桌面应用程序的能力而广受欢迎。\n主要功能：Electron 通过其 Node.js 集成提供对本机 API 的轻松访问，使开发人员能够创建功能丰富的应用程序。它还支持用 C++ 编写的本机插件，尽管构建这些插件可能更复杂且容易出错。\nElectron：以其较高的资源使用率而闻名，Electron 应用程序可能会占用更多内存和 CPU，从而影响较旧或功能较弱的计算机的性能。\nElectron 提供了大量预构建的 UI 组件和广泛的主题选项。开发人员可以轻松创建具有视觉吸引力的应用程序。\nElectron：Electron 通过 Node.js 集成提供对本机 API 的轻松访问。它还支持用 C++ 编写的本机插件，尽管构建这些插件可能更复杂且容易出错。\nElectron：广泛用于构建跨平台桌面应用程序，包括代码编辑器（VSCode）、通信工具（Slack）和娱乐应用程序（Spotify）。\nElectron：Electron 应用程序可能会占用大量资源，可能会导致旧硬件上出现性能问题。\nFlutter背景：Flutter 由 Google 创建，以其在移动应用程序开发中的使用而闻名，但也可用于桌面应用程序。\n主要特点：Flutter 提供了一组丰富的可定制 UI 小部件，其 Dart 代码被编译为本机机器代码，从而实现快速执行并减少开销。它采用独特的“基于小部件”架构，提供丰富的可定制 UI 小部件。\nFlutter：Flutter 的性能值得称赞，这要归功于它的编译代码和 GPU 加速。它提供快速的启动时间和流畅的动画。\nFlutter 基于小部件的方法允许高度可定制且具有视觉吸引力的用户界面。它提供了广泛的开箱即用的小部件。\nFlutter：Flutter 的 Dart 代码被编译为本机机器代码，从而实现快速执行并减少开销。它采用了一种称为“基于小部件”架构的独特方法，提供了一组丰富的可定制 UI 小部件。\nFlutter：Flutter 逐渐成为富媒体应用程序的选择，已用于 Google Ads、阿里巴巴和 Reflectly 等应用程序。\nFlutter：如果您主要是移动开发人员，那么使用 Flutter 进行桌面开发可能会涉及一个学习曲线。\nTauri背景：Tauri 是一个较新的框架，旨在创建安全且轻量级的桌面应用程序。它旨在弥合 Rust 和 Web 技术之间的差距。\n主要功能：Tauri 支持使用 Rust 或 C 构建本机插件，从而可以访问 Web 平台中不可用的本机 API 和功能。\nTauri：Tauri 因其轻量级特性和低资源消耗而脱颖而出。它是构建快速且响应灵敏的桌面应用程序的绝佳选择。\nTauri：Tauri 不像其他框架那样提供那么多的 UI 组件，但允许对用户界面进行严格控制，这有利于创建独特的设计。\nTauri：Tauri 支持使用 Rust 或 C 构建原生插件，可用于访问 Web 平台中不可用的原生 API 和功能。\nTauri：Tauri 正在获得轻量级、安全应用程序的青睐，包括密码管理器 (LosePass) 和通信工具 (Mailspring)。\nTauri：作为一个相对较新的框架，与更成熟的选项相比，Tauri 可能拥有较小的社区和较少的第三方库。\nReact Native背景：React Native，同样来自 Facebook，主要以移动应用程序开发而闻名，但也有桌面应用程序开发的扩展。\n主要特点：React Native 提供了一种访问本机 API 和功能的方法，但与其他框架相比，它可能需要更多的努力。它支持无缝集成第三方库。\nReact Native 虽然主要是为移动设备设计的，但可以扩展以创建桌面应用程序。然而，它的跨平台支持可能不像其他框架那样无缝，并且可能需要额外的努力才能在所有平台上实现一致的性能和 UI。\nReact Native 桌面应用程序可以节省资源，但跨平台优化性能可能需要额外的工作。\nReact Native：通过React Native，开发人员可以使用第三方库和组件进行UI设计。可能需要额外的工作才能实现完全定制的外观。\nReact Native：React Native 提供了一种访问本机 API 和功能的方法，但与其他框架相比可能需要更多的努力。它支持无缝集成第三方库。\nReact Native：虽然主要是一个移动框架，但 React Native 已扩展到 Discord 和 Microsoft Teams 等应用程序中的桌面使用。\nReact Native：将 React Native 转换到桌面可能需要额外的努力，并且某些特定于平台的功能可能更难访问\nQt背景：Qt 是一个 C++ 框架，绑定了多种语言，包括 Python 和 JavaScript。这是一个历史悠久、历史悠久的框架。\n主要特性：Qt 提供出色的本机集成功能，允许开发人员访问本机 API 和功能。它提供了一套用于构建跨平台桌面应用程序的全面工具，并强调本机外观和感觉。\n性能非常出色，提供类似本机的速度和响应能力。它是资源密集型应用程序的首选。\nQt：Qt 擅长提供与目标平台无缝集成的类似本机的 UI 元素。它是需要精美原生外观的应用程序的首选。\nQt：Qt 提供出色的本机集成功能。它是一个 C++ 框架，绑定了多种语言，包括 Python 和 JavaScript，可用于访问本机 API 和功能。\nQt：Qt 是一种多功能选择，可用于从工业软件到游戏和汽车信息娱乐系统的广泛应用。\nQt：Qt 的学习曲线，特别是对于刚接触 C++ 的开发人员来说，可能是一个挑战。\nQt法务的律师函也相当强\n","slug":"混合开发","date":"2024-07-29T16:00:00.000Z","categories_index":"个人见解","tags_index":"","author_index":"暗使开开"},{"id":"9ffd256e9fff6c4df350e6574fc875b0","title":"VPS 搭建 Reality协议节点","content":"VPS 搭建 Reality协议节点一、准备工作1、VPS一台，重置好系统（CentOS &#x2F; Debian &#x2F; Ubuntu）本期教程视频使用的 VPS 官网：点此打开\nXTLS官方Reality开源仓库：**点此打开**\n新版X-UI面板作者开源仓库：**点此打开**\n\n二、开始搭建 Reality\n1、安装组件\nCentOS系统分别执行如下命令：\nyum update -yyum install curl wget -y\n\n2、Debian &#x2F; Ubuntu系统分别执行如下命令\napt update -yapt install curl wget -y\n\n\n三、安装 X-ui 作者开源仓库地址：点此打开\nbash &lt;(curl -Ls https://raw.githubusercontent.com/FranzKafkaYu/x-ui/master/install.sh)\n\n\n四、BBR网络拥堵算法\n1、CentOS 开启 BBR 加速\nwget -N --no-check-certificate &quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh\n\n2、Debian &#x2F; Ubuntu 开启 BBR2 加速\nwget --no-check-certificate -q -O bbr2.sh &quot;https://github.com/yeyingorg/bbr2.sh/raw/master/bbr2.sh&quot; &amp;&amp; chmod +x bbr2.sh &amp;&amp; bash bbr2.sh auto\n\n\nPS：如搭建完成，无法打开X-UI面板，请检查你VPS端口是否放行，如Reality节点搭建好无法使用，请打开网址：https://ping.pe 输入VPS公网IP查看IP是否被墙！\n","slug":"vps搭建Reality协议节点","date":"2023-07-24T16:00:00.000Z","categories_index":"编程语言","tags_index":"shell","author_index":"暗使开开"},{"id":"2d728caa47af746573cb7fba96b85d4f","title":"C++","content":"C++中map与unordered_map的区别头文件\nmap: #include &lt;map&gt;\nunordered_map: #include &lt;unordered_map&gt;\n\n内部实现机理\nmap： map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。\nunordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的\n\nunordered_map和map类似，都是存储的key-value的值，可以通过key快速索引到value。不同的是unordered_map不会根据key的大小进行排序，存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。\n所以使用时map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator==。但是很多系统内置的数据类型都自带这些，那么如果是自定义类型，那么就需要自己重载operator&lt;或者hash_value()了。\n优缺点以及适用处\n\n\n\nmap\nunordered_map\n\n\n\n优点\n有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作红黑树，内部实现一个红黑书使得map的很多操作在lgnlgn的时间复杂度下就可以实现，因此效率非常的高\n因为内部实现了哈希表，因此其查找速度非常的快\n\n\n缺点\n空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红&#x2F;黑性质，使得每一个节点都占用大量的空间\n哈希表的建立比较耗费时间\n\n\n适用处\n对于那些有顺序要求的问题，用map会更高效一些\n对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map\n\n\n结论如果需要内部元素自动排序，使用map，不需要排序使用unordered_map\nnote:对于unordered_map或者unordered_set容器，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照哈希表从前往后依次遍历的\n参考\nc++中map与unordered_map的区别\nC++11 新特性： unordered_map 与 map 的对比\n\nC++ 11之Lambda表达式C++11的一大亮点就是引入了Lambda表达式。利用Lambda表达式，可以方便的定义和创建匿名函数,用以替换独立函数或者函数对象，并且使代码更可读。但是从本质上来讲，lambda表达式只是一种语法糖，因为所有其能完成的工作都可以用其它稍微复杂的代码来实现。但是它简便的语法却给C++带来了深远的影响。如果从广义上说，lamdba表达式产生的是函数对象。在类中，可以重载函数调用运算符()，此时类的对象可以将具有类似函数的行为，我们称这些对象为函数对象（Function Object）或者仿函数（Functor）。对于C++这门语言来说来说，“Lambda表达式”或“匿名函数”这些概念听起来好像很深奥，但很多高级语言在很早以前就已经提供了Lambda表达式的功能，如C#，Python等。今天，我们就来简单介绍一下C++中Lambda表达式的简单使用。\n声明Lambda表达式Lambda表达式完整的声明格式如下：\n[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125; \n\n各项具体含义如下\n\ncapture list：捕获外部变量列表\nparams list：形参列表\nmutable指示符：用来说用是否可以修改捕获的变量\nexception：异常设定\nreturn type：返回类型\nfunction body：函数体\n\n此外，我们还可以省略其中的某些成分来声明“不完整”的Lambda表达式，常见的有以下几种：\n\n\n\n序号\n格式\n\n\n\n1\n[capture list] (params list) -&gt; return type {function body}\n\n\n2\n[capture list] (params list) {function body}\n\n\n3\n[capture list] {function body}\n\n\n其中：\n\n格式1声明了const类型的表达式，这种类型的表达式不能修改捕获列表中的值。\n格式2省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型： （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定； （2）：如果function body中没有return语句，则返回值为void类型。\n格式3中省略了参数列表，类似普通函数中的无参函数。\n\nLambda表达式的一个实例\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(int a, int b)&#123;    return  a &lt; b;&#125;int main()&#123;    vector&lt;int&gt; myvec&#123; 3, 2, 5, 7, 3, 2 &#125;;    vector&lt;int&gt; lbvec(myvec);    sort(myvec.begin(), myvec.end(), cmp); // 旧式做法    cout &lt;&lt; &quot;predicate function:&quot; &lt;&lt; endl;    for (int it : myvec)        cout &lt;&lt; it &lt;&lt; &#x27; &#x27;;    cout &lt;&lt; endl;    sort(lbvec.begin(), lbvec.end(), [](int a, int b) -&gt; bool &#123; return a &lt; b; &#125;);   // Lambda表达式    cout &lt;&lt; &quot;lambda expression:&quot; &lt;&lt; endl;    for (int it : lbvec)        cout &lt;&lt; it &lt;&lt; &#x27; &#x27;;&#125;\n\n在C++11之前，我们使用STL的sort函数，需要提供一个谓词函数。如果使用C++11的Lambda表达式，我们只需要传入一个匿名函数即可，方便简洁，而且代码的可读性也比旧式的做法好多了。\n下面，我们就重点介绍一下Lambda表达式各项的具体用法。\n捕获外部变量Lambda表达式可以使用其可见范围内的外部变量，但必须明确声明（明确声明哪些外部变量可以被该Lambda表达式使用）。那么，在哪里指定这些外部变量呢？Lambda表达式通过在最前面的方括号[]来明确指明其内部可以访问的外部变量，这一过程也称过Lambda表达式“捕获”了外部变量。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    int a = 123;    auto f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;     f(); // 输出：123    //或通过“函数体”后面的‘()’传入参数    auto x = [](int a)&#123;cout &lt;&lt; a &lt;&lt; endl;&#125;(123); &#125;  \n\n上面这个例子先声明了一个整型变量a，然后再创建Lambda表达式，该表达式“捕获”了a变量，这样在Lambda表达式函数体中就可以获得该变量的值。\n类似参数传递方式（值传递、引入传递、指针传递），在Lambda表达式中，外部变量的捕获方式也有值捕获、引用捕获、隐式捕获。\n1、值捕获值捕获和参数传递中的值传递类似，被捕获的变量的值在Lambda表达式创建时通过值拷贝的方式传入，因此随后对该变量的修改不会影响影响Lambda表达式中的值。\n示例如下：\nint main()&#123;    int a = 123;    auto f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;     a = 321;    f(); // 输出：123&#125;  1 2 3 4 5 6 7 int main() &#123;    int a = 123;    auto f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;     a = 321;    f(); // 输出：123 &#125;   \n\n*这里需要注意的是，如果以传值方式捕获外部变量，则在Lambda表达式函数体中不能修改该外部变量的值。*\n2、引用捕获使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符 &amp;。如下：\nint main()&#123;    int a = 123;    auto f = [&amp;a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;     a = 321;    f(); // 输出：321&#125;   \n\n从示例中可以看出，引用捕获的变量使用的实际上就是该引用所绑定的对象。\n3、隐式捕获上面的值捕获和引用捕获都需要我们在捕获列表中显示列出Lambda表达式中使用的外部变量。除此之外，我们还可以让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获。隐式捕获有两种方式，分别是[=]和[&amp;]。[=]表示以值捕获的方式捕获外部变量，[&amp;]表示以引用捕获的方式捕获外部变量。\n隐式值捕获示例：\nint main()&#123;    int a = 123;    auto f = [=] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    // 值捕获    f(); // 输出：123&#125;  \n\n隐式引用捕获示例：\nint main()&#123;    int a = 123;    auto f = [&amp;] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    // 引用捕获    a = 321;    f(); // 输出：321&#125;  \n\n4、混合方式上面的例子，要么是值捕获，要么是引用捕获，Lambda表达式还支持混合的方式捕获外部变量，这种方式主要是以上几种捕获方式的组合使用。\n到这里，我们来总结一下：C++11中的Lambda表达式捕获外部变量主要有以下形式：\n\n\n\n捕获形式\n说明\n\n\n\n[]\n不捕获任何外部变量\n\n\n[变量名, …]\n默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp; 说明符）\n\n\n[this]\n以值的形式捕获this指针\n\n\n[&#x3D;]\n以值的形式捕获所有外部变量\n\n\n[&amp;]\n以引用形式捕获所有外部变量\n\n\n[&#x3D;, &amp;x]\n变量x以引用形式捕获，其余变量以传值形式捕获\n\n\n[&amp;, x]\n变量x以值的形式捕获，其余变量以引用形式捕获\n\n\n修改捕获变量前面我们提到过，在Lambda表达式中，如果以传值方式捕获外部变量，则函数体中不能修改该外部变量，否则会引发编译错误。那么有没有办法可以修改值捕获的外部变量呢？这是就需要使用mutable关键字，该关键字用以说明表达式体内的代码可以修改值捕获的变量，示例：\nint main()&#123;    int a = 123;    auto f = [a]()mutable &#123; cout &lt;&lt; ++a; &#125;; // 不会报错    cout &lt;&lt; a &lt;&lt; endl; // 输出：123    f(); // 输出：124&#125;   \n\nLambda表达式的参数Lambda表达式的参数和普通函数的参数类似，那么这里为什么还要拿出来说一下呢？原因是在Lambda表达式中传递参数还有一些限制，主要有以下几点：\n\n\n参数列表中不能有默认参数\n\n\n\n不支持可变参数\n\n\n\n所有参数必须有参数名\n\n\n\n常用举例：\n&#123;　　　　 int m = [](int x) &#123; return [](int y) &#123; return y * 2; &#125;(x)+6; &#125;(5);        std::cout &lt;&lt; &quot;m:&quot; &lt;&lt; m &lt;&lt; std::endl;            　　//输出m:16        std::cout &lt;&lt; &quot;n:&quot; &lt;&lt; [](int x, int y) &#123; return x + y; &#125;(5, 4) &lt;&lt; std::endl;            //输出n:9                auto gFunc = [](int x) -&gt; function&lt;int(int)&gt; &#123; return [=](int y) &#123; return x + y; &#125;; &#125;;        auto lFunc = gFunc(4);        std::cout &lt;&lt; lFunc(5) &lt;&lt; std::endl;        auto hFunc = [](const function&lt;int(int)&gt;&amp; f, int z) &#123; return f(z) + 1; &#125;;        auto a = hFunc(gFunc(7), 8);        int a = 111, b = 222;        auto func = [=, &amp;b]()mutable &#123; a = 22; b = 333; std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl; &#125;;        func();        std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl;        a = 333;        auto func2 = [=, &amp;a] &#123; a = 444; std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl; &#125;;        func2();        auto func3 = [](int x) -&gt;function&lt;int(int)&gt; &#123; return [=](int y) &#123; return x + y; &#125;; &#125;;    　　　　　　 std::function&lt;void(int x)&gt; f_display_42 = [](int x) &#123; print_num(x); &#125;;\tf_display_42(44);　　&#125;  \n\n详细的使用方式可以参考cppreference.com的Lambda 表达式 (C++11 起)的文档说明。\n参考\nC++ 11 Lambda表达式\nLambda 表达式 (C++11 起)\n\nC++ 阻止类被继承（继承类被实例化）的几种常用办法不时会留意到有人问起如何阻止 C++ 中的类被继承，但多数人都没有把这个问题问对。\n在 C++11 标准之前，阻止类被继承在语法上是做不到的，大家通常做到的只是继承而来的类不能被实例化了。这样一来，继承得到的类就完全没有用了。虽然最终的效果一致，但对问题的理解其实是有差异的。\n从 C++11 标准开始，C++ 引入了一个新的关键字 final，只有被 final 修饰的类才能真正做到不能被继承。\n下面举例实现常用的以达到“不能被继承&#x2F;继承类不能被实例化”的几种手段。\n私有化构造函数class Demo1&#123;public:    static Demo1* Create()    &#123;        return new Demo1;    &#125;private:    // 注意：私有掉构造函数    Demo1() &#123;&#125;    Demo1(const Demo1&amp;);    void operator=(const Demo1&amp;);&#125;;class Test1 : public Demo1&#123;&#125;;int main()&#123;//  Demo1*      pd1 = new Demo1;        // 错误：不能调用私有构造    Demo1*      pd1 = Demo1::Create();//  Test1*      pt1 = new Test1;        // 错误：不能调用基类私有构造&#125;\n\n使用 虚继承 + 私有基类构造函数template&lt;typename T&gt;class SealedT&#123;    // 注意：不是 friend class T;    friend T;private:    SealedT() &#123;&#125;&#125;;// 注意：是虚继承class Demo2 : virtual SealedT&lt;Demo2&gt;&#123;&#125;;int main()&#123;    Demo2*      pd2 = new Demo2;//  Test2*      pt2 = new Test2;        // 错误：不能访问间接虚基类&#125;  \n\n使用 虚继承 + 受保护的基类构造函数这个其实与前面一种形式是类似的。\nclass Sealed&#123;protected:    Sealed() &#123;&#125;&#125;;class Demo3 : virtual Sealed&#123;&#125;;class Test3 : public Demo3&#123;&#125;;int main()&#123;    Demo3*      pb3 = new Demo3;//  Test3*      pt3 = new Test3;        // 错误：不能访问间接虚基类&#125;   \n\n使用 final 关键字这个是最简单、最直接、最完美的。C++ 标准为啥如此晚才推出此功能。\nclass Demo4 final&#123;&#125;;// 不能从被 final 修饰的类继承，编译失败/*class Test4 : public Demo4&#123;&#125;;*/  \n\n参考\nPrevent class inheritance in C++\nVirtual inheritance\n\nVector初始化(1): vector ilist1;\n默认初始化，vector为空， size为0，表明容器中没有元素，而且 capacity 也返回 0，意味着还没有分配内存空间。这种初始化方式适用于元素个数未知，需要在程序中动态添加的情况。\n(2): vector ilist2(ilist);\nvector ilist2  &#x3D; ilist; \n两种方式等价 ，ilist2 初始化为ilist 的拷贝，ilist必须与ilist2 类型相同，也就是同为int的vector类型，ilist2将具有和ilist相同的容量和元素\n(3): vector ilist &#x3D; {1,2,3.0,4,5,6,7};\n vector ilist {1,2,3.0,4,5,6,7};\nilist 初始化为列表中元素的拷贝，列表中元素必须与ilist的元素类型相容，本例中必须是与整数类型相容的类型，整形会直接拷贝，其他类型会进行类型转换。\n(4): vector ilist3(ilist.begin()+2,ilist.end()-1);\nilist3初始化为两个迭代器指定范围中元素的拷贝，范围中的元素类型必须与ilist3 的元素类型相容，在本例中ilist3被初始化为{3,4,5,6}。注意：由于只要求范围中的元素类型与待初始化的容器的元素类型相容，因此迭代器来自不同的容器是可能的，例如，用一个double的list的范围来初始化ilist3是可行的。另外由于构造函数只是读取范围中的元素进行拷贝，因此使用普通迭代器还是const迭代器来指出范围并没有区别。这种初始化方法特别适合于获取一个序列的子序列。\n(5): vector ilist4(7);\n默认值初始化，ilist4中将包含7个元素，每个元素进行缺省的值初始化，对于int，也就是被赋值为0，因此ilist4被初始化为包含7个0。当程序运行初期元素大致数量可预知，而元素的值需要动态获取的时候，可采用这种初始化方式。\n(6):vector ilist5(7,3);\n指定值初始化，ilist5被初始化为包含7个值为3的int\n排序\nsort(vec.rbegin(), vec.rend());\n&#x2F;&#x2F;逆向排序 即按照从大到小的顺序进行排序   \n\nsort(vec.begin(), vec.end());\n&#x2F;&#x2F;正向排序 即按照从小到大的顺序排序\n\n\n合并​\tvector vec3;&#x2F;&#x2F;vec3是空的​    vec3.insert(vec3.end(),vec1.begin(),vec1.end())&#x2F;&#x2F;将vec1压入​    vec3.insert(vec3.end(),vec2.begin(),vec2.end())&#x2F;&#x2F;继续将vec2压入\n","slug":"cpp","date":"2023-07-23T16:00:00.000Z","categories_index":"编程语言","tags_index":"C++","author_index":"暗使开开"},{"id":"f02629f5f29a12c48d8e63a0dc01bd32","title":"flutter","content":"Dart基础在线练习网址 https://dartpad.dev/\n程序入口：main()&#123;&#125;控制台输出：print(&#x27;hello&#x27;);变量：var int检查null或零：1或非null对象都为true ??为null时设置默认值functions：fn()&#123;&#125;异步编程：async函数返回一个Future awit运算用于等待future_getIPAddress() async&#123;\tfinal url = &#x27;https://www.baidu.com/&#x27;; \tvar request = await HttpRequest.request(url);\tString ip = json.decode(request.responseText)[&#x27;origin&#x27;];\tprint(ip);&#125;\n\n\n\n声明式UI声明式UI要修改UI，Widget本身不可变，只能触发重构修改UI\nFlutter入门基础创建flutterflutter create &lt;projectname&gt;运行flutterflutter run -d &#x27;iPhone X&#x27;导入Widgetimport写一个Hello World//flutterimport &#x27;package:flutter/material.dart&#x27;;void main()&#123;\trunApp(\t\tCenter(\t\t\tchild: Text(\t\t\t\t&#x27;Hello, world!&#x27;,\t\t\t\ttextDirection: TextDirection.ltr,\t\t\t),\t\t),\t);&#125;使用Widget并将其嵌套以形成widget树//flutterimport &#x27;package:flutter/material.dart&#x27;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123;\t@override\tWidget build(BuildContext context)&#123;\treturn MaterialApp(\t\t\ttitle: &#x27;Werlcome to Flutter&#x27;,\t\t\thome: Scaffold(\t\t\t\tappBar: AppBar&#123;\t\t\t\t\ttitle:Text (&#x27;Welcome to Flutter&#x27;),\t\t\t\t&#125;,\t\t\t\tbody: Center(\t\t\t\t\tchild: Text(&#x27;Hello, world!&#x27;),\t\t\t\t),\t\t\t),\t\t);\t&#125;&#125;创建可重用Widget// Flutterclass CustomCard extends StatelessWidget &#123;\tCustomCard (&#123;@required this.index, @required\t\tthis.onPress&#125;);\t\t\tfinal index;\tfinal Function onPress;\t\t@override\tWidget build(BuildContext context) &#123;\t\treturn Card(\t\t\tchild: Column (\t\t\t\tchildren: &lt;Widget&gt;[\t\t\t\t\tText (&#x27;Card $index&#x27;), \t\t\t\t\tFlatButton (\t\t\t\t\t\tchild: const Text( &#x27;Press&#x27;), \t\t\t\t\t\tonPressed: this.onPress,\t\t\t\t\t),\t\t\t\t],\t\t\t)\t\t);\t｝｝// UsageCustomCard (\tindex: index,\tonPress: () &#123;\t\tprint( &#x27;Card $index&#x27;);\t&#125;,)\n\n\n\n\n\n\n\nAn error occurred while creating the AVD. See idea.log for details问题File-&gt;Settings-&gt;Android SDK-&gt;SDK Tools安装Android Emulator\n","slug":"flutter","date":"2023-07-13T16:00:00.000Z","categories_index":"开发经验","tags_index":"","author_index":"暗使开开"},{"id":"8ce8bc13895147db2d25a36c61abcc58","title":"centos升级git","content":"centos升级git卸载原有的gitrpm -e --nodeps git\n\nyum remove git    采用yum删除git，同时也将删除其依赖包\n安装相关依赖yum install -y curl-devel expat-devel openssl-devel zlib-devel asciidocyum install -y gcc perl-ExtUtils-MakeMaker\n\n下载解压wget https://github.com/git/git/archive/v2.27.0.tar.gz -O git.tar.gztar -C /usr/local/src -zxvf git.tar.gzcd /usr/local/src/git-2.27.0\n\n\n\n编译并设置安装路径vi Makefileprefix = /usr/local/bin/gitmake allmake install\n\n添加环境变量echo &quot;export PATH=$PATH:/usr/local/bin/git/bin&quot; &gt;&gt; /etc/profile &amp;&amp; source /etc/profilegit --version","slug":"centos升级git","date":"2023-04-15T16:00:00.000Z","categories_index":"","tags_index":"CentOS","author_index":"暗使开开"},{"id":"fe4ea5ff50282301f0085214fc01e7b3","title":"总线控制","content":"总线控制一、总线判优控制1. 基本概念\n主设备(模块) 可以提出总线占用请求，控制和其他设备之间的通信过程 对总线有 控制权（有些总线可以由多个主设备）\n从设备(模块) 响应 从主设备发来的总线命令\n总线判优控制：集中式(总线控制部件集中在一起)，分布式\n集中式：链式查询，计数器定时查询，独立请求方式\n分布式\n\n\n\n2. 链式查询方式\n数据总线：用于信息交换过程中数据传输\n地址总线：主设备占用总线之后，和从设备进行数据传输通过地址总线找到从设备\nBR：所有设备都通过BR发起总线占用请求\nBS：如果有设备占用总线，就通过BS告诉其他设备总线忙\nBG：总线授权线，一个一个向下查询（链式查询）\n\nI&#x2F;O接口（外设）有占用请求时，通过BR给总线控制部件发送占用请求\n总线控制部件接受到请求以后且可以让出总线的控制权（BS总线不忙）时，通过BG总线授权信号逐个进行查询是哪个I&#x2F;O接口（设备）发出的请求\n总线授权信号碰到第一个提出总线占用请求的接口，则它就获得了总线的使用权，并且通过BS设置总线忙\n\n链式查询\n缺点：优先级事先已经确定的，优先级太低的可能一直得不到总线授权。对电路故障特别敏感，如果BG上的某接口出现电路故障，信号不会往下传，后面的设备永远无法获得使用权，速度慢\n优点：结构简单，优先级算法简单，增删设备简单，进行可靠性设计时容易实现\n一般运用在微型计算机，简单的嵌入式系统中\n3. 计数器定时查询方式\nBG线变成了设备地址线（宽度和设备地址有关）\n\nI&#x2F;O接口（外设）有占用请求时，通过BR给总线控制部件发送占用请求\n总线控制部件接受到请求以后且可以让出总线的控制权（BS总线不忙）时，启动总线控制部件中的计数器，计数器的值通过设备地址这条线向外输出查询接口\n计数器根据计数器的值访问对应I&#x2F;O接口，如果不是就加一，继续访问，直到碰到第一个提出总线占用请求的接口，则它就获得了总线的使用权，并且通过BS设置总线忙\n\n缺点：比链式查询需要的线多，log2n向上取整+2条线，速度慢\n优点：优先级确定非常灵活，如：每次从0或K开始一直到n，则0或k接口优先级最高，如：每次从上一次数值开始变成循环优先级等等。\n4. 独立请求方式\n每个接口都有自己的BR，BG线\n优先级由总线控制部件内部的排队器决定\n\nI&#x2F;O接口（外设）有占用请求时，通过自己的BR给总线控制部件发送占用请求\n总线控制部件接受到请求以后且可以让出总线的控制权（BS总线不忙）时，经过排队其排队以后，对某一个（根据优先级）提出总线控制请求的设备进行总线授权\n获得总线控制部件应答的设备，就占用了总线的使用权\n\n优点：优先级确定非常灵活，自定义排队器\n缺点：需要的线多2n条线\n二、总线通信控制1. 目的： 解决通信双方协调配合问题2. 总线传输周期\n申请分配阶段： 主模块申请，总线仲裁决定（总线判优逻辑：上面所解决的问题）\n寻址阶段： 主模块（向从模块）给出地址（找到从设备） 和 命令（控制从设备完成相应的操作）\n传数阶段： 主模块和从模块交换数据\n结束阶段： 主模块和从模块都撤消有关信息\n\n3. 总线通信的四种方式\n同步通信：由统一时标控制数据传送 应用在总线长度比较短且各个模块存取时间比较一致的情况下\n异步通信：采用应答方式 ，没有公共时钟标准\n半同步通信： 同步、异步结合\n分离式通信： 充分挖掘系统总线每个瞬间的潜力\n\n\n同步通信：由统一时标控制数据传送(主从模块是强制同步的，速度不同模块需要选择速度最慢的模块作为统一的时标)CPU用同步通信的方式从外部设备进行数据输入\n同步通讯有定宽定距的时标来控制整个数据的传输过程\n时钟信号：总线传输周期由四个时钟周期构成，这四个时钟周期就可以完成一次完整可靠的数据通信\nCPU完成数据输入需要地址信号，读信号，从设备在给定的时间点上给出数据的输出，对CPU来说时数据的输入\n在固定的时间点上要给出固定的操作：\n\nT1时钟周期的上升沿CPU（主设备）必须给出地址信号，\nT2时钟周期的上升沿必须给出读命令信号告诉从设备CPU（主设备）要从从模块读入数据\nT3时钟周期的上升沿到达之前从设备必须通过数据总线给出数据信号\nT4时钟周期的上升沿数据信号和读信号（控制信号）可以撤销，T4结束时地址信号也撤销\n\n\nCPU用同步通信的方式把数据输出到外部设备\n同步通讯有定宽定距的时标来控制整个数据的传输过程\n时钟信号：总线传输周期由四个时钟周期构成，这四个时钟周期就可以完成一次完整可靠的数据通信\nCPU完成数据输入需要地址信号，写信号\n在固定的时间点上要给出固定的操作：\n\nT1时钟周期的上升沿CPU（主设备）必须给出地址信号，\nT1时钟周期的下降沿给出数据\nT2时钟周期的上升沿必须给出写命令信号 向从设备进行数据写入\nT4时钟周期的上升沿数据信号和写信号（控制信号）可以撤销，T4结束时地址信号也撤销\n\n\n异步通信： 采用应答方式，没有公共时钟标准主设备发起请求，从设备受主设备控制，不用定宽定距的时钟\n\n\n异步通信不互锁方式（通信没有可靠性）：主设备发起通信请求，从设备接受到主设备请求发出应答信号，主设备撤销请求信号，从设备撤销应答信号，主设备不管有没有收到应答信号，一定延时后都会撤销请求信号，从设备不管主设备有没有接到应答信号，一定延时后都会撤销应答信号\n异步通信半互锁方式（可能造成主设备请求信号一直保持高电平）：主设备发起通信请求，从设备接受到主设备请求发出应答信号，主设备接收到应答信号以后撤销请求信号，如果接收不到，请求信号会保持，从设备不管主设备有没有接到应答信号，一定延时后都会撤销应答信号\n异步通信全互锁方式（通过握手信号完成可靠的数据传输通信联络）：主设备发起通信请求，从设备接受到主设备请求发出应答信号，主设备接收到应答信号以后撤销请求信号，如果接收不到，请求信号会保持，只有主设备的请求信号撤销以后，从设备才会撤销自己的应答信号\n\n半同步通信： 同步、异步结合\n同步： 发送方 用系统 时钟前沿 发信号\n接收方 用系统 时钟后沿 判断、识别\n\n异步 允许不同速度的模块和谐工作 增加一条 “等待”响应信号 WAIT\n\n\n以输入数据为例的半同步通信时序（主模块熟读快，等从模块回应）\nT1 主模块发地址\nT2 主模块发命令\nTw 当 WAIT为低电平时，等待一个 T\nTw 当 WAIT为低电平时，等待一个 T\n…\nT3 从模块提供数据\nT4 从模块撤销数据，主模块撤销命令\n\nT1时钟周期的上升沿CPU（主设备）必须给出地址信号，\nT2时钟周期的上升沿必须给出读命令信号告诉从设备CPU（主设备）要从从模块读入数据\nT3时钟周期开始之前，从设备如果不能把数据准备好，通过WAIT信号给出低电平，告诉主设备进行等待，CPU会在第三个时钟周期到来之前插入一个时钟周期Tw（循环往复）\n数据已经准备好放在数据总线上，WAIT变成高电平时，则该Tw结束后开始T3周期\nT4时钟周期的上升沿数据信号和读信号（控制信号）可以撤销，T4结束时地址信号也撤销\n\n\n上述三种通信的共同点一个总线传输周期（以输入数据为例）\n\n主模块发地址 、命令： 占用总线\n从模块准备数据： 不占用总线 总线空闲\n从模块向主模块发数据： 占用总线\n\n总线有空闲\n分离式通信 充分挖掘系统总线每个瞬间的潜力一个总线传输周期，子周期1和2之间用来让从模块准备数据，子周期2中从模块已经变成了主模块\n\n读数据时，准备数据 硬盘有三步操作：\n主模块向从模块发出找指定磁道请求后，放弃总线使用权\n\n定位：磁头镜像移动，寻找指定磁道（时间长）\n\n硬盘找到指定磁道变成主模块，发出找对应扇区的请求后，放弃总线使用权\n\n找到指定扇区：磁头停止在磁盘表面不动，磁盘围绕轴转动（时间长）\n\n硬盘找到指定扇区变成主模块，发出读请求，进行数据传输\n\n读数据\n\n\n分离式通信特点（充分提高了总线的有效占用）\n\n\n各模块有权申请占用总线\n采用同步方式通信，不等对方回答\n各模块准备数据时，不占用总线\n总线被占用时，无空闲\n\n","slug":"总线控制","date":"2022-08-29T15:02:22.000Z","categories_index":"","tags_index":"","author_index":"暗使开开"},{"id":"ba68949a58e3c0521996a1c671405388","title":"总线的基本概念","content":"总线的基本概念一、为什么要用总线把各个部件连接起来，方便维护管理各部件\n二、什么是总线总线是连接各个部件的信息传输线，是各个部件共享的传输介质\n三、总线上信息的传送串行——-\n并行&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n四、总线结构的计算机举例\n单总线结构框图\n\n\n面向 CPU 的双总线结构框图\n\n\n以存储器为中心的双总线结构框图\n\n\n\n","slug":"总线的基本概念","date":"2022-08-29T15:02:22.000Z","categories_index":"","tags_index":"","author_index":"暗使开开"},{"id":"88e51c25651f7ab23251517d494ade0d","title":"总线特性及性能指标","content":"总线特性及性能指标一、总线物理实现\n总线印刷在主板（印刷电路板）上 ，在总线上留出接口给模块插板用来连接\n二、总线特性\n机械特性 尺寸、形状、管脚数 及 排列顺序\n电气特性 传输方向 和有效的 电平 范围\n功能特性 每根传输线的 功能：地址，数据，控制\n时间特性 信号的 时序 关系\n\n三、总线的性能指标\n总线宽度 数据线 的根数\n标准传输率 每秒传输的最大字节数（MBps）\n时钟同步&#x2F;异步 同步、不同步\n总线复用 地址线 与 数据线 复用\n信号线数 地址线、数据线和控制线的 总和\n总线控制方式 突发、自动、仲裁、逻辑、计数\n其他指标 负载能力\n\n四、总线标准\n\n带宽（28）&#x3D;数据线（16根就是2字节Byte）总线时钟（8MHz）\nISA：工业标准体系结构\nEISA：兼容ISA\nVESA（VL-BUS）：视频电子标准协会 大部分信号来自CPU 驱动能力差\nPCI：外设部件互联标准 独立于处理器的结构 形成特殊的中间缓冲器式的设计，把中央处理器子系统和外设分开，用户可以随意添加外设，不用担心在不同的时钟频率下导致计算机性能的下降\nAGP：Inter推出的接口，点对点的局部总线 为了连接控制芯片和显卡\nRS-232：串行通信 总线标准\nUSB：串行接口 总线标准\n","slug":"总线特性及性能指标","date":"2022-08-29T15:02:22.000Z","categories_index":"","tags_index":"","author_index":"暗使开开"},{"id":"67a07993746681dd1e13888391663bfc","title":"总线的分类","content":"总线的分类1.片内总线芯片内部 的总线\n2.系统总线计算机各部件之间 的信息传输线\n数据总线 双向 与机器字长、存储字长有关地址总线 单向 与存储地址、 I&#x2F;O地址有关控制总线 有出（中断请求、总线请求） 有入（存储器读、存储器写 总线允许、中断确认）\n3.通信总线用于 计算机系统之间 或 计算机系统与其他系统（如控制仪表、移动通信等）之间的通信\n传输方式：串行通信总线 并行通信总线\n","slug":"总线的分类","date":"2022-08-29T15:02:22.000Z","categories_index":"","tags_index":"","author_index":"暗使开开"},{"id":"01d906b6031118ca7dc7178db4a7223b","title":"总线结构","content":"总线结构一、单总线结构\n把所有设备连接到一条总线上，导致总线成为系统瓶颈，采用多总线结构\n二、多总线结构1. 双总线结构\n存储总线和I&#x2F;O总线分离，通过通道连接，通道有自己的控制器，指令系统等等，通道通常由操作系统来编写的\n2.三总线结构\nDMA总线：直接存储器访问，高速外设直接访问内存，低速还要走I&#x2F;O总线\n3. 三总线结构的又一形式\nCPU更新快，内存速度迭代慢，在CPU和内存之间增加了一个小容量高速度的Cache，对主存中的数据进行缓存，CPU运行需要的指令和数据主要从Cache中获取，局部总线把CPU和Cache连接起来，局部I&#x2F;O控制器连接高速I&#x2F;O设备，系统总线通过扩展总线接口连接扩展总线，各种设备都连接到了扩展总线上，解决了I&#x2F;O设备的扩展问题。但是多种类型的设备连接到扩展总线，影响外设的工作速度\n4. 四总线结构\n局部总线连接CPU和Cache&#x2F;桥，系统总线连接主存和Cache&#x2F;桥，桥电路扩展出了一个高速总线，用来连接高速外设，低速设备可以连接到扩展总线上，扩展总线通过接口连接高速总线，把高速和低速分开组织，提高数据传输速率\n三、总线结构举例1. 传统微型机总线结构\n2. VL-BUS局部总线结构\nVL-BUS高速低速分开\n3. PCI 总线结构\nPCI高速低速分开\n4. 多层 PCI 总线结构\n如果PCI总线连接的设备太多，总线驱动能力不够，可以通过PCI桥进行扩展\nCPU和存储器通过存储器总线连接，下面是桥电路，通过桥电路实现驱动能力的提高\n","slug":"总线结构","date":"2022-08-29T15:02:22.000Z","categories_index":"","tags_index":"","author_index":"暗使开开"},{"id":"8dc7cd46376ad8466899f7367562bde2","title":"计算机的展望","content":"计算机的展望一、计算机具有类似人脑的一些超级智能功能\n要求计算机的速度要足够快\n二、芯片集成度的提高受以下三方面的限制\n\n芯片集成度受物理极限的制约\n按几何级数递增的制作成本\n芯片的功耗、散热、线延迟\n\n三、替代传统的硅芯片\n\n光计算机\n利用光子取代电子进行运算和存储\n\nDNA生物计算机\n通过控制DNA分子间的生化反应\n\n量子计算机\n利用原子所具有的量子特性\n\n\n","slug":"计算机的展望","date":"2022-08-29T15:02:22.000Z","categories_index":"","tags_index":"计组","author_index":"暗使开开"},{"id":"13d39ce5494ddd5022f4722dceb80b96","title":"计算在世界上的天数","content":"计算在世界上的天数#include &lt;stdio.h&gt;int main()&#123;        int year1,year2,month1,month2,day1,day2;        int a[13]= &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;        printf(&quot;birthday:2001 02 06:&quot;);        scanf(&quot;%d %d %d&quot;,&amp;year1,&amp;month1,&amp;day1);        printf(&quot;now:2022 05 16:&quot;);        scanf(&quot;%d %d %d&quot;,&amp;year2,&amp;month2,&amp;day2);        int num=0,i,j,k;        if((year2-year1)&gt;1)        &#123;                for(i=year1+1;i&lt;=year2-1;i++)                &#123;                        if(i%4==0&amp;&amp;i%100!=0||i%400==0)                        &#123;                                num=num+366;                        &#125;                        else num=num+365;                &#125;        &#125;        if(year1%4==0&amp;&amp;year1%100!=0||year1%400==0) a[2]=29;        if(year1==year2)        &#123;                for(i=month1+1;i&lt;month2;i++)                &#123;                        num=num+a[i];                &#125;                num=num+(a[month1]-day1)+day2;        &#125;        a[2]=28;        if(year1!=year2)        &#123;                if(year1%4==0&amp;&amp;year1%100!=0||year1%400==0) a[2]=29;                for(i=month1+1;i&lt;=12;i++)                &#123;                        num+=a[i];                &#125;\t\t\t\tnum+=(a[month1]-day1);                a[2]=28;                if(year2%4==0&amp;&amp;year1%100!=0||year2%400==0) a[2]=29;                for(i=month2-1;i&gt;=1;i--)                &#123;                num+=a[i];                &#125;                num+=day2;        &#125;        printf(&quot;You have lived %d days.\\n&quot;,num);        return 0;&#125;","slug":"计算在世界上的天数","date":"2022-08-29T15:02:22.000Z","categories_index":"","tags_index":"计组","author_index":"暗使开开"},{"id":"57fbb8bedac43540c8f51c0ee11adbc5","title":"计算机硬件的主要技术指标","content":"计算机硬件的主要技术指标\n1.机器字长CPU 一次能处理数据的位数 与 CPU 中的 寄存器位数 有关（相等）\n\n2.运算速度主频\n核数，每个核支持的线程数\n吉普森法\nCPI 执行一条指令所需时钟周期数\nIPC 一个时钟周期数能执行多少条指令\nMIPS 每秒执行百万条指令\nFLOPS 每秒浮点运算次数\n\n3.存储容量存放二进制信息的总位数\n\n主存容量\n\n存储单元个数 × 存储字长\n\n\n\nMAR\nMDR\n容量\n\n\n\n10位\n8位\n1 K*8位（1 K&#x3D;210）\n\n\n16位\n32位\n64 K*32位\n\n\n\n字节数\n213 b&#x3D; 1 KB(1 B &#x3D; 23 b)\n221 b&#x3D; 256 KB\n\n\n\n辅存容量\n字节数 80 GB（1GB &#x3D; 230B）\n\n\n\n\n","slug":"计算机硬件的主要技术指标","date":"2022-08-29T15:02:22.000Z","categories_index":"","tags_index":"计组","author_index":"暗使开开"},{"id":"0c48a428566e19d732a05162b62e7687","title":"计算机的基本组成","content":"计算机的基本组成现在的计算机都是存储程序结构的计算机\n一、冯·诺依曼计算机（以运算器为中心）的特点\n\n计算机由五大部件组成（输入设备，运算器，控制器，存储器，输出设备）\n指令和数据以同等地位存于存储器，可按地址寻访\n指令和数据用二进制表示\n指令由操作码和地址码组成\n存储程序\n以运算器为中心\n\n二、计算机硬件框图1.计算机硬件框图（以存储器为中心）\n2.现代计算机硬件框图\nCPU：ALU（运算器），CU（控制器）\n存储器：主存，副存\n主机：CPU，存储器\nI&#x2F;O设备：输入设备，输出设备\n硬件：主机系统，I&#x2F;O设备\n系统复杂性管理的方法-2（3’Y）\n层次化（Hierachy）：将被设计的系统划分为多个模块或子模块\n模块化（Modularity）：有明确定义（well-defined）的功能和接口\n规则性（regularity）：模块更容易被重用\n\n三、计算机的工作步骤一个现实中的问题，如何用计算机来解决？\n1. 上机前的准备\n建立数学模型\n编制解题程序\n确定计算方法程序 —— 运算的 全部步骤指令 —— 每 一个步骤\n编程举例：计算 ax2 + bx + c&#x3D; (ax + b)x + c\n\n\n取x 至运算器中\n乘以x 在运算器中\n乘以a 在运算器中\n存ax2 在存储器中\n取b 至运算器中\n乘以x 在运算器中\n加ax2 在运算器中\n加c 在运算器中\n\n或者\n\n取x 至运算器中\n乘以a 在运算器中\n加b 在运算器中\n乘以x 在运算器中\n加c 在运算器中\n\n\n指令格式举例：操作码|地址码\n\n\n\n\n指令和数据存于主存单元的地址\n操作码\n地址码\n步骤\n注释\n\n\n\n0\n000001(取数)\n0000001000（α）\n[α] -&gt;ACC\n取数x至ACC\n\n\n1\n000100(存数)\n0000001001(β)\n[ACC] -&gt; β\n乘a得ax ,存于ACC中\n\n\n2\n000011(加)\n0000001010(γ)\n[ACC]+[γ] -&gt; ACC\n加b得ax+b ,存于ACC中\n\n\n3\n000100(乘)\n0000001000(δ)\n[ACC]×[δ] -&gt; ACC\n乘x得（ax+b)x,存于ACC中\n\n\n4\n000011\n0000001011\n\n加c得ax2 + bx + c ,存于ACC\n\n\n5\n000010\n0000001100\n\n将ax2 + bx +c ,存于主存单元\n\n\n6\n000011(打印)\n0000001011(o)\n[ o ] -&gt; 打印机\n打印\n\n\n7\n000110\n\n\n停机\n\n\n8\nx\n\n\n原始数据x\n\n\n9\na\n\n\n原始数据a\n\n\n10\nb\n\n\n原始数据b\n\n\n11\nc\n\n\n原始数据c\n\n\n12\n\n\n\n存放结果\n\n\n指令和数据都是保存在存储器中的\n2.计算机的解题过程1. 存储器的基本组成\n存储器：存储体，MAR，MDR\n\n存储体 -存储单元 -存储元件（0&#x2F;1）\n大楼 -房间 -床位（无人&#x2F;有人）\n\n\n\n\n存储单元\n存放一串二进制代码\n\n\n\n存储字\n存储单元中二进制代码的组合\n\n\n存储字长\n存储单元中二进制代码的位数\n\n\n按地址寻访\n每个存储单元赋予一个地址号\n\n\nMAR：存储器地址寄存器，反映存储单元（房间）的个数\nMDR：存储器数据寄存器，反映存储字长\n例如：MAR &#x3D; 4 位 -&gt; 存储单元个数 16MDR &#x3D; 8 位 -&gt; 存储字长 8\n2. 运算器的基本组成及操作过程\n运算器：X-&gt;ALU&lt;&#x3D;&gt;ACC&lt;&#x3D;&gt;MQ\n\n\n\n\nACC\nMQ\nX\n\n\n\n加法\n被加数和\n\n加数\n\n\n减法\n被减数差\n\n减数\n\n\n乘法\n乘积高位\n乘数乘积低位\n被乘法\n\n\n除法\n被除数余数\n商\n除法\n\n\nALU：算咯运算单元\n① 加法操作过程\n\n\n\n\n指令\n加\nM\n\n\n\n初态ACC被加数\n\n[M] -&gt; X 把M中的值给X\n\n\n得到\n[ACC]+[X] -&gt; ACC 运算结果给ACC\n\n\n\n② 减法操作过程\n\n\n\n\n指令\n减\nM\n\n\n\n初态ACC被减数\n\n[M] -&gt; X 把M中的值给X\n\n\n得到\n[ACC]-[X] -&gt; ACC 运算结果给ACC\n\n\n\n③ 乘法操作过程\n\n\n\n\n指令\n乘\nM\n\n\n\n初态ACC被乘数\n\n[M] -&gt; MQ\n\n\n[ACC] -&gt; X把ACC的内容送到X\n0 -&gt; ACC把ACC清零\n\n\n\n得到\n[X]*[MQ] -&gt; ACC&#x2F;MQ\n\n\n\n④ 除法操作过程\n\n\n\n\n指令\n除\nM\n\n\n\n初态ACC被除数\n\n[M] -&gt; X\n\n\n得到\n[ACC]&#x2F;[X] -&gt; MQ\n\n\n\n余数在ACC中\n3.控制器的基本组成\n\n控制器：CU，IR，PC\n\nCU：控制单元\nPC: 存放当前欲执行指令的地址， 具有计数功能（PC）+ 1 -&gt; PC\nIR: 存放当前欲执行的指令\n\n\n完成一条指令：取指令PC -&gt; 分析指令IR -&gt; 执行指令CU\n运算器、控制器、存储器构成了什么主机\n一条指令在主机上的完成过程\n程序在主机上是如何执行的\n\n4.主机完成一条指令的过程以取数指令为例\n\nPC把需要的指令的地址送给MAR（控制器上的PC中存放着要执行的指令的地址，指令保存在存储体当中）\nMAR把地址送给存储体（在控制器的控制下，存储体把指定存储单元当中保存的取数指令取出来，送入MDR中）\n存储体把指定存储单元当中保存的取数指令取出来，给MDR中（MDR中现在就有了指令）\nMDR把取出来的指令送给IR（IR存放当前欲执行的指令和当前指令操作数的地址）\n分析指令 IR送给CU\n从IR的地址码部分取出操作数地址送给MAR（CU控制IR把操作数地址送给MAR）\nMAR把地址给存储体（在控制器的控制下，存储体把指定存储单元当中保存的取数指令要去的数取出来，）\n存储体把找到的数据给MDR\nMDR送给运算器中的ACC\n\n以存数指令为例\n\nPC把需要的指令的地址送给MAR（控制器上的PC中存放着要执行的指令的地址，指令保存在存储体当中）\nMAR把地址送给存储体（在控制器的控制下，存储体把指定存储单元当中保存的存数指令取出来，送入MDR中）\n存储体把指定存储单元当中保存的存数指令取出来，给MDR中（MDR中现在就有了指令）\nMDR把取出来的指令送给IR（IR存放当前欲执行的指令和当前指令操作数的地址）\n分析指令 IR送给CU\n从IR的地址码部分取出操作数地址送给MAR（CU控制IR把操作数地址送给MAR）\nMAR把地址给存储体（在控制器CU的控制下，MAR把地址给存储体，告诉存储体现在有一个数据要存进来，对应的地址是多少）\n运算器中ACC中的内容取出来送给MDR（CU控制）\nMDR把得到的数据保存到存储体（在CU控制的控制之下把MDR中的数据保存的存储体对应的地址中）\n\nax2 + bx + c 程序的运行过程\n将程序通过输入设备送至计算机\n\n程序首地址 -&gt; PC\n\n启动程序运行\n\n取指令 PC -&gt; MAR -&gt; M(存储体) -&gt; MDR -&gt; IR ,(PC)+1 -&gt; PC\n\n分析指令 OP(IR)(指令的操作码部分) -&gt; CU\n\n执行指令 Ad(IR)(指令的操作数部分) -&gt; MAR -&gt; M -&gt; MDR -&gt; ACC\n…\n\n打印结果\n\n停机\n\n\n","slug":"计算机的基本组成","date":"2022-08-29T15:02:22.000Z","categories_index":"","tags_index":"计组","author_index":"暗使开开"},{"id":"ef19fa8a649369ddae37d49f372def59","title":"计算机的应用","content":"计算机的应用一、科学计算和数据处理\n二、工业控制和实时控制\n三、网络技术\n\n电子商务\n网络教育\n敏捷制造\n\n四、虚拟现实\n五、办公自动化和管理信息系统\n六、CAD&#x2F;CAM&#x2F;CIMS\n七、多媒体技术\n八、人工智能\n","slug":"计算机的应用","date":"2022-08-29T15:02:22.000Z","categories_index":"","tags_index":"计组","author_index":"暗使开开"},{"id":"ee6ffbefdb1e53ca7036ca0db67b41e3","title":"计算机系统简介","content":"计算机系统简介物联网把感应器嵌入和装备到电网、铁路、桥梁、隧道、公路、建筑、供水系统、大坝、油气管道等各种物体中，并且被普遍连接，形成所谓“物联网”\n一.计算机系统硬件：计算机的实体，如主机，外设等\n软件：由具有各类特殊功能的信息（程序）组成\n软件系统软件：用来管理整个计算机系统\n\n语言处理程序\n操作系统\n服务性程序\n数据库管理系统\n网络软件\n\n应用软件：按任务需要编制成的各种程序\n二.计算机系统的层次结构系统复杂性管理的方法-1\n抽象抽象-对于一个过程或者一件制品的某些细节有目的的隐藏，以便把其他方面、细节或者结构表达得更加清楚—-百度百科抽象-指高级的模型，和低级的实体相对—–维基百科抽象-隐藏系统中不重要的细节。—–David Harris\n\n从物理构成的角度把计算机系统抽象成九层 依据是每一层计算机典型的构建模块\n\n\n\nApplication Software\nprograms\n\n\n\nOperating Systems\nadders memories\n\n\nArchitecture\ndevice drivers\n\n\nMicroarchitecture\ninstructions registers\n\n\nLogic\ndatapaths controllers\n\n\nDigital Circuits\nand gate not gate\n\n\nAnalog Circuits\namplifiers filters\n\n\nDevices\ntransistors diodes\n\n\nPhysics\nelectros\n\n\n\n从程序员的角度，把计算机系统抽象成五层\n\n\n\n高级语言\n虚拟机器M4（软件）\n用编译程序翻译成汇编语言程序\n\n\n\n汇编语言\n虚拟机器M3（软件）\n用汇编程序翻译成机器语言程序\n\n\n操作系统\n虚拟机器M2（软件）\n用机器语言解释操作系统\n\n\n机器语言\n实际机器M1（硬件）\n用微指令解释机器指令\n\n\n微指令系统\n微程序机器M0（硬件）\n由硬件直接执行微指令\n\n\n\n\n计算机系统（体系）结构：（例如：定义有无乘法指令）\n\n程序员（机器语言程序员）所见到的计算机系统的属性（指令集及其能够对哪些类型的数据进行操作，寄存器文件的组织，内存的编址单位） 概念性的结构与功能特性（指令系统、数据类型、寻址技术、I&#x2F;O机理）\n定义了计算机系统软硬件的交界面，定义了哪些功能由软件来实现，哪些功能由硬件来实现，提供了上层软件进行编写的时候和硬件进行交互的接口\n\n计算机组成：（例如：如何实现乘法指令）\n\n实现计算机体系结构所体现的属性（具体指令的实现）\n\n","slug":"计算机系统简介","date":"2022-08-29T15:02:22.000Z","categories_index":"","tags_index":"计组","author_index":"暗使开开"},{"id":"862ecabae65544f00e4a4f42f663a791","title":"Hexo","content":"Hexo 基本操作\nhexo cl\nhexo new post markdown_name\nhexo g\nhexo d\nhexo s\n\n上传日志到云服务器 or GitHub\nhexo clean\nhexo g -d\n\n安装配置Hexo环境配置nvm安装\nhttps://github.com/coreybutler/nvm-windows/releases\n下载后安装 安装完毕后，找到安装的路径，一些简单配置，打开setting.txt增加镜像源提高下载速度\n\nnode_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/\n\n\nnvm version 检验是否安装成功\n\nNode安装\nnvm install 18\nnvm list\nnvm use 18 (进入安装目录，用管理员运行cmd)\nnode -v\n\n安装hexonpm install hexo-cli -g\n\n生成SSH Keysssh-keygen -t rsa -C &quot;eviwbh@163.com&quot;\n\n\n\n创建Hexocd 目录hexo init blog(文件名)cd bloghexo shexo n &quot;markdown_name&quot; == hexo new post markdown_name\n\n上线博客github账户里配置好之前生成的id_rsa.pub\n_config.yml中修改deploydeploy:  type: git  repository: https://github.com/Eviwbh/eviwbh.github.io.git  branch: main\n\n云服务器登录云服务器普通用户账号\nsu [username]mkdir .sshvim .ssh/authorized_keys粘贴之前生成的id_rsa.pubexitmkdir 网站存放路径chown -R [username]:[username] 网站存放路径su [username]git init --bare blog.gitvi 网站存放路径/blog.git/hooks/post-receive#!/bin/bashgit --work-tree=网站存放路径 --git-dir=网站存放路径/blog.git checkout -fchmod +x 网站存放路径/blog.git/hooks/post-receive\n\n\n\ndeploy:  type: git  repository: git@ip:网站存放路径/blog.git  branch: master\n\n\n\n自动部署工具npm install hexo-deployer-git --save\n\n\n\nHexo维护hexo其他电脑上写博客原设备在github上创建分支并设置为默认分支\n把新的分支拉下来，删除除了.git 文件夹之外的所有文件\ngit clone ...\n\n把之前源码(除了.deploy_git文件夹)都克隆到这个新生成的文件夹中\ngit add .git commit –m &quot;新大陆&quot;git push\n\n之后就正常更新文章\n新设备生成ssh key添加到GitHub账户上\nssh-keygen -t rsa -C &quot;email&quot;\n\n把仓库的源码拉下来\ngit clone ...\n\n安装好环境\nnpm install hexo-cli -gnpm instal\n\n之后正常使用\nhexo clean hexo ghexo d hexo s\n\n\n\n多个服务器部署deploy:  - type: git    repository: https://github.com/Eviwbh/eviwbh.github.io.git    branch: main  - type: git    repository: git@ip:网站存放路径/blog.git    branch: master\n\n\n\n\n\nHexo去除代码块行号在配置文件_config.yml中，找到highlight，并将line_number：true改为false。\n疑难杂症Hexo报错hexo : 无法加载文件hexo.ps1，原因：因为在此系统上禁止运行脚本\n解决方法设置-&gt;隐私和安全性-&gt;开发者选项-&gt;允许本地PowerShell脚本在为签名的情况下运行git-receive-pack: command not found原因：远程服务器上的git安装路径是&#x2F;usr&#x2F;local&#x2F;bin&#x2F;git，不是默认路径\n解决方法建立链接文件：ln -s /usr/local/bin/git/bin/git-receive-pack /usr/bin/git-receive-pack\n\n\n\n\n\nThe authenticity of host ‘IP’ can’t be established:ssh原因：在于每次远程登录Linux的时候，Linux都要检查一下，当前访问的计算机公钥是不是在~&#x2F;.ssh&#x2F;know_hosts中，这个文件时OpenSSH记录的。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告，避免你受到DNS Hijack之类的攻击。SSH对主机的public_key的检查等级是根据StrictHostKeyChecking变量来配置的。默认情况下，StrictHostKeyChecking&#x3D;ask。简单所下它的三种配置值：1.StrictHostKeyChecking&#x3D;no最不安全的级别，当然也没有那么多烦人的提示了，相对安全的内网测试时建议使用。如果连接server的key在本地不存在，那么就自动添加到文件中（默认是known_hosts），并且给出一个警告。2.StrictHostKeyChecking&#x3D;ask #默认的级别，就是出现刚才的提示了。如果连接和key不匹配，给出提示，并拒绝登录。3.StrictHostKeyChecking&#x3D;yes #最安全的级别，如果连接与key不匹配，就拒绝连接，不会提示详细信息。\n解决方法修改云服务器&#x2F;etc&#x2F;ssh&#x2F;ssh_configStrictHostKeyChecking no\n\n","slug":"hexo","date":"2022-08-29T15:02:22.000Z","categories_index":"开发经验","tags_index":"","author_index":"暗使开开"},{"id":"f18e335be203daef5375edd1ee27ca4d","title":"计算机的发展史","content":"计算机的发展史一、计算机的产生和发展世界上第一台电子计算机 ENIAC(1946)\n1946年 美国 ENIAC 1955年退役十进制运算18 000 多个电子管1 500 多个继电器150 千瓦30 吨1 500 平方英尺5 000 次加法／秒用手工搬动开关和拔插电缆来编程\n现代计算机产生的驱动力\n需求、需求、还是需求\n技术发展\n电子技术的发展\n计算机体系结构技术的发展\n\n\n\n硬件技术对计算机更新换代的影响\n\n\n代\n时间\n硬件技术\n速度（次&#x2F;秒）\n\n\n\n一\n1946－1957\n电子管\n40 000\n\n\n二\n1958－1964\n晶体管\n200 000\n\n\n三\n1965－1971\n中小规模集成电路\n1 000 000\n\n\n四\n1972－1977\n大规模集成电路\n10 000 000\n\n\n五\n1978－现在\n超大规模集成电路\n100 000 000\n\n\nIAS的逻辑结构以运算器为中心的冯诺依曼计算机结构\n\n\n\n\n\n\n\n\n\n\n\n\nMain Memory\n&lt;&#x3D;&gt;\nArithmetic Logic Unit\n&lt;&#x3D;&gt;\nI&#x2F;O Equipment\n\n\n\n\n||\n\n\n\n\n\n&lt;&#x3D;&gt;\nProgram Control Unit\n\n\n\n\nIBM System &#x2F; 360系列产品 大中小型360\n二、微型计算机的出现和发展微处理器：用一片大规模的集成电路，组成的处理器，集成了运算器和控制器\n微型计算机：使用微处理器、集成度相当高、大规模集成电路，面向个人用户体积小、重量轻、价格低的计算机\n\n\n\n微处理器芯片（Intel）\n1971年\n存储器芯片\n1970\n\n\n\n4位（4004）\n1971\n256 位\n\n\n\n8位（8080）\n1974\n1 K位\n\n\n\n16位（8086、80286）2.9 万个晶体管\n1979、1982\n4 K位\n\n\n\n32位（80386、80486）27.5 万个晶体管\n1985、1989\n16 K位\n\n\n\n64位（Pentium、Pentium Pro、Pentium Ⅱ、Pentium Ⅲ、Pentium Ⅳ）4 200.0 万个晶体管\n1993、1995、1997、1999、2000\n64 K位\n\n\n\n目前芯片可集成30亿个晶体管\n\n256 K位\n\n\n\n\n\n1 M位\n\n\n\n\n\n4 M位\n\n\n\n\n\n16 M位\n\n\n\n\n\n64 M位\n\n\n\nMoore 定律：Intel 公司的缔造者之一 Gordon Moore 提出微芯片上集成的晶体管数目每三年翻两番（4倍）\n三、软件技术的兴起和发展1. 各种语言机器语言 面向机器\n汇编语言 面向机器\n高级语言 面向问题\n FORTRAN 科学计算和工程计算\n PASCAL 结构化程序设计\n C＋＋ 面向对象\n Java 适应网络环境\n2. 系统软件\n\n\n语言处理程序\n汇编程序 编译程序 解释程序\n\n\n\n操作系统\nDOS、UNIX、Windows、Linux、Kylin Linux\n\n\n服务性程序\n装配 调试 诊断 排错\n\n\n数据库管理系统\n数据库和数据库管理软件\n\n\n网络软件\n\n\n\n3. 软件发展的特点\n开发周期长\n\n制作成本昂贵\n\n检测软件产品质量的特殊性\n软件是程序以及开发、使用和维护程序所需要的所有文档\n\n\n","slug":"计算机的发展史","date":"2022-08-28T16:00:00.000Z","categories_index":"","tags_index":"计组","author_index":"暗使开开"},{"id":"b7dd937fd88b1c61f67f5db2e381adf2","title":"C++开发","content":"C++开发public框架:心跳程序-框架中的心跳类_public.h// 信号量。class CSEM&#123;private:  union semun  // 用于信号量操作的共同体。  &#123;    int val;    struct semid_ds *buf;    unsigned short  *arry;  &#125;;  int   m_semid;         // 信号量描述符。  // 如果把sem_flg设置为SEM_UNDO，操作系统将跟踪进程对信号量的修改情况，  // 在全部修改过信号量的进程（正常或异常）终止后，操作系统将把信号量恢  // 复为初始值（就像撤消了全部进程对信号的操作）。  // 如果信号量用于表示可用资源的数量（不变的），设置为SEM_UNDO更合适。  // 如果信号量用于生产消费者模型，设置为0更合适。  // 注意，网上查到的关于sem_flg的用法基本上是错的，一定要自己动手多测试。  short m_sem_flg;public:  CSEM();  // 如果信号量已存在，获取信号量；如果信号量不存在，则创建它并初始化为value。  bool init(key_t key,unsigned short value=1,short sem_flg=SEM_UNDO);   bool P(short sem_op=-1); // 信号量的P操作。  bool V(short sem_op=1);  // 信号量的V操作。  int  value();            // 获取信号量的值，成功返回信号量的值，失败返回-1。  bool destroy();          // 销毁信号量。 ~CSEM();&#125;;// 进程心跳信息的结构体。struct st_procinfo&#123;  int    pid;         // 进程id。  char   pname[51];   // 进程名称，可以为空。  int    timeout;     // 超时时间，单位：秒。  time_t atime;       // 最后一次心跳的时间，用整数表示。&#125;;#define MAXNUMP     1000    // 最大的进程数量。#define SHMKEYP   0x5095    // 共享内存的key。#define SEMKEYP   0x5095    // 信号量的key。// 查看共享内存：  ipcs -m// 删除共享内存：  ipcrm -m shmid// 查看信号量：    ipcs -s// 删除信号量：    ipcrm sem semid// 进程心跳操作类。class CPActive&#123;private:  CSEM m_sem;                 // 用于给共享内存加锁的信号量id。  int  m_shmid;               // 共享内存的id。  int  m_pos;                 // 当前进程在共享内存进程组中的位置。  st_procinfo *m_shm;         // 指向共享内存的地址空间。public:  CPActive();  // 初始化成员变量。  // 把当前进程的心跳信息加入共享内存进程组中。  bool AddPInfo(const int timeout,const char *pname=0,CLogFile *logfile=0);  // 更新共享内存进程组中当前进程的心跳时间。  bool UptATime();  ~CPActive();  // 从共享内存中删除当前进程的心跳记录。&#125;;\n\n_public.cppCSEM::CSEM()&#123;  m_semid=-1;  m_sem_flg=SEM_UNDO;&#125;// 如果信号量已存在，获取信号量；如果信号量不存在，则创建它并初始化为value。bool CSEM::init(key_t key,unsigned short value,short sem_flg)&#123;  if (m_semid!=-1) return false;  m_sem_flg=sem_flg;  // 信号量的初始化不能直接用semget(key,1,0666|IPC_CREAT)，因为信号量创建后，初始值是0。  // 信号量的初始化分三个步骤：  // 1）获取信号量，如果成功，函数返回。  // 2）如果失败，则创建信号量。  // 3) 设置信号量的初始值。  // 获取信号量。  if ( (m_semid=semget(key,1,0666)) == -1)  &#123;    // 如果信号量不存在，创建它。    if (errno==2)    &#123;      // 用IPC_EXCL标志确保只有一个进程创建并初始化信号量，其它进程只能获取。      if ( (m_semid=semget(key,1,0666|IPC_CREAT|IPC_EXCL)) == -1)      &#123;        if (errno!=EEXIST)        &#123;          perror(&quot;init 1 semget()&quot;); return false;        &#125;        if ( (m_semid=semget(key,1,0666)) == -1)        &#123; perror(&quot;init 2 semget()&quot;); return false; &#125;            return true;      &#125;      // 信号量创建成功后，还需要把它初始化成value。      union semun sem_union;      sem_union.val = value;   // 设置信号量的初始值。      if (semctl(m_semid,0,SETVAL,sem_union) &lt;  0) &#123; perror(&quot;init semctl()&quot;); return false; &#125;    &#125;    else    &#123; perror(&quot;init 3 semget()&quot;); return false; &#125;  &#125;  return true;&#125;bool CSEM::P(short sem_op)&#123;  if (m_semid==-1) return false;  struct sembuf sem_b;  sem_b.sem_num = 0;      // 信号量编号，0代表第一个信号量。  sem_b.sem_op = sem_op;  // P操作的sem_op必须小于0。  sem_b.sem_flg = m_sem_flg;     if (semop(m_semid,&amp;sem_b,1) == -1) &#123; perror(&quot;p semop()&quot;); return false; &#125;  return true;&#125;bool CSEM::V(short sem_op)&#123;  if (m_semid==-1) return false;  struct sembuf sem_b;  sem_b.sem_num = 0;      // 信号量编号，0代表第一个信号量。  sem_b.sem_op = sem_op;  // V操作的sem_op必须大于0。  sem_b.sem_flg = m_sem_flg;  if (semop(m_semid,&amp;sem_b,1) == -1) &#123; perror(&quot;V semop()&quot;); return false; &#125;  return true;&#125;// 获取信号量的值，成功返回信号量的值，失败返回-1。int CSEM::value()&#123;  return semctl(m_semid,0,GETVAL);&#125;bool CSEM::destroy()&#123;  if (m_semid==-1) return false;  if (semctl(m_semid,0,IPC_RMID) == -1) &#123; perror(&quot;destroy semctl()&quot;); return false; &#125;  return true;&#125;CSEM::~CSEM()&#123;&#125;CPActive::CPActive()&#123;  m_shmid=0;  m_pos=-1;  m_shm=0;&#125;// 把当前进程的心跳信息加入共享内存进程组中。bool CPActive::AddPInfo(const int timeout,const char *pname,CLogFile *logfile)&#123;  if (m_pos!=-1) return true;  if (m_sem.init(SEMKEYP) == false)  // 初始化信号量。  &#123;    if (logfile!=0) logfile-&gt;Write(&quot;创建/获取信号量(%x)失败。\\n&quot;,SEMKEYP);     else printf(&quot;创建/获取信号量(%x)失败。\\n&quot;,SEMKEYP);    return false;  &#125;  // 创建/获取共享内存，键值为SHMKEYP，大小为MAXNUMP个st_procinfo结构体的大小。  if ( (m_shmid = shmget((key_t)SHMKEYP, MAXNUMP*sizeof(struct st_procinfo), 0666|IPC_CREAT)) == -1)  &#123;     if (logfile!=0) logfile-&gt;Write(&quot;创建/获取共享内存(%x)失败。\\n&quot;,SHMKEYP);     else printf(&quot;创建/获取共享内存(%x)失败。\\n&quot;,SHMKEYP);    return false;   &#125;  // 将共享内存连接到当前进程的地址空间。  m_shm=(struct st_procinfo *)shmat(m_shmid, 0, 0);    struct st_procinfo stprocinfo;    // 当前进程心跳信息的结构体。  memset(&amp;stprocinfo,0,sizeof(stprocinfo));  stprocinfo.pid=getpid();            // 当前进程号。  stprocinfo.timeout=timeout;         // 超时时间。  stprocinfo.atime=time(0);           // 当前时间。  STRNCPY(stprocinfo.pname,sizeof(stprocinfo.pname),pname,50); // 进程名。  // 进程id是循环使用的，如果曾经有一个进程异常退出，没有清理自己的心跳信息，  // 它的进程信息将残留在共享内存中，不巧的是，当前进程重用了上述进程的id，  // 这样就会在共享内存中存在两个进程id相同的记录，守护进程检查到残留进程的  // 心跳时，会向进程id发送退出信号，这个信号将误杀当前进程。  // 如果共享内存中存在当前进程编号，一定是其它进程残留的数据，当前进程就重用该位置。  for (int ii=0;ii&lt;MAXNUMP;ii++)  &#123;    if ( (m_shm+ii)-&gt;pid==stprocinfo.pid ) &#123; m_pos=ii; break; &#125;  &#125;  m_sem.P();  // 给共享内存上锁。  if (m_pos==-1)  &#123;    // 如果m_pos==-1，共享内存的进程组中不存在当前进程编号，找一个空位置。    for (int ii=0;ii&lt;MAXNUMP;ii++)      if ( (m_shm+ii)-&gt;pid==0 ) &#123; m_pos=ii; break; &#125;  &#125;  if (m_pos==-1)   &#123;     if (logfile!=0) logfile-&gt;Write(&quot;共享内存空间已用完。\\n&quot;);    else printf(&quot;共享内存空间已用完。\\n&quot;);    m_sem.V();  // 解锁。    return false;   &#125;  // 把当前进程的心跳信息存入共享内存的进程组中。  memcpy(m_shm+m_pos,&amp;stprocinfo,sizeof(struct st_procinfo));   m_sem.V();   // 解锁。  return true;&#125;// 更新共享内存进程组中当前进程的心跳时间。bool CPActive::UptATime()&#123;  if (m_pos==-1) return false;  (m_shm+m_pos)-&gt;atime=time(0);  return true;&#125;CPActive::~CPActive()&#123;  // 把当前进程从共享内存的进程组中移去。  if (m_pos!=-1) memset(m_shm+m_pos,0,sizeof(struct st_procinfo));  // 把共享内存从当前进程中分离。  if (m_shm!=0) shmdt(m_shm);&#125;\n\n\n\n调度程序procctl.cpp\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main(int argc,char *argv[])&#123;  if (argc&lt;3)  &#123;    printf(&quot;Using:./procctl timetvl program argv ...\\n&quot;);    printf(&quot;Example:/project/tools1/bin/procctl 5 /usr/bin/tar zcvf /tmp/tmp.tgz /usr/include\\n\\n&quot;);    printf(&quot;本程序是服务程序的调度程序，周期性启动服务程序或shell脚本。\\n&quot;);    printf(&quot;timetvl 运行周期，单位：秒。被调度的程序运行结束后，在timetvl秒后会被procctl重新启动。\\n&quot;);    printf(&quot;program 被调度的程序名，必须使用全路径。\\n&quot;);    printf(&quot;argvs   被调度的程序的参数。\\n&quot;);    printf(&quot;注意，本程序不会被kill杀死，但可以用kill -9强行杀死。\\n\\n\\n&quot;);    return -1;  &#125;  // 关闭信号和IO，本程序不希望被打扰。  for (int ii=0;ii&lt;64;ii++)  &#123;    signal(ii,SIG_IGN); close(ii);  &#125;  // 生成子进程，父进程退出，让程序运行在后台，由系统1号进程托管。  if (fork()!=0) exit(0);  // 启用SIGCHLD信号，让父进程可以wait子进程退出的状态。  signal(SIGCHLD,SIG_DFL);  char *pargv[argc];  for (int ii=2;ii&lt;argc;ii++)    pargv[ii-2]=argv[ii];  pargv[argc-2]=NULL;  while (true)  &#123;    if (fork()==0)    &#123;      execv(argv[2],pargv);      exit(0);    &#125;    else    &#123;      int status;      wait(&amp;status);      sleep(atoi(argv[1]));    &#125;  &#125;&#125;\n\n编译文件makefile\nall: procctl procctl:procctl.cpp\tg++ -o procctl procctl.cpp\tcp procctl ../bin/.clean:\trm -f procctl \n\n\n\n守护进程程序checkproc.cpp\n#include &quot;_public.h&quot;// 程序运行的日志。CLogFile logfile;int main(int argc,char *argv[])&#123;  // 程序的帮助。  if (argc != 2)  &#123;    printf(&quot;\\n&quot;);    printf(&quot;Using:./checkproc logfilename\\n&quot;);    printf(&quot;Example:/project/tools1/bin/procctl 10 /project/tools1/bin/checkproc /tmp/log/checkproc.log\\n\\n&quot;);    printf(&quot;本程序用于检查后台服务程序是否超时，如果已超时，就终止它。\\n&quot;);    printf(&quot;注意：\\n&quot;);    printf(&quot;  1）本程序由procctl启动，运行周期建议为10秒。\\n&quot;);    printf(&quot;  2）为了避免被普通用户误杀，本程序应该用root用户启动。\\n&quot;);    printf(&quot;  3）如果要停止本程序，只能用killall -9 终止。\\n\\n\\n&quot;);    return 0;  &#125;  // 忽略全部的信号和IO，不希望程序被干扰。  CloseIOAndSignal(true);  // 打开日志文件。  if (logfile.Open(argv[1],&quot;a+&quot;)==false)  &#123; printf(&quot;logfile.Open(%s) failed.\\n&quot;,argv[1]); return -1; &#125;  int shmid=0;  // 创建/获取共享内存，键值为SHMKEYP，大小为MAXNUMP个st_procinfo结构体的大小。  if ( (shmid = shmget((key_t)SHMKEYP, MAXNUMP*sizeof(struct st_procinfo), 0666|IPC_CREAT)) == -1)  &#123;    logfile.Write(&quot;创建/获取共享内存(%x)失败。\\n&quot;,SHMKEYP); return false;  &#125;  // 将共享内存连接到当前进程的地址空间。  struct st_procinfo *shm=(struct st_procinfo *)shmat(shmid, 0, 0);  // 遍历共享内存中全部的记录。  for (int ii=0;ii&lt;MAXNUMP;ii++)  &#123;    // 如果记录的pid==0，表示空记录，continue;    if (shm[ii].pid==0) continue;    // 如果记录的pid!=0，表示是服务程序的心跳记录。    // 程序稳定运行后，以下两行代码可以注释掉。    //logfile.Write(&quot;ii=%d,pid=%d,pname=%s,timeout=%d,atime=%d\\n&quot;,\\    //               ii,shm[ii].pid,shm[ii].pname,shm[ii].timeout,shm[ii].atime);    // 向进程发送信号0，判断它是否还存在，如果不存在，从共享内存中删除该记录，continue;    int iret=kill(shm[ii].pid,0);    if (iret==-1)    &#123;      logfile.Write(&quot;进程pid=%d(%s)已经不存在。\\n&quot;,(shm+ii)-&gt;pid,(shm+ii)-&gt;pname);      memset(shm+ii,0,sizeof(struct st_procinfo)); // 从共享内存中删除该记录。      continue;    &#125;    time_t now=time(0);   // 取当前时间。    // 如果进程未超时，continue;    if (now-shm[ii].atime&lt;shm[ii].timeout) continue;    // 如果已超时。    logfile.Write(&quot;进程pid=%d(%s)已经超时。\\n&quot;,(shm+ii)-&gt;pid,(shm+ii)-&gt;pname);    // 发送信号15，尝试正常终止进程。    kill(shm[ii].pid,15);         // 每隔1秒判断一次进程是否存在，累计5秒，一般来说，5秒的时间足够让进程退出。    for (int jj=0;jj&lt;5;jj++)    &#123;      sleep(1);      iret=kill(shm[ii].pid,0);     // 向进程发送信号0，判断它是否还存在。      if (iret==-1) break;     // 进程已退出。    &#125;     // 如果进程仍存在，就发送信号9，强制终止它。    if (iret==-1)      logfile.Write(&quot;进程pid=%d(%s)已经正常终止。\\n&quot;,(shm+ii)-&gt;pid,(shm+ii)-&gt;pname);    else    &#123;      kill(shm[ii].pid,9);  // 如果进程仍存在，就发送信号9，强制终止它。      logfile.Write(&quot;进程pid=%d(%s)已经强制终止。\\n&quot;,(shm+ii)-&gt;pid,(shm+ii)-&gt;pname);    &#125;        // 从共享内存中删除已超时进程的心跳记录。    memset(shm+ii,0,sizeof(struct st_procinfo)); // 从共享内存中删除该记录。  &#125;  // 把共享内存从当前进程中分离。  shmdt(shm);  return 0;&#125;\n\n编译文件makefile\n# 开发框架头文件路径。PUBINCL = -I/project/public# 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。PUBCPP = /project/public/_public.cpp# 编译参数。CFLAGS = -gall: checkproc checkproc:checkproc.cpp\tg++ $(CFLAGS) -o checkproc checkproc.cpp $(PUBINCL) $(PUBCPP) -lm -lc\tcp checkproc ../bin/.clean:\trm -f checkproc\n\n\n\n压缩文件程序gzipfiles.cpp\n#include &quot;_public.h&quot;// 程序退出和信号2、15的处理函数。void EXIT(int sig);int main(int argc,char *argv[])&#123;  // 程序的帮助。  if (argc != 4)  &#123;    printf(&quot;\\n&quot;);    printf(&quot;Using:/project/tools1/bin/gzipfiles pathname matchstr timeout\\n\\n&quot;);    printf(&quot;Example:/project/tools1/bin/gzipfiles /log/idc \\&quot;*.log.20*\\&quot; 0.02\\n&quot;);    printf(&quot;        /project/tools1/bin/gzipfiles /tmp/idc/surfdata \\&quot;*.xml,*.json\\&quot; 0.01\\n&quot;);    printf(&quot;        /project/tools1/bin/procctl 300 /project/tools1/bin/gzipfiles /log/idc \\&quot;*.log.20*\\&quot; 0.02\\n&quot;);    printf(&quot;        /project/tools1/bin/procctl 300 /project/tools1/bin/gzipfiles /tmp/idc/surfdata \\&quot;*.xml,*.json\\&quot; 0.01\\n\\n&quot;);    printf(&quot;这是一个工具程序，用于压缩历史的数据文件或日志文件。\\n&quot;);    printf(&quot;本程序把pathname目录及子目录中timeout天之前的匹配matchstr文件全部压缩，timeout可以是小数。\\n&quot;);    printf(&quot;本程序不写日志文件，也不会在控制台输出任何信息。\\n&quot;);    printf(&quot;本程序调用/usr/bin/gzip命令压缩文件。\\n\\n\\n&quot;);    return -1;  &#125;  // 关闭全部的信号和输入输出。  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。  CloseIOAndSignal(true); signal(SIGINT,EXIT);  signal(SIGTERM,EXIT);  // 获取文件超时的时间点。  char strTimeOut[21];  LocalTime(strTimeOut,&quot;yyyy-mm-dd hh24:mi:ss&quot;,0-(int)(atof(argv[3])*24*60*60));  CDir Dir;  // 打开目录，CDir.OpenDir()  if (Dir.OpenDir(argv[1],argv[2],10000,true)==false)  &#123;    printf(&quot;Dir.OpenDir(%s) failed.\\n&quot;,argv[1]); return -1;  &#125;  char strCmd[1024]; // 存放gzip压缩文件的命令。  // 遍历目录中的文件名。  while (true)  &#123;    // 得到一个文件的信息，CDir.ReadDir()    if (Dir.ReadDir()==false) break;      // 与超时的时间点比较，如果更早，就需要压缩    if ( (strcmp(Dir.m_ModifyTime,strTimeOut)&lt;0) &amp;&amp; (MatchStr(Dir.m_FileName,&quot;*.gz&quot;)==false) )    &#123;      // 压缩文件，调用操作系统的gzip命令。      SNPRINTF(strCmd,sizeof(strCmd),1000,&quot;/usr/bin/gzip -f %s 1&gt;/dev/null 2&gt;/dev/null&quot;,Dir.m_FullFileName);      if (system(strCmd)==0)         printf(&quot;gzip %s ok.\\n&quot;,Dir.m_FullFileName);      else        printf(&quot;gzip %s failed.\\n&quot;,Dir.m_FullFileName);    &#125;  &#125;  return 0;&#125;void EXIT(int sig)&#123;  printf(&quot;程序退出，sig=%d\\n\\n&quot;,sig);  exit(0);&#125;\n\n编译文件makefile\n# 开发框架头文件路径。PUBINCL = -I/project/public# 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。PUBCPP = /project/public/_public.cpp# 编译参数。CFLAGS = -gall: gzipfilesgzipfiles:gzipfiles.cpp\tg++ $(CFLAGS) -o gzipfiles gzipfiles.cpp $(PUBINCL) $(PUBCPP) -lm -lc\tcp gzipfiles ../bin/.clean:\trm -f gzipfiles\n\n\n\n清理文件程序deletefiles.cpp\n#include &quot;_public.h&quot;// 程序退出和信号2、15的处理函数。void EXIT(int sig);int main(int argc,char *argv[])&#123;  // 程序的帮助。  if (argc != 4)  &#123;    printf(&quot;\\n&quot;);    printf(&quot;Using:/project/tools1/bin/deletefiles pathname matchstr timeout\\n\\n&quot;);    printf(&quot;Example:/project/tools1/bin/deletefiles /log/idc \\&quot;*.log.20*\\&quot; 0.02\\n&quot;);    printf(&quot;        /project/tools1/bin/deletefiles /tmp/idc/surfdata \\&quot;*.xml,*.json\\&quot; 0.01\\n&quot;);    printf(&quot;        /project/tools1/bin/procctl 300 /project/tools1/bin/deletefiles /log/idc \\&quot;*.log.20*\\&quot; 0.02\\n&quot;);    printf(&quot;        /project/tools1/bin/procctl 300 /project/tools1/bin/deletefiles /tmp/idc/surfdata \\&quot;*.xml,*.json\\&quot; 0.01\\n\\n&quot;);    printf(&quot;这是一个工具程序，用于删除历史的数据文件或日志文件。\\n&quot;);    printf(&quot;本程序把pathname目录及子目录中timeout天之前的匹配matchstr文件全部删除，timeout可以是小数。\\n&quot;);    printf(&quot;本程序不写日志文件，也不会在控制台输出任何信息。\\n\\n\\n&quot;);    return -1;  &#125;  // 关闭全部的信号和输入输出。  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。  // CloseIOAndSignal(true);   signal(SIGINT,EXIT);  signal(SIGTERM,EXIT);  // 获取文件超时的时间点。  char strTimeOut[21];  LocalTime(strTimeOut,&quot;yyyy-mm-dd hh24:mi:ss&quot;,0-(int)(atof(argv[3])*24*60*60));  CDir Dir;  // 打开目录，CDir.OpenDir()  if (Dir.OpenDir(argv[1],argv[2],10000,true)==false)  &#123;    printf(&quot;Dir.OpenDir(%s) failed.\\n&quot;,argv[1]); return -1;  &#125;  // 遍历目录中的文件名。  while (true)  &#123;    // 得到一个文件的信息，CDir.ReadDir()    if (Dir.ReadDir()==false) break;printf(&quot;=%s=\\n&quot;,Dir.m_FullFileName);      // 与超时的时间点比较，如果更早，就需要删除。    if (strcmp(Dir.m_ModifyTime,strTimeOut)&lt;0)     &#123;      if (REMOVE(Dir.m_FullFileName)==0)         printf(&quot;REMOVE %s ok.\\n&quot;,Dir.m_FullFileName);      else        printf(&quot;REMOVE %s failed.\\n&quot;,Dir.m_FullFileName);    &#125;  &#125;  return 0;&#125;void EXIT(int sig)&#123;  printf(&quot;程序退出，sig=%d\\n\\n&quot;,sig);  exit(0);&#125;\n\n\n\n编译文件# 开发框架头文件路径。PUBINCL = -I/project/public# 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。PUBCPP = /project/public/_public.cpp# 编译参数。CFLAGS = -gall: deletefilesdeletefiles:deletefiles.cpp\tg++ $(CFLAGS) -o deletefiles deletefiles.cpp $(PUBINCL) $(PUBCPP) -lm -lc\tcp deletefiles ../bin/.clean:\trm -f deletefiles\n\n\n\n模拟生产测试数据文件crtsurfdata.cpp\n/* *  程序名：crtsurfdata.cpp  本程序用于生成全国气象站点观测的分钟数据。*/#include &quot;_public.h&quot;CPActive PActive;   // 进程心跳。// 全国气象站点参数结构体。struct st_stcode&#123;  char provname[31]; // 省  char obtid[11];    // 站号  char obtname[31];  // 站名  double lat;        // 纬度  double lon;        // 经度  double height;     // 海拔高度&#125;;vector&lt;struct st_stcode&gt; vstcode; // 存放全国气象站点参数的容器。// 把站点参数文件中加载到vstcode容器中。bool LoadSTCode(const char *inifile);// 全国气象站点分钟观测数据结构struct st_surfdata&#123;  char obtid[11];      // 站点代码。  char ddatetime[21];  // 数据时间：格式yyyymmddhh24miss  int  t;              // 气温：单位，0.1摄氏度。  int  p;              // 气压：0.1百帕。  int  u;              // 相对湿度，0-100之间的值。  int  wd;             // 风向，0-360之间的值。  int  wf;             // 风速：单位0.1m/s  int  r;              // 降雨量：0.1mm。  int  vis;            // 能见度：0.1米。&#125;;vector&lt;struct st_surfdata&gt; vsurfdata;  // 存放全国气象站点分钟观测数据的容器char strddatetime[21]; // 观测数据的时间。// 模拟生成全国气象站点分钟观测数据，存放在vsurfdata容器中。void CrtSurfData();CFile File;  // 文件操作对象。// 把容器vsurfdata中的全国气象站点分钟观测数据写入文件。bool CrtSurfFile(const char *outpath,const char *datafmt);CLogFile logfile;    // 日志类。void EXIT(int sig);  // 程序退出和信号2、15的处理函数。int main(int argc,char *argv[])&#123;  if ( (argc!=5) &amp;&amp; (argc!=6) )  &#123;    // 如果参数非法，给出帮助文档。    printf(&quot;Using:./crtsurfdata inifile outpath logfile datafmt [datetime]\\n&quot;);    printf(&quot;Example:/project/idc1/bin/crtsurfdata /project/idc1/ini/stcode.ini /tmp/idc/surfdata /log/idc/crtsurfdata.log xml,json,csv\\n&quot;);    printf(&quot;        /project/idc1/bin/crtsurfdata /project/idc1/ini/stcode.ini /tmp/idc/surfdata /log/idc/crtsurfdata.log xml,json,csv 20210710123000\\n&quot;);    printf(&quot;        /project/tools1/bin/procctl 60 /project/idc1/bin/crtsurfdata /project/idc1/ini/stcode.ini /tmp/idc/surfdata /log/idc/crtsurfdata.log xml,json,csv\\n\\n\\n&quot;);    printf(&quot;inifile  全国气象站点参数文件名。\\n&quot;);    printf(&quot;outpath  全国气象站点数据文件存放的目录。\\n&quot;);    printf(&quot;logfile  本程序运行的日志文件名。\\n&quot;);    printf(&quot;datafmt  生成数据文件的格式，支持xml、json和csv三种格式，中间用逗号分隔。\\n&quot;);    printf(&quot;datetime 这是一个可选参数，表示生成指定时间的数据和文件。\\n\\n\\n&quot;);    return -1;  &#125;  // 关闭全部的信号和输入输出。  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。  CloseIOAndSignal(true); signal(SIGINT,EXIT);  signal(SIGTERM,EXIT);  // 打开程序的日志文件。  if (logfile.Open(argv[3],&quot;a+&quot;,false)==false)  &#123;    printf(&quot;logfile.Open(%s) failed.\\n&quot;,argv[3]); return -1;  &#125;  logfile.Write(&quot;crtsurfdata 开始运行。\\n&quot;);  PActive.AddPInfo(20,&quot;crtsurfdata&quot;);  // 把站点参数文件中加载到vstcode容器中。   if (LoadSTCode(argv[1])==false) return -1;  // 获取当前时间，当作观测时间。  memset(strddatetime,0,sizeof(strddatetime));  if (argc==5)    LocalTime(strddatetime,&quot;yyyymmddhh24miss&quot;);  else    STRCPY(strddatetime,sizeof(strddatetime),argv[5]);  // 模拟生成全国气象站点分钟观测数据，存放在vsurfdata容器中。  CrtSurfData();  // 把容器vsurfdata中的全国气象站点分钟观测数据写入文件。  if (strstr(argv[4],&quot;xml&quot;)!=0) CrtSurfFile(argv[2],&quot;xml&quot;);  if (strstr(argv[4],&quot;json&quot;)!=0) CrtSurfFile(argv[2],&quot;json&quot;);  if (strstr(argv[4],&quot;csv&quot;)!=0) CrtSurfFile(argv[2],&quot;csv&quot;);  logfile.Write(&quot;crtsurfdata 运行结束。\\n&quot;);  return 0;&#125;// 把站点参数文件中加载到vstcode容器中。 bool LoadSTCode(const char *inifile)&#123;  // 打开站点参数文件。  if (File.Open(inifile,&quot;r&quot;)==false)  &#123;    logfile.Write(&quot;File.Open(%s) failed.\\n&quot;,inifile); return false;  &#125;  char strBuffer[301];  CCmdStr CmdStr;  struct st_stcode stcode;  while (true)  &#123;    // 从站点参数文件中读取一行，如果已读取完，跳出循环。    if (File.Fgets(strBuffer,300,true)==false) break;    // 把读取到的一行拆分。    CmdStr.SplitToCmd(strBuffer,&quot;,&quot;,true);    if (CmdStr.CmdCount()!=6) continue;     // 扔掉无效的行。    // 把站点参数的每个数据项保存到站点参数结构体中。    memset(&amp;stcode,0,sizeof(struct st_stcode));    CmdStr.GetValue(0, stcode.provname,30); // 省    CmdStr.GetValue(1, stcode.obtid,10);    // 站号    CmdStr.GetValue(2, stcode.obtname,30);  // 站名    CmdStr.GetValue(3,&amp;stcode.lat);         // 纬度    CmdStr.GetValue(4,&amp;stcode.lon);         // 经度    CmdStr.GetValue(5,&amp;stcode.height);      // 海拔高度    // 把站点参数结构体放入站点参数容器。    vstcode.push_back(stcode);  &#125;  /*  for (int ii=0;ii&lt;vstcode.size();ii++)    logfile.Write(&quot;provname=%s,obtid=%s,obtname=%s,lat=%.2f,lon=%.2f,height=%.2f\\n&quot;,\\                   vstcode[ii].provname,vstcode[ii].obtid,vstcode[ii].obtname,vstcode[ii].lat,\\                   vstcode[ii].lon,vstcode[ii].height);  */  return true;&#125;// 模拟生成全国气象站点分钟观测数据，存放在vsurfdata容器中。void CrtSurfData()&#123;  // 播随机数种子。  srand(time(0));  struct st_surfdata stsurfdata;  // 遍历气象站点参数的vstcode容器。  for (int ii=0;ii&lt;vstcode.size();ii++)  &#123;    memset(&amp;stsurfdata,0,sizeof(struct st_surfdata));    // 用随机数填充分钟观测数据的结构体。    strncpy(stsurfdata.obtid,vstcode[ii].obtid,10); // 站点代码。    strncpy(stsurfdata.ddatetime,strddatetime,14);  // 数据时间：格式yyyymmddhh24miss    stsurfdata.t=rand()%351;       // 气温：单位，0.1摄氏度    stsurfdata.p=rand()%265+10000; // 气压：0.1百帕    stsurfdata.u=rand()%100+1;     // 相对湿度，0-100之间的值。    stsurfdata.wd=rand()%360;      // 风向，0-360之间的值。    stsurfdata.wf=rand()%150;      // 风速：单位0.1m/s    stsurfdata.r=rand()%16;        // 降雨量：0.1mm    stsurfdata.vis=rand()%5001+100000;  // 能见度：0.1米    // 把观测数据的结构体放入vsurfdata容器。    vsurfdata.push_back(stsurfdata);  &#125;&#125;// 把容器vsurfdata中的全国气象站点分钟观测数据写入文件。bool CrtSurfFile(const char *outpath,const char *datafmt)&#123;  // 拼接生成数据的文件名，例如：/tmp/idc/surfdata/SURF_ZH_20210629092200_2254.csv  char strFileName[301];  sprintf(strFileName,&quot;%s/SURF_ZH_%s_%d.%s&quot;,outpath,strddatetime,getpid(),datafmt);  // 打开文件。  if (File.OpenForRename(strFileName,&quot;w&quot;)==false)  &#123;    logfile.Write(&quot;File.OpenForRename(%s) failed.\\n&quot;,strFileName); return false;  &#125;  if (strcmp(datafmt,&quot;csv&quot;)==0) File.Fprintf(&quot;站点代码,数据时间,气温,气压,相对湿度,风向,风速,降雨量,能见度\\n&quot;);  if (strcmp(datafmt,&quot;xml&quot;)==0) File.Fprintf(&quot;&lt;data&gt;\\n&quot;);  if (strcmp(datafmt,&quot;json&quot;)==0) File.Fprintf(&quot;&#123;\\&quot;data\\&quot;:[\\n&quot;);  // 遍历存放观测数据的vsurfdata容器。  for (int ii=0;ii&lt;vsurfdata.size();ii++)  &#123;    // 写入一条记录。    if (strcmp(datafmt,&quot;csv&quot;)==0)      File.Fprintf(&quot;%s,%s,%.1f,%.1f,%d,%d,%.1f,%.1f,%.1f\\n&quot;,\\         vsurfdata[ii].obtid,vsurfdata[ii].ddatetime,vsurfdata[ii].t/10.0,vsurfdata[ii].p/10.0,\\         vsurfdata[ii].u,vsurfdata[ii].wd,vsurfdata[ii].wf/10.0,vsurfdata[ii].r/10.0,vsurfdata[ii].vis/10.0);    if (strcmp(datafmt,&quot;xml&quot;)==0)      File.Fprintf(&quot;&lt;obtid&gt;%s&lt;/obtid&gt;&lt;ddatetime&gt;%s&lt;/ddatetime&gt;&lt;t&gt;%.1f&lt;/t&gt;&lt;p&gt;%.1f&lt;/p&gt;&quot;\\                   &quot;&lt;u&gt;%d&lt;/u&gt;&lt;wd&gt;%d&lt;/wd&gt;&lt;wf&gt;%.1f&lt;/wf&gt;&lt;r&gt;%.1f&lt;/r&gt;&lt;vis&gt;%.1f&lt;/vis&gt;&lt;endl/&gt;\\n&quot;,\\         vsurfdata[ii].obtid,vsurfdata[ii].ddatetime,vsurfdata[ii].t/10.0,vsurfdata[ii].p/10.0,\\         vsurfdata[ii].u,vsurfdata[ii].wd,vsurfdata[ii].wf/10.0,vsurfdata[ii].r/10.0,vsurfdata[ii].vis/10.0);    if (strcmp(datafmt,&quot;json&quot;)==0)    &#123;      File.Fprintf(&quot;&#123;\\&quot;obtid\\&quot;:\\&quot;%s\\&quot;,\\&quot;ddatetime\\&quot;:\\&quot;%s\\&quot;,\\&quot;t\\&quot;:\\&quot;%.1f\\&quot;,\\&quot;p\\&quot;:\\&quot;%.1f\\&quot;,&quot;\\                   &quot;\\&quot;u\\&quot;:\\&quot;%d\\&quot;,\\&quot;wd\\&quot;:\\&quot;%d\\&quot;,\\&quot;wf\\&quot;:\\&quot;%.1f\\&quot;,\\&quot;r\\&quot;:\\&quot;%.1f\\&quot;,\\&quot;vis\\&quot;:\\&quot;%.1f\\&quot;&#125;&quot;,\\         vsurfdata[ii].obtid,vsurfdata[ii].ddatetime,vsurfdata[ii].t/10.0,vsurfdata[ii].p/10.0,\\         vsurfdata[ii].u,vsurfdata[ii].wd,vsurfdata[ii].wf/10.0,vsurfdata[ii].r/10.0,vsurfdata[ii].vis/10.0);      if (ii&lt;vsurfdata.size()-1) File.Fprintf(&quot;,\\n&quot;);      else   File.Fprintf(&quot;\\n&quot;);    &#125;  &#125;  if (strcmp(datafmt,&quot;xml&quot;)==0) File.Fprintf(&quot;&lt;/data&gt;\\n&quot;);  if (strcmp(datafmt,&quot;json&quot;)==0) File.Fprintf(&quot;]&#125;\\n&quot;);  // 关闭文件。  File.CloseAndRename();  UTime(strFileName,strddatetime);  // 修改文件的时间属性。  logfile.Write(&quot;生成数据文件%s成功，数据时间%s，记录数%d。\\n&quot;,strFileName,strddatetime,vsurfdata.size());  return true;&#125;// 程序退出和信号2、15的处理函数。void EXIT(int sig)  &#123;  logfile.Write(&quot;程序退出，sig=%d\\n\\n&quot;,sig);  exit(0);&#125;\n\n编译文件makfile\n# 开发框架头文件路径。PUBINCL = -I/project/public# 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。PUBCPP = /project/public/_public.cpp# 编译参数。CFLAGS = -g all:crtsurfdata crtsurfdata:crtsurfdata.cpp\tg++ $(CFLAGS) -o crtsurfdata crtsurfdata.cpp $(PUBINCL) $(PUBCPP) -lm -lc\tcp crtsurfdata ../bin/.clean:\trm -f crtsurfdata \n\n\n\nftp上传下载安装ftp去看安装ftp说明\nftp客户端下载ftpgetfiles.cpp\n#include &quot;_public.h&quot;#include &quot;_ftp.h&quot;// 程序运行参数的结构体。struct st_arg&#123;  char host[31];           // 远程服务端的IP和端口。  int  mode;               // 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。  char username[31];       // 远程服务端ftp的用户名。  char password[31];       // 远程服务端ftp的密码。  char remotepath[301];    // 远程服务端存放文件的目录。  char localpath[301];     // 本地文件存放的目录。  char matchname[101];     // 待下载文件匹配的规则。  char listfilename[301];  // 下载前列出服务端文件名的文件。  int  ptype;              // 下载后服务端文件的处理方式：1-什么也不做；2-删除；3-备份。  char remotepathbak[301]; // 下载后服务端文件的备份目录。  char okfilename[301];    // 已下载成功文件名清单。  bool checkmtime;         // 是否需要检查服务端文件的时间，true-需要，false-不需要，缺省为false。  int  timeout;            // 进程心跳的超时时间。  char pname[51];          // 进程名，建议用&quot;ftpgetfiles_后缀&quot;的方式。&#125; starg;// 文件信息的结构体。struct st_fileinfo&#123;  char filename[301];   // 文件名。  char mtime[21];       // 文件时间。&#125;;vector&lt;struct st_fileinfo&gt; vlistfile1;    // 已下载成功文件名的容器，从okfilename中加载。vector&lt;struct st_fileinfo&gt; vlistfile2;    // 下载前列出服务端文件名的容器，从nlist文件中加载。vector&lt;struct st_fileinfo&gt; vlistfile3;    // 本次不需要下载的文件的容器。vector&lt;struct st_fileinfo&gt; vlistfile4;    // 本次需要下载的文件的容器。// 加载okfilename文件中的内容到容器vlistfile1中。bool LoadOKFile();// 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。bool CompVector();// 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。bool WriteToOKFile();// 如果ptype==1，把下载成功的文件记录追加到okfilename文件中。bool AppendToOKFile(struct st_fileinfo *stfileinfo);// 把ftp.nlist()方法获取到的list文件加载到容器vlistfile2中。bool LoadListFile();CLogFile logfile;Cftp ftp;// 程序退出和信号2、15的处理函数。void EXIT(int sig);void _help();// 把xml解析到参数starg结构中。bool _xmltoarg(char *strxmlbuffer);// 下载文件功能的主函数。bool _ftpgetfiles();CPActive PActive;  // 进程心跳。int main(int argc,char *argv[])&#123;  if (argc!=3) &#123; _help(); return -1; &#125;  // 关闭全部的信号和输入输出。  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。  CloseIOAndSignal(); signal(SIGINT,EXIT); signal(SIGTERM,EXIT);  // 打开日志文件。  if (logfile.Open(argv[1],&quot;a+&quot;)==false)  &#123;    printf(&quot;打开日志文件失败（%s）。\\n&quot;,argv[1]); return -1;  &#125;  // 解析xml，得到程序运行的参数。  if (_xmltoarg(argv[2])==false) return -1;  PActive.AddPInfo(starg.timeout,starg.pname);  // 把进程的心跳信息写入共享内存。  // 登录ftp服务端。  if (ftp.login(starg.host,starg.username,starg.password,starg.mode)==false)  &#123;    logfile.Write(&quot;ftp.login(%s,%s,%s) failed.\\n&quot;,starg.host,starg.username,starg.password); return -1;  &#125;  // logfile.Write(&quot;ftp.login ok.\\n&quot;);  // 正式运行后，可以注释这行代码。  _ftpgetfiles();  ftp.logout();  return 0;&#125;// 下载文件功能的主函数。bool _ftpgetfiles()&#123;  // 进入ftp服务端存放文件的目录。  if (ftp.chdir(starg.remotepath)==false)  &#123;    logfile.Write(&quot;ftp.chdir(%s) failed.\\n&quot;,starg.remotepath); return false;  &#125;  // 调用ftp.nlist()方法列出服务端目录中的文件，结果存放到本地文件中。  if (ftp.nlist(&quot;.&quot;,starg.listfilename)==false)  &#123;    logfile.Write(&quot;ftp.nlist(%s) failed.\\n&quot;,starg.remotepath); return false;  &#125;  PActive.UptATime();   // 更新进程的心跳。  // 把ftp.nlist()方法获取到的list文件加载到容器vlistfile2中。  if (LoadListFile()==false)  &#123;    logfile.Write(&quot;LoadListFile() failed.\\n&quot;);  return false;  &#125;  PActive.UptATime();   // 更新进程的心跳。  if (starg.ptype==1)  &#123;    // 加载okfilename文件中的内容到容器vlistfile1中。    LoadOKFile();    // 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。    CompVector();    // 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。    WriteToOKFile();    // 把vlistfile4中的内容复制到vlistfile2中。    vlistfile2.clear(); vlistfile2.swap(vlistfile4);  &#125;  PActive.UptATime();   // 更新进程的心跳。  char strremotefilename[301],strlocalfilename[301];  // 遍历容器vlistfile2。  for (int ii=0;ii&lt;vlistfile2.size();ii++)  &#123;    SNPRINTF(strremotefilename,sizeof(strremotefilename),300,&quot;%s/%s&quot;,starg.remotepath,vlistfile2[ii].filename);    SNPRINTF(strlocalfilename,sizeof(strlocalfilename),300,&quot;%s/%s&quot;,starg.localpath,vlistfile2[ii].filename);    logfile.Write(&quot;get %s ...&quot;,strremotefilename);    // 调用ftp.get()方法从服务端下载文件。    if (ftp.get(strremotefilename,strlocalfilename)==false)     &#123;      logfile.WriteEx(&quot;failed.\\n&quot;); return false;    &#125;    logfile.WriteEx(&quot;ok.\\n&quot;);    PActive.UptATime();   // 更新进程的心跳。        // 如果ptype==1，把下载成功的文件记录追加到okfilename文件中。    if (starg.ptype==1) AppendToOKFile(&amp;vlistfile2[ii]);    // 删除服务端的文件。    if (starg.ptype==2)     &#123;      if (ftp.ftpdelete(strremotefilename)==false)      &#123;        logfile.Write(&quot;ftp.ftpdelete(%s) failed.\\n&quot;,strremotefilename); return false;      &#125;    &#125;    // 把服务端的文件转存到备份目录。    if (starg.ptype==3)     &#123;      char strremotefilenamebak[301];      SNPRINTF(strremotefilenamebak,sizeof(strremotefilenamebak),300,&quot;%s/%s&quot;,starg.remotepathbak,vlistfile2[ii].filename);      if (ftp.ftprename(strremotefilename,strremotefilenamebak)==false)      &#123;        logfile.Write(&quot;ftp.ftprename(%s,%s) failed.\\n&quot;,strremotefilename,strremotefilenamebak); return false;      &#125;    &#125;  &#125;  return true;&#125;void EXIT(int sig)&#123;  printf(&quot;程序退出，sig=%d\\n\\n&quot;,sig);  exit(0);&#125;void _help()&#123;  printf(&quot;\\n&quot;);  printf(&quot;Using:/project/tools1/bin/ftpgetfiles logfilename xmlbuffer\\n\\n&quot;);  printf(&quot;Sample:/project/tools1/bin/procctl 30 /project/tools1/bin/ftpgetfiles /log/idc/ftpgetfiles.log \\&quot;&lt;host&gt;127.0.0.1:21&lt;/host&gt;&lt;mode&gt;1&lt;/mode&gt;&lt;username&gt;lijialin&lt;/username&gt;&lt;password&gt;6VzFeKBnSoV.&lt;/password&gt;&lt;localpath&gt;/home/lijialin/ftpget&lt;/localpath&gt;&lt;remotepath&gt;/log/idc&lt;/remotepath&gt;&lt;matchname&gt;*&lt;/matchname&gt;&lt;listfilename&gt;/home/lijialin/ftpgetfiles.list&lt;/listfilename&gt;&lt;ptype&gt;1&lt;/ptype&gt;&lt;remotepathbak&gt;/tmp/idc/surfdatabak&lt;/remotepathbak&gt;&lt;okfilename&gt;/home/lijialin/ftpgetfiles.xml&lt;/okfilename&gt;&lt;checkmtime&gt;true&lt;/checkmtime&gt;&lt;timeout&gt;80&lt;/timeout&gt;&lt;pname&gt;ftplijialingetfiles&lt;/pname&gt;\\&quot;\\n\\n\\n&quot;);  printf(&quot;本程序是通用的功能模块，用于把远程ftp服务端的文件下载到本地目录。\\n&quot;);  printf(&quot;logfilename是本程序运行的日志文件。\\n&quot;);  printf(&quot;xmlbuffer为文件下载的参数，如下：\\n&quot;);  printf(&quot;&lt;host&gt;127.0.0.1:21&lt;/host&gt; 远程服务端的IP和端口。\\n&quot;);  printf(&quot;&lt;mode&gt;1&lt;/mode&gt; 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。\\n&quot;);  printf(&quot;&lt;username&gt;wucz&lt;/username&gt; 远程服务端ftp的用户名。\\n&quot;);  printf(&quot;&lt;password&gt;wuczpwd&lt;/password&gt; 远程服务端ftp的密码。\\n&quot;);  printf(&quot;&lt;remotepath&gt;/tmp/idc/surfdata&lt;/remotepath&gt; 远程服务端存放文件的目录。\\n&quot;);  printf(&quot;&lt;localpath&gt;/idcdata/surfdata&lt;/localpath&gt; 本地文件存放的目录。\\n&quot;);  printf(&quot;&lt;matchname&gt;SURF_ZH*.XML,SURF_ZH*.CSV&lt;/matchname&gt; 待下载文件匹配的规则。&quot;\\         &quot;不匹配的文件不会被下载，本字段尽可能设置精确，不建议用*匹配全部的文件。\\n&quot;);  printf(&quot;&lt;listfilename&gt;/idcdata/ftplist/ftpgetfiles_surfdata.list&lt;/listfilename&gt; 下载前列出服务端文件名的文件。\\n&quot;);  printf(&quot;&lt;ptype&gt;1&lt;/ptype&gt; 文件下载成功后，远程服务端文件的处理方式：1-什么也不做；2-删除；3-备份，如果为3，还要指定备份的目录。\\n&quot;);  printf(&quot;&lt;remotepathbak&gt;/tmp/idc/surfdatabak&lt;/remotepathbak&gt; 文件下载成功后，服务端文件的备份目录，此参数只有当ptype=3时才有效。\\n&quot;);  printf(&quot;&lt;okfilename&gt;/idcdata/ftplist/ftpgetfiles_surfdata.xml&lt;/okfilename&gt; 已下载成功文件名清单，此参数只有当ptype=1时才有效。\\n&quot;);  printf(&quot;&lt;checkmtime&gt;true&lt;/checkmtime&gt; 是否需要检查服务端文件的时间，true-需要，false-不需要，此参数只有当ptype=1时才有效，缺省为false。\\n&quot;);  printf(&quot;&lt;timeout&gt;80&lt;/timeout&gt; 下载文件超时时间，单位：秒，视文件大小和网络带宽而定。\\n&quot;);  printf(&quot;&lt;pname&gt;ftpgetfiles_surfdata&lt;/pname&gt; 进程名，尽可能采用易懂的、与其它进程不同的名称，方便故障排查。\\n\\n\\n&quot;);&#125;// 把xml解析到参数starg结构中。bool _xmltoarg(char *strxmlbuffer)&#123;  memset(&amp;starg,0,sizeof(struct st_arg));  GetXMLBuffer(strxmlbuffer,&quot;host&quot;,starg.host,30);   // 远程服务端的IP和端口。  if (strlen(starg.host)==0)  &#123; logfile.Write(&quot;host is null.\\n&quot;);  return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;mode&quot;,&amp;starg.mode);   // 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。  if (starg.mode!=2)  starg.mode=1;  GetXMLBuffer(strxmlbuffer,&quot;username&quot;,starg.username,30);   // 远程服务端ftp的用户名。  if (strlen(starg.username)==0)  &#123; logfile.Write(&quot;username is null.\\n&quot;);  return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;password&quot;,starg.password,30);   // 远程服务端ftp的密码。  if (strlen(starg.password)==0)  &#123; logfile.Write(&quot;password is null.\\n&quot;);  return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;remotepath&quot;,starg.remotepath,300);   // 远程服务端存放文件的目录。  if (strlen(starg.remotepath)==0)  &#123; logfile.Write(&quot;remotepath is null.\\n&quot;);  return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;localpath&quot;,starg.localpath,300);   // 本地文件存放的目录。  if (strlen(starg.localpath)==0)  &#123; logfile.Write(&quot;localpath is null.\\n&quot;);  return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;matchname&quot;,starg.matchname,100);   // 待下载文件匹配的规则。  if (strlen(starg.matchname)==0)  &#123; logfile.Write(&quot;matchname is null.\\n&quot;);  return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;listfilename&quot;,starg.listfilename,300);   // 下载前列出服务端文件名的文件。  if (strlen(starg.listfilename)==0)  &#123; logfile.Write(&quot;listfilename is null.\\n&quot;);  return false; &#125;  // 下载后服务端文件的处理方式：1-什么也不做；2-删除；3-备份。  GetXMLBuffer(strxmlbuffer,&quot;ptype&quot;,&amp;starg.ptype);     if ( (starg.ptype!=1) &amp;&amp; (starg.ptype!=2) &amp;&amp; (starg.ptype!=3) )  &#123; logfile.Write(&quot;ptype is error.\\n&quot;); return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;remotepathbak&quot;,starg.remotepathbak,300); // 下载后服务端文件的备份目录。  if ( (starg.ptype==3) &amp;&amp; (strlen(starg.remotepathbak)==0) )  &#123; logfile.Write(&quot;remotepathbak is null.\\n&quot;);  return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;okfilename&quot;,starg.okfilename,300); // 已下载成功文件名清单。  if ( (starg.ptype==1) &amp;&amp; (strlen(starg.okfilename)==0) )  &#123; logfile.Write(&quot;okfilename is null.\\n&quot;);  return false; &#125;  // 是否需要检查服务端文件的时间，true-需要，false-不需要，此参数只有当ptype=1时才有效，缺省为false。  GetXMLBuffer(strxmlbuffer,&quot;checkmtime&quot;,&amp;starg.checkmtime);  GetXMLBuffer(strxmlbuffer,&quot;timeout&quot;,&amp;starg.timeout);   // 进程心跳的超时时间。  if (starg.timeout==0) &#123; logfile.Write(&quot;timeout is null.\\n&quot;);  return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;pname&quot;,starg.pname,50);     // 进程名。  if (strlen(starg.pname)==0) &#123; logfile.Write(&quot;pname is null.\\n&quot;);  return false; &#125;  return true;&#125;// 把ftp.nlist()方法获取到的list文件加载到容器vlistfile2中。bool LoadListFile()&#123;  vlistfile2.clear();  CFile  File;  if (File.Open(starg.listfilename,&quot;r&quot;)==false)  &#123;    logfile.Write(&quot;File.Open(%s) 失败。\\n&quot;,starg.listfilename); return false;  &#125;  struct st_fileinfo stfileinfo;  while (true)  &#123;    memset(&amp;stfileinfo,0,sizeof(struct st_fileinfo));       if (File.Fgets(stfileinfo.filename,300,true)==false) break;    if (MatchStr(stfileinfo.filename,starg.matchname)==false) continue;    if ( (starg.ptype==1) &amp;&amp; (starg.checkmtime==true) )    &#123;      // 获取ftp服务端文件时间。      if (ftp.mtime(stfileinfo.filename)==false)      &#123;        logfile.Write(&quot;ftp.mtime(%s) failed.\\n&quot;,stfileinfo.filename); return false;      &#125;          strcpy(stfileinfo.mtime,ftp.m_mtime);    &#125;    vlistfile2.push_back(stfileinfo);  &#125;  /*  for (int ii=0;ii&lt;vlistfile2.size();ii++)    logfile.Write(&quot;filename=%s=\\n&quot;,vlistfile2[ii].filename);  */  return true;&#125;// 加载okfilename文件中的内容到容器vlistfile1中。bool LoadOKFile()&#123;  vlistfile1.clear();  CFile File;  // 注意：如果程序是第一次下载，okfilename是不存在的，并不是错误，所以也返回true。  if ( (File.Open(starg.okfilename,&quot;r&quot;))==false )  return true;  char strbuffer[501];  struct st_fileinfo stfileinfo;  while (true)  &#123;    memset(&amp;stfileinfo,0,sizeof(struct st_fileinfo));    if (File.Fgets(strbuffer,300,true)==false) break;    GetXMLBuffer(strbuffer,&quot;filename&quot;,stfileinfo.filename);    GetXMLBuffer(strbuffer,&quot;mtime&quot;,stfileinfo.mtime);    vlistfile1.push_back(stfileinfo);  &#125;  return true;&#125;// 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。bool CompVector()&#123;  vlistfile3.clear(); vlistfile4.clear();  int ii,jj;  // 遍历vlistfile2。  for (ii=0;ii&lt;vlistfile2.size();ii++)  &#123;    // 在vlistfile1中查找vlistfile2[ii]的记录。    for (jj=0;jj&lt;vlistfile1.size();jj++)    &#123;      // 如果找到了，把记录放入vlistfile3。      if ( (strcmp(vlistfile2[ii].filename,vlistfile1[jj].filename)==0) &amp;&amp;           (strcmp(vlistfile2[ii].mtime,vlistfile1[jj].mtime)==0) )      &#123;        vlistfile3.push_back(vlistfile2[ii]); break;      &#125;    &#125;    // 如果没有找到，把记录放入vlistfile4。    if (jj==vlistfile1.size()) vlistfile4.push_back(vlistfile2[ii]);  &#125;  return true;&#125;// 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。bool WriteToOKFile()&#123;  CFile File;      if (File.Open(starg.okfilename,&quot;w&quot;)==false)  &#123;    logfile.Write(&quot;File.Open(%s) failed.\\n&quot;,starg.okfilename); return false;  &#125;  for (int ii=0;ii&lt;vlistfile3.size();ii++)    File.Fprintf(&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;\\n&quot;,vlistfile3[ii].filename,vlistfile3[ii].mtime);  return true;&#125;// 如果ptype==1，把下载成功的文件记录追加到okfilename文件中。bool AppendToOKFile(struct st_fileinfo *stfileinfo)&#123;  CFile File;  if (File.Open(starg.okfilename,&quot;a&quot;)==false)  &#123;    logfile.Write(&quot;File.Open(%s) failed.\\n&quot;,starg.okfilename); return false;  &#125;  File.Fprintf(&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;\\n&quot;,stfileinfo-&gt;filename,stfileinfo-&gt;mtime);  return true;&#125;\n\nftp客户端上传ftpputfiles.cpp\n#include &quot;_public.h&quot;#include &quot;_ftp.h&quot;// 程序运行参数的结构体。struct st_arg&#123;  char host[31];           // 远程服务端的IP和端口。  int  mode;               // 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。  char username[31];       // 远程服务端ftp的用户名。  char password[31];       // 远程服务端ftp的密码。  char remotepath[301];    // 远程服务端存放文件的目录。  char localpath[301];     // 本地文件存放的目录。  char matchname[101];     // 待上传文件匹配的规则。  int  ptype;              // 上传后客户端文件的处理方式：1-什么也不做；2-删除；3-备份。  char localpathbak[301];  // 上传后客户端文件的备份目录。  char okfilename[301];    // 已上传成功文件名清单。  int  timeout;            // 进程心跳的超时时间。  char pname[51];          // 进程名，建议用&quot;ftpputfiles_后缀&quot;的方式。&#125; starg;// 文件信息的结构体。struct st_fileinfo&#123;  char filename[301];   // 文件名。  char mtime[21];       // 文件时间。&#125;;vector&lt;struct st_fileinfo&gt; vlistfile1;    // 已上传成功文件名的容器，从okfilename中加载。vector&lt;struct st_fileinfo&gt; vlistfile2;    // 上传前列出客户端文件名的容器，从nlist文件中加载。vector&lt;struct st_fileinfo&gt; vlistfile3;    // 本次不需要上传的文件的容器。vector&lt;struct st_fileinfo&gt; vlistfile4;    // 本次需要上传的文件的容器。// 加载okfilename文件中的内容到容器vlistfile1中。bool LoadOKFile();// 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。bool CompVector();// 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。bool WriteToOKFile();// 如果ptype==1，把上传成功的文件记录追加到okfilename文件中。bool AppendToOKFile(struct st_fileinfo *stfileinfo);// 把localpath目录下的文件加载到vlistfile2容器中。bool LoadLocalFile();CLogFile logfile;Cftp ftp;// 程序退出和信号2、15的处理函数。void EXIT(int sig);void _help();// 把xml解析到参数starg结构中。bool _xmltoarg(char *strxmlbuffer);// 上传文件功能的主函数。bool _ftpputfiles();CPActive PActive;  // 进程心跳。int main(int argc,char *argv[])&#123;  if (argc!=3) &#123; _help(); return -1; &#125;  // 关闭全部的信号和输入输出。  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。  CloseIOAndSignal(); signal(SIGINT,EXIT); signal(SIGTERM,EXIT);  // 打开日志文件。  if (logfile.Open(argv[1],&quot;a+&quot;)==false)  &#123;    printf(&quot;打开日志文件失败（%s）。\\n&quot;,argv[1]); return -1;  &#125;  // 解析xml，得到程序运行的参数。  if (_xmltoarg(argv[2])==false) return -1;  PActive.AddPInfo(starg.timeout,starg.pname);  // 把进程的心跳信息写入共享内存。  // 登录ftp服务端。  if (ftp.login(starg.host,starg.username,starg.password,starg.mode)==false)  &#123;    logfile.Write(&quot;ftp.login(%s,%s,%s) failed.\\n&quot;,starg.host,starg.username,starg.password); return -1;  &#125;  // logfile.Write(&quot;ftp.login ok.\\n&quot;);  // 正式运行后，可以注释这行代码。  _ftpputfiles();  ftp.logout();  return 0;&#125;// 上传文件功能的主函数。bool _ftpputfiles()&#123;  // 把localpath目录下的文件加载到vlistfile2容器中。  if (LoadLocalFile()==false)  &#123;    logfile.Write(&quot;LoadLocalFile() failed.\\n&quot;);  return false;  &#125;  PActive.UptATime();   // 更新进程的心跳。  if (starg.ptype==1)  &#123;    // 加载okfilename文件中的内容到容器vlistfile1中。    LoadOKFile();    // 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。    CompVector();    // 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。    WriteToOKFile();    // 把vlistfile4中的内容复制到vlistfile2中。    vlistfile2.clear(); vlistfile2.swap(vlistfile4);  &#125;  PActive.UptATime();   // 更新进程的心跳。  char strremotefilename[301],strlocalfilename[301];  // 遍历容器vlistfile2。  for (int ii=0;ii&lt;vlistfile2.size();ii++)  &#123;    SNPRINTF(strremotefilename,sizeof(strremotefilename),300,&quot;%s/%s&quot;,starg.remotepath,vlistfile2[ii].filename);    SNPRINTF(strlocalfilename,sizeof(strlocalfilename),300,&quot;%s/%s&quot;,starg.localpath,vlistfile2[ii].filename);    logfile.Write(&quot;put %s ...&quot;,strlocalfilename);    // 调用ftp.put()方法把文件上传到服务端，第三个参数填true的目的是确保文件上传成功，对方不可抵赖。    if (ftp.put(strlocalfilename,strremotefilename,true)==false)     &#123;      logfile.WriteEx(&quot;failed.\\n&quot;); return false;    &#125;    logfile.WriteEx(&quot;ok.\\n&quot;);    PActive.UptATime();   // 更新进程的心跳。        // 如果ptype==1，把上传成功的文件记录追加到okfilename文件中。    if (starg.ptype==1) AppendToOKFile(&amp;vlistfile2[ii]);    // 删除文件。    if (starg.ptype==2)    &#123;      if (REMOVE(strlocalfilename)==false)      &#123;        logfile.Write(&quot;REMOVE(%s) failed.\\n&quot;,strlocalfilename); return false;      &#125;    &#125;    // 转存到备份目录。    if (starg.ptype==3)    &#123;      char strlocalfilenamebak[301];      SNPRINTF(strlocalfilenamebak,sizeof(strlocalfilenamebak),300,&quot;%s/%s&quot;,starg.localpathbak,vlistfile2[ii].filename);      if (RENAME(strlocalfilename,strlocalfilenamebak)==false)      &#123;        logfile.Write(&quot;RENAME(%s,%s) failed.\\n&quot;,strlocalfilename,strlocalfilenamebak); return false;      &#125;    &#125;  &#125;  return true;&#125;void EXIT(int sig)&#123;  printf(&quot;程序退出，sig=%d\\n\\n&quot;,sig);  exit(0);&#125;void _help()&#123;  printf(&quot;\\n&quot;);  printf(&quot;Using:/project/tools1/bin/ftpputfiles logfilename xmlbuffer\\n\\n&quot;);  printf(&quot;Sample:/project/tools1/bin/procctl 30 /project/tools1/bin/ftpputfiles /log/idc/ftpputfiles.log \\&quot;&lt;host&gt;127.0.0.1:21&lt;/host&gt;&lt;mode&gt;1&lt;/mode&gt;&lt;username&gt;lijialin&lt;/username&gt;&lt;password&gt;6VzFeKBnSoV.&lt;/password&gt;&lt;localpath&gt;/home/lijialin/ftptext&lt;/localpath&gt;&lt;remotepath&gt;/tmp/ftptext&lt;/remotepath&gt;&lt;matchname&gt;*&lt;/matchname&gt;&lt;ptype&gt;1&lt;/ptype&gt;&lt;localpathbak&gt;/tmp/idc/surfdatabak&lt;/localpathbak&gt;&lt;okfilename&gt;/home/lijialin/textlist.xml&lt;/okfilename&gt;&lt;timeout&gt;80&lt;/timeout&gt;&lt;pname&gt;ftplijialinputfiletext&lt;/pname&gt;\\&quot;\\n\\n\\n&quot;);  printf(&quot;本程序是通用的功能模块，用于把本地目录中的文件上传到远程的ftp服务器。\\n&quot;);  printf(&quot;logfilename是本程序运行的日志文件。\\n&quot;);  printf(&quot;xmlbuffer为文件上传的参数，如下：\\n&quot;);  printf(&quot;&lt;host&gt;127.0.0.1:21&lt;/host&gt; 远程服务端的IP和端口。\\n&quot;);  printf(&quot;&lt;mode&gt;1&lt;/mode&gt; 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。\\n&quot;);  printf(&quot;&lt;username&gt;wucz&lt;/username&gt; 远程服务端ftp的用户名。\\n&quot;);  printf(&quot;&lt;password&gt;wuczpwd&lt;/password&gt; 远程服务端ftp的密码。\\n&quot;);  printf(&quot;&lt;remotepath&gt;/tmp/ftpputest&lt;/remotepath&gt; 远程服务端存放文件的目录。\\n&quot;);  printf(&quot;&lt;localpath&gt;/tmp/idc/surfdata&lt;/localpath&gt; 本地文件存放的目录。\\n&quot;);  printf(&quot;&lt;matchname&gt;SURF_ZH*.JSON&lt;/matchname&gt; 待上传文件匹配的规则。&quot;\\         &quot;不匹配的文件不会被上传，本字段尽可能设置精确，不建议用*匹配全部的文件。\\n&quot;);  printf(&quot;&lt;ptype&gt;1&lt;/ptype&gt; 文件上传成功后，本地文件的处理方式：1-什么也不做；2-删除；3-备份，如果为3，还要指定备份的目录。\\n&quot;);  printf(&quot;&lt;localpathbak&gt;/tmp/idc/surfdatabak&lt;/localpathbak&gt; 文件上传成功后，本地文件的备份目录，此参数只有当ptype=3时才有效。\\n&quot;);  printf(&quot;&lt;okfilename&gt;/idcdata/ftplist/ftpputfiles_surfdata.xml&lt;/okfilename&gt; 已上传成功文件名清单，此参数只有当ptype=1时才有效。\\n&quot;);  printf(&quot;&lt;timeout&gt;80&lt;/timeout&gt; 上传文件超时时间，单位：秒，视文件大小和网络带宽而定。\\n&quot;);  printf(&quot;&lt;pname&gt;ftpputfiles_surfdata&lt;/pname&gt; 进程名，尽可能采用易懂的、与其它进程不同的名称，方便故障排查。\\n\\n\\n&quot;);&#125;// 把xml解析到参数starg结构中。bool _xmltoarg(char *strxmlbuffer)&#123;  memset(&amp;starg,0,sizeof(struct st_arg));  GetXMLBuffer(strxmlbuffer,&quot;host&quot;,starg.host,30);   // 远程服务端的IP和端口。  if (strlen(starg.host)==0)  &#123; logfile.Write(&quot;host is null.\\n&quot;);  return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;mode&quot;,&amp;starg.mode);   // 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。  if (starg.mode!=2)  starg.mode=1;  GetXMLBuffer(strxmlbuffer,&quot;username&quot;,starg.username,30);   // 远程服务端ftp的用户名。  if (strlen(starg.username)==0)  &#123; logfile.Write(&quot;username is null.\\n&quot;);  return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;password&quot;,starg.password,30);   // 远程服务端ftp的密码。  if (strlen(starg.password)==0)  &#123; logfile.Write(&quot;password is null.\\n&quot;);  return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;remotepath&quot;,starg.remotepath,300);   // 远程服务端存放文件的目录。  if (strlen(starg.remotepath)==0)  &#123; logfile.Write(&quot;remotepath is null.\\n&quot;);  return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;localpath&quot;,starg.localpath,300);   // 本地文件存放的目录。  if (strlen(starg.localpath)==0)  &#123; logfile.Write(&quot;localpath is null.\\n&quot;);  return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;matchname&quot;,starg.matchname,100);   // 待上传文件匹配的规则。  if (strlen(starg.matchname)==0)  &#123; logfile.Write(&quot;matchname is null.\\n&quot;);  return false; &#125;  // 上传后客户端文件的处理方式：1-什么也不做；2-删除；3-备份。  GetXMLBuffer(strxmlbuffer,&quot;ptype&quot;,&amp;starg.ptype);     if ( (starg.ptype!=1) &amp;&amp; (starg.ptype!=2) &amp;&amp; (starg.ptype!=3) )  &#123; logfile.Write(&quot;ptype is error.\\n&quot;); return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;localpathbak&quot;,starg.localpathbak,300); // 上传后客户端文件的备份目录。  if ( (starg.ptype==3) &amp;&amp; (strlen(starg.localpathbak)==0) )  &#123; logfile.Write(&quot;localpathbak is null.\\n&quot;);  return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;okfilename&quot;,starg.okfilename,300); // 已上传成功文件名清单。  if ( (starg.ptype==1) &amp;&amp; (strlen(starg.okfilename)==0) )  &#123; logfile.Write(&quot;okfilename is null.\\n&quot;);  return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;timeout&quot;,&amp;starg.timeout);   // 进程心跳的超时时间。  if (starg.timeout==0) &#123; logfile.Write(&quot;timeout is null.\\n&quot;);  return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;pname&quot;,starg.pname,50);     // 进程名。  if (strlen(starg.pname)==0) &#123; logfile.Write(&quot;pname is null.\\n&quot;);  return false; &#125;  return true;&#125;// 把localpath目录下的文件加载到vlistfile2容器中。bool LoadLocalFile()&#123;  vlistfile2.clear();  CDir Dir;  Dir.SetDateFMT(&quot;yyyymmddhh24miss&quot;);  // 不包括子目录。  // 注意，如果本地目录下的总文件数超过10000，增量上传文件功能将有问题。  // 建议用deletefiles程序及时清理本地目录中的历史文件。  if (Dir.OpenDir(starg.localpath,starg.matchname)==false)  &#123;    logfile.Write(&quot;Dir.OpenDir(%s) 失败。\\n&quot;,starg.localpath); return false;  &#125;  struct st_fileinfo stfileinfo;  while (true)  &#123;    memset(&amp;stfileinfo,0,sizeof(struct st_fileinfo));       if (Dir.ReadDir()==false) break;    strcpy(stfileinfo.filename,Dir.m_FileName);   // 文件名，不包括目录名。    strcpy(stfileinfo.mtime,Dir.m_ModifyTime);    // 文件时间。    vlistfile2.push_back(stfileinfo);  &#125;  return true;&#125;// 加载okfilename文件中的内容到容器vlistfile1中。bool LoadOKFile()&#123;  vlistfile1.clear();  CFile File;  // 注意：如果程序是第一次上传，okfilename是不存在的，并不是错误，所以也返回true。  if ( (File.Open(starg.okfilename,&quot;r&quot;))==false )  return true;  char strbuffer[501];  struct st_fileinfo stfileinfo;  while (true)  &#123;    memset(&amp;stfileinfo,0,sizeof(struct st_fileinfo));    if (File.Fgets(strbuffer,300,true)==false) break;    GetXMLBuffer(strbuffer,&quot;filename&quot;,stfileinfo.filename);    GetXMLBuffer(strbuffer,&quot;mtime&quot;,stfileinfo.mtime);    vlistfile1.push_back(stfileinfo);  &#125;  return true;&#125;// 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。bool CompVector()&#123;  vlistfile3.clear(); vlistfile4.clear();  int ii,jj;  // 遍历vlistfile2。  for (ii=0;ii&lt;vlistfile2.size();ii++)  &#123;    // 在vlistfile1中查找vlistfile2[ii]的记录。    for (jj=0;jj&lt;vlistfile1.size();jj++)    &#123;      // 如果找到了，把记录放入vlistfile3。      if ( (strcmp(vlistfile2[ii].filename,vlistfile1[jj].filename)==0) &amp;&amp;           (strcmp(vlistfile2[ii].mtime,vlistfile1[jj].mtime)==0) )      &#123;        vlistfile3.push_back(vlistfile2[ii]); break;      &#125;    &#125;    // 如果没有找到，把记录放入vlistfile4。    if (jj==vlistfile1.size()) vlistfile4.push_back(vlistfile2[ii]);  &#125;  return true;&#125;// 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。bool WriteToOKFile()&#123;  CFile File;      if (File.Open(starg.okfilename,&quot;w&quot;)==false)  &#123;    logfile.Write(&quot;File.Open(%s) failed.\\n&quot;,starg.okfilename); return false;  &#125;  for (int ii=0;ii&lt;vlistfile3.size();ii++)    File.Fprintf(&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;\\n&quot;,vlistfile3[ii].filename,vlistfile3[ii].mtime);  return true;&#125;// 如果ptype==1，把上传成功的文件记录追加到okfilename文件中。bool AppendToOKFile(struct st_fileinfo *stfileinfo)&#123;  CFile File;  if (File.Open(starg.okfilename,&quot;a&quot;)==false)  &#123;    logfile.Write(&quot;File.Open(%s) failed.\\n&quot;,starg.okfilename); return false;  &#125;  File.Fprintf(&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;\\n&quot;,stfileinfo-&gt;filename,stfileinfo-&gt;mtime);  return true;&#125;\n\nftp编译makefile\n# 开发框架头文件路径。PUBINCL = -I/project/public# 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。PUBCPP = /project/public/_public.cpp# 编译参数。CFLAGS = -gall: ftpgetfiles ftpputfilesftpgetfiles:ftpgetfiles.cpp\tg++ $(CFLAGS) -o ftpgetfiles ftpgetfiles.cpp $(PUBINCL) $(PUBCPP) /project/public/libftp.a /project/public/_ftp.cpp -lm -lc\tcp ftpgetfiles ../bin/.ftpputfiles:ftpputfiles.cpp\tg++ $(CFLAGS) -o ftpputfiles ftpputfiles.cpp $(PUBINCL) $(PUBCPP) /project/public/libftp.a /project/public/_ftp.cpp -lm -lc\tcp ftpputfiles ../bin/.clean:\trm -f ftpgetfiles ftpputfiles\n\n\n\nTCP上传下载tcp客户端上传tcpputfiles.cpp\n/* * 程序名：tcpputfiles.cpp，采用tcp协议，实现文件上传的客户端。*/#include &quot;_public.h&quot;// 程序运行的参数结构体。struct st_arg&#123;  int  clienttype;          // 客户端类型，1-上传文件；2-下载文件。  char ip[31];              // 服务端的IP地址。  int  port;                // 服务端的端口。  int  ptype;               // 文件上传成功后本地文件的处理方式：1-删除文件；2-移动到备份目录。  char clientpath[301];     // 本地文件存放的根目录。  char clientpathbak[301];  // 文件成功上传后，本地文件备份的根目录，当ptype==2时有效。  bool andchild;            // 是否上传clientpath目录下各级子目录的文件，true-是；false-否。  char matchname[301];      // 待上传文件名的匹配规则，如&quot;*.TXT,*.XML&quot;。  char srvpath[301];        // 服务端文件存放的根目录。  int  timetvl;             // 扫描本地目录文件的时间间隔，单位：秒。  int  timeout;             // 进程心跳的超时时间。  char pname[51];           // 进程名，建议用&quot;tcpputfiles_后缀&quot;的方式。&#125; starg;CLogFile logfile;// 程序退出和信号2、15的处理函数。void EXIT(int sig);void _help();// 把xml解析到参数starg结构中。bool _xmltoarg(char *strxmlbuffer);CTcpClient TcpClient;bool Login(const char *argv);    // 登录业务。bool ActiveTest();    // 心跳。char strrecvbuffer[1024];   // 发送报文的buffer。char strsendbuffer[1024];   // 接收报文的buffer。// 文件上传的主函数，执行一次文件上传的任务。bool _tcpputfiles();bool bcontinue=true;   // 如果调用_tcpputfiles发送了文件，bcontinue为true，初始化为true。// 把文件的内容发送给对端。bool SendFile(const int sockfd,const char *filename,const int filesize);// 删除或者转存本地的文件。bool AckMessage(const char *strrecvbuffer);CPActive PActive;  // 进程心跳。int main(int argc,char *argv[])&#123;  if (argc!=3) &#123; _help(); return -1; &#125;  // 关闭全部的信号和输入输出。  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。  CloseIOAndSignal(); signal(SIGINT,EXIT); signal(SIGTERM,EXIT);  // 打开日志文件。  if (logfile.Open(argv[1],&quot;a+&quot;)==false)  &#123;    printf(&quot;打开日志文件失败（%s）。\\n&quot;,argv[1]); return -1;  &#125;  // 解析xml，得到程序运行的参数。  if (_xmltoarg(argv[2])==false) return -1;  PActive.AddPInfo(starg.timeout,starg.pname);  // 把进程的心跳信息写入共享内存。  // 向服务端发起连接请求。  if (TcpClient.ConnectToServer(starg.ip,starg.port)==false)  &#123;    logfile.Write(&quot;TcpClient.ConnectToServer(%s,%d) failed.\\n&quot;,starg.ip,starg.port); EXIT(-1);  &#125;  // 登录业务。  if (Login(argv[2])==false) &#123; logfile.Write(&quot;Login() failed.\\n&quot;); EXIT(-1); &#125;  while (true)  &#123;    // 调用文件上传的主函数，执行一次文件上传的任务。    if (_tcpputfiles()==false) &#123; logfile.Write(&quot;_tcpputfiles() failed.\\n&quot;); EXIT(-1); &#125;    if (bcontinue==false)    &#123;      sleep(starg.timetvl);      if (ActiveTest()==false) break;    &#125;    PActive.UptATime();  &#125;     EXIT(0);&#125;// 心跳。 bool ActiveTest()    &#123;  memset(strsendbuffer,0,sizeof(strsendbuffer));  memset(strrecvbuffer,0,sizeof(strrecvbuffer));   SPRINTF(strsendbuffer,sizeof(strsendbuffer),&quot;&lt;activetest&gt;ok&lt;/activetest&gt;&quot;);  // logfile.Write(&quot;发送：%s\\n&quot;,strsendbuffer);  if (TcpClient.Write(strsendbuffer)==false) return false; // 向服务端发送请求报文。  if (TcpClient.Read(strrecvbuffer,20)==false) return false; // 接收服务端的回应报文。  // logfile.Write(&quot;接收：%s\\n&quot;,strrecvbuffer);  return true;&#125;// 登录业务。 bool Login(const char *argv)    &#123;  memset(strsendbuffer,0,sizeof(strsendbuffer));  memset(strrecvbuffer,0,sizeof(strrecvbuffer));   SPRINTF(strsendbuffer,sizeof(strsendbuffer),&quot;%s&lt;clienttype&gt;1&lt;/clienttype&gt;&quot;,argv);  logfile.Write(&quot;发送：%s\\n&quot;,strsendbuffer);  if (TcpClient.Write(strsendbuffer)==false) return false; // 向服务端发送请求报文。  if (TcpClient.Read(strrecvbuffer,20)==false) return false; // 接收服务端的回应报文。  logfile.Write(&quot;接收：%s\\n&quot;,strrecvbuffer);  logfile.Write(&quot;登录(%s:%d)成功。\\n&quot;,starg.ip,starg.port);   return true;&#125;void EXIT(int sig)&#123;  logfile.Write(&quot;程序退出，sig=%d\\n\\n&quot;,sig);  exit(0);&#125;void _help()&#123;  printf(&quot;\\n&quot;);  printf(&quot;Using:/project/tools1/bin/tcpputfiles logfilename xmlbuffer\\n\\n&quot;);  printf(&quot;Sample:/project/tools1/bin/procctl 20 /project/tools1/bin/tcpputfiles /log/idc/tcpputfiles_surfdata.log \\&quot;&lt;ip&gt;39.106.159.62&lt;/ip&gt;&lt;port&gt;5005&lt;/port&gt;&lt;ptype&gt;1&lt;/ptype&gt;&lt;clientpath&gt;/tmp/tcp/surfdata1&lt;/clientpath&gt;&lt;andchild&gt;true&lt;/andchild&gt;&lt;matchname&gt;*.XML,*.CSV,*.JSON&lt;/matchname&gt;&lt;srvpath&gt;/tmp/tcp/surfdata2&lt;/srvpath&gt;&lt;timetvl&gt;10&lt;/timetvl&gt;&lt;timeout&gt;50&lt;/timeout&gt;&lt;pname&gt;tcpputfiles_surfdata&lt;/pname&gt;\\&quot;\\n&quot;);  printf(&quot;       /project/tools1/bin/procctl 20 /project/tools1/bin/tcpputfiles /log/idc/tcpputfiles_surfdata.log \\&quot;&lt;ip&gt;39.106.159.62&lt;/ip&gt;&lt;port&gt;5005&lt;/port&gt;&lt;ptype&gt;2&lt;/ptype&gt;&lt;clientpath&gt;/tmp/tcp/surfdata1&lt;/clientpath&gt;&lt;clientpathbak&gt;/tmp/tcp/surfdata1bak&lt;/clientpathbak&gt;&lt;andchild&gt;true&lt;/andchild&gt;&lt;matchname&gt;*.XML,*.CSV,*.JSON&lt;/matchname&gt;&lt;srvpath&gt;/tmp/tcp/surfdata2&lt;/srvpath&gt;&lt;timetvl&gt;10&lt;/timetvl&gt;&lt;timeout&gt;50&lt;/timeout&gt;&lt;pname&gt;tcpputfiles_surfdata&lt;/pname&gt;\\&quot;\\n\\n\\n&quot;);  printf(&quot;本程序是数据中心的公共功能模块，采用tcp协议把文件上传给服务端。\\n&quot;);  printf(&quot;logfilename   本程序运行的日志文件。\\n&quot;);  printf(&quot;xmlbuffer     本程序运行的参数，如下：\\n&quot;);  printf(&quot;ip            服务端的IP地址。\\n&quot;);  printf(&quot;port          服务端的端口。\\n&quot;);  printf(&quot;ptype         文件上传成功后的处理方式：1-删除文件；2-移动到备份目录。\\n&quot;);  printf(&quot;clientpath    本地文件存放的根目录。\\n&quot;);  printf(&quot;clientpathbak 文件成功上传后，本地文件备份的根目录，当ptype==2时有效。\\n&quot;);  printf(&quot;andchild      是否上传clientpath目录下各级子目录的文件，true-是；false-否，缺省为false。\\n&quot;);  printf(&quot;matchname     待上传文件名的匹配规则，如\\&quot;*.TXT,*.XML\\&quot;\\n&quot;);  printf(&quot;srvpath       服务端文件存放的根目录。\\n&quot;);  printf(&quot;timetvl       扫描本地目录文件的时间间隔，单位：秒，取值在1-30之间。\\n&quot;);  printf(&quot;timeout       本程序的超时时间，单位：秒，视文件大小和网络带宽而定，建议设置50以上。\\n&quot;);  printf(&quot;pname         进程名，尽可能采用易懂的、与其它进程不同的名称，方便故障排查。\\n\\n&quot;);&#125;// 把xml解析到参数starg结构bool _xmltoarg(char *strxmlbuffer)&#123;  memset(&amp;starg,0,sizeof(struct st_arg));  GetXMLBuffer(strxmlbuffer,&quot;ip&quot;,starg.ip);  if (strlen(starg.ip)==0) &#123; logfile.Write(&quot;ip is null.\\n&quot;); return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;port&quot;,&amp;starg.port);  if ( starg.port==0) &#123; logfile.Write(&quot;port is null.\\n&quot;); return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;ptype&quot;,&amp;starg.ptype);  if ((starg.ptype!=1)&amp;&amp;(starg.ptype!=2)) &#123; logfile.Write(&quot;ptype not in (1,2).\\n&quot;); return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;clientpath&quot;,starg.clientpath);  if (strlen(starg.clientpath)==0) &#123; logfile.Write(&quot;clientpath is null.\\n&quot;); return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;clientpathbak&quot;,starg.clientpathbak);  if ((starg.ptype==2)&amp;&amp;(strlen(starg.clientpathbak)==0)) &#123; logfile.Write(&quot;clientpathbak is null.\\n&quot;); return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;andchild&quot;,&amp;starg.andchild);  GetXMLBuffer(strxmlbuffer,&quot;matchname&quot;,starg.matchname);  if (strlen(starg.matchname)==0) &#123; logfile.Write(&quot;matchname is null.\\n&quot;); return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;srvpath&quot;,starg.srvpath);  if (strlen(starg.srvpath)==0) &#123; logfile.Write(&quot;srvpath is null.\\n&quot;); return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;timetvl&quot;,&amp;starg.timetvl);  if (starg.timetvl==0) &#123; logfile.Write(&quot;timetvl is null.\\n&quot;); return false; &#125;  // 扫描本地目录文件的时间间隔，单位：秒。  // starg.timetvl没有必要超过30秒。  if (starg.timetvl&gt;30) starg.timetvl=30;  // 进程心跳的超时时间，一定要大于starg.timetvl，没有必要小于50秒。  GetXMLBuffer(strxmlbuffer,&quot;timeout&quot;,&amp;starg.timeout);  if (starg.timeout==0) &#123; logfile.Write(&quot;timeout is null.\\n&quot;); return false; &#125;  if (starg.timeout&lt;50) starg.timeout=50;  GetXMLBuffer(strxmlbuffer,&quot;pname&quot;,starg.pname,50);  if (strlen(starg.pname)==0) &#123; logfile.Write(&quot;pname is null.\\n&quot;); return false; &#125;  return true;&#125;// 文件上传的主函数，执行一次文件上传的任务。bool _tcpputfiles()&#123;  CDir Dir;  // 调用OpenDir()打开starg.clientpath目录。  if (Dir.OpenDir(starg.clientpath,starg.matchname,10000,starg.andchild)==false)  &#123;    logfile.Write(&quot;Dir.OpenDir(%s) 失败。\\n&quot;,starg.clientpath); return false;  &#125;  int delayed=0;        // 未收到对端确认报文的文件数量。  int buflen=0;         // 用于存放strrecvbuffer的长度。  bcontinue=false;  while (true)  &#123;    memset(strsendbuffer,0,sizeof(strsendbuffer));    memset(strrecvbuffer,0,sizeof(strrecvbuffer));    // 遍历目录中的每个文件，调用ReadDir()获取一个文件名。    if (Dir.ReadDir()==false) break;    bcontinue=true;    // 把文件名、修改时间、文件大小组成报文，发送给对端。    SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;&lt;size&gt;%d&lt;/size&gt;&quot;,Dir.m_FullFileName,Dir.m_ModifyTime,Dir.m_FileSize);    // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);    if (TcpClient.Write(strsendbuffer)==false)    &#123;      logfile.Write(&quot;TcpClient.Write() failed.\\n&quot;); return false;    &#125;    // 把文件的内容发送给对端。    logfile.Write(&quot;send %s(%d) ...&quot;,Dir.m_FullFileName,Dir.m_FileSize);    if (SendFile(TcpClient.m_connfd,Dir.m_FullFileName,Dir.m_FileSize)==true)    &#123;      logfile.WriteEx(&quot;ok.\\n&quot;); delayed++;    &#125;    else    &#123;      logfile.WriteEx(&quot;failed.\\n&quot;); TcpClient.Close(); return false;    &#125;    PActive.UptATime();    // 接收对端的确认报文。    while (delayed&gt;0)    &#123;      memset(strrecvbuffer,0,sizeof(strrecvbuffer));      if (TcpRead(TcpClient.m_connfd,strrecvbuffer,&amp;buflen,-1)==false) break;      // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);      // 删除或者转存本地的文件。      delayed--;      AckMessage(strrecvbuffer);    &#125;  &#125;  // 继续接收对端的确认报文。  while (delayed&gt;0)  &#123;    memset(strrecvbuffer,0,sizeof(strrecvbuffer));    if (TcpRead(TcpClient.m_connfd,strrecvbuffer,&amp;buflen,10)==false) break;    // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);    // 删除或者转存本地的文件。    delayed--;    AckMessage(strrecvbuffer);  &#125;  return true;&#125;// 把文件的内容发送给对端。bool SendFile(const int sockfd,const char *filename,const int filesize)&#123;  int  onread=0;        // 每次调用fread时打算读取的字节数。   int  bytes=0;         // 调用一次fread从文件中读取的字节数。  char buffer[1000];    // 存放读取数据的buffer。  int  totalbytes=0;    // 从文件中已读取的字节总数。  FILE *fp=NULL;  // 以&quot;rb&quot;的模式打开文件。  if ( (fp=fopen(filename,&quot;rb&quot;))==NULL )  return false;  while (true)  &#123;    memset(buffer,0,sizeof(buffer));    // 计算本次应该读取的字节数，如果剩余的数据超过1000字节，就打算读1000字节。    if (filesize-totalbytes&gt;1000) onread=1000;    else onread=filesize-totalbytes;    // 从文件中读取数据。    bytes=fread(buffer,1,onread,fp);    // 把读取到的数据发送给对端。    if (bytes&gt;0)    &#123;      if (Writen(sockfd,buffer,bytes)==false) &#123; fclose(fp); return false; &#125;    &#125;    // 计算文件已读取的字节总数，如果文件已读完，跳出循环。    totalbytes=totalbytes+bytes;    if (totalbytes==filesize) break;  &#125;  fclose(fp);  return true;&#125;// 删除或者转存本地的文件。bool AckMessage(const char *strrecvbuffer)&#123;  char filename[301];  char result[11];  memset(filename,0,sizeof(filename));  memset(result,0,sizeof(result));  GetXMLBuffer(strrecvbuffer,&quot;filename&quot;,filename,300);  GetXMLBuffer(strrecvbuffer,&quot;result&quot;,result,10);  // 如果服务端接收文件不成功，直接返回。  if (strcmp(result,&quot;ok&quot;)!=0) return true;  // ptype==1，删除文件。  if (starg.ptype==1)  &#123;    if (REMOVE(filename)==false) &#123; logfile.Write(&quot;REMOVE(%s) failed.\\n&quot;,filename); return false; &#125;  &#125;    // ptype==2，移动到备份目录。  if (starg.ptype==2)  &#123;    // 生成转存后的备份目录文件名。    char bakfilename[301];    STRCPY(bakfilename,sizeof(bakfilename),filename);    UpdateStr(bakfilename,starg.clientpath,starg.clientpathbak,false);    if (RENAME(filename,bakfilename)==false)     &#123; logfile.Write(&quot;RENAME(%s,%s) failed.\\n&quot;,filename,bakfilename); return false; &#125;  &#125;  return true;&#125;\n\n\n\ntcp客户端下载tcpgetfiles.cpp\n/* * 程序名：tcpgetfiles.cpp，采用tcp协议，实现文件下载的客户端。*/#include &quot;_public.h&quot;// 程序运行的参数结构体。struct st_arg&#123;  int  clienttype;          // 客户端类型，1-上传文件；2-下载文件。  char ip[31];              // 服务端的IP地址。  int  port;                // 服务端的端口。  int  ptype;               // 文件下载成功后服务端文件的处理方式：1-删除文件；2-移动到备份目录。  char srvpath[301];        // 服务端文件存放的根目录。  char srvpathbak[301];     // 文件成功下载后，服务端文件备份的根目录，当ptype==2时有效。  bool andchild;            // 是否下载srvpath目录下各级子目录的文件，true-是；false-否。  char matchname[301];      // 待下载文件名的匹配规则，如&quot;*.TXT,*.XML&quot;。  char clientpath[301];     // 客户端文件存放的根目录。  int  timetvl;             // 扫描服务端目录文件的时间间隔，单位：秒。  int  timeout;             // 进程心跳的超时时间。  char pname[51];           // 进程名，建议用&quot;tcpgetfiles_后缀&quot;的方式。&#125; starg;CLogFile logfile;// 程序退出和信号2、15的处理函数。void EXIT(int sig);void _help();// 把xml解析到参数starg结构中。bool _xmltoarg(char *strxmlbuffer);CTcpClient TcpClient;bool Login(const char *argv);    // 登录业务。char strrecvbuffer[1024];   // 发送报文的buffer。char strsendbuffer[1024];   // 接收报文的buffer。// 文件下载的主函数。void _tcpgetfiles();// 接收文件的内容。bool RecvFile(const int sockfd,const char *filename,const char *mtime,int filesize);CPActive PActive;  // 进程心跳。int main(int argc,char *argv[])&#123;  if (argc!=3) &#123; _help(); return -1; &#125;  // 关闭全部的信号和输入输出。  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。  CloseIOAndSignal(); signal(SIGINT,EXIT); signal(SIGTERM,EXIT);  // 打开日志文件。  if (logfile.Open(argv[1],&quot;a+&quot;)==false)  &#123;    printf(&quot;打开日志文件失败（%s）。\\n&quot;,argv[1]); return -1;  &#125;  // 解析xml，得到程序运行的参数。  if (_xmltoarg(argv[2])==false) return -1;  PActive.AddPInfo(starg.timeout,starg.pname);  // 把进程的心跳信息写入共享内存。  // 向服务端发起连接请求。  if (TcpClient.ConnectToServer(starg.ip,starg.port)==false)  &#123;    logfile.Write(&quot;TcpClient.ConnectToServer(%s,%d) failed.\\n&quot;,starg.ip,starg.port); EXIT(-1);  &#125;  // 登录业务。  if (Login(argv[2])==false) &#123; logfile.Write(&quot;Login() failed.\\n&quot;); EXIT(-1); &#125;  // 调用文件下载的主函数。  _tcpgetfiles();  EXIT(0);&#125;// 登录业务。 bool Login(const char *argv)    &#123;  memset(strsendbuffer,0,sizeof(strsendbuffer));  memset(strrecvbuffer,0,sizeof(strrecvbuffer));   SPRINTF(strsendbuffer,sizeof(strsendbuffer),&quot;%s&lt;clienttype&gt;2&lt;/clienttype&gt;&quot;,argv);  logfile.Write(&quot;发送：%s\\n&quot;,strsendbuffer);  if (TcpClient.Write(strsendbuffer)==false) return false; // 向服务端发送请求报文。  if (TcpClient.Read(strrecvbuffer,20)==false) return false; // 接收服务端的回应报文。  logfile.Write(&quot;接收：%s\\n&quot;,strrecvbuffer);  logfile.Write(&quot;登录(%s:%d)成功。\\n&quot;,starg.ip,starg.port);   return true;&#125;void EXIT(int sig)&#123;  logfile.Write(&quot;程序退出，sig=%d\\n\\n&quot;,sig);  exit(0);&#125;void _help()&#123;  printf(&quot;\\n&quot;);  printf(&quot;Using:/project/tools1/bin/tcpgetfiles logfilename xmlbuffer\\n\\n&quot;);  printf(&quot;Sample:/project/tools1/bin/procctl 20 /project/tools1/bin/tcpgetfiles /log/idc/tcpgetfiles_surfdata.log \\&quot;&lt;ip&gt;192.168.174.132&lt;/ip&gt;&lt;port&gt;5005&lt;/port&gt;&lt;ptype&gt;1&lt;/ptype&gt;&lt;srvpath&gt;/tmp/tcp/surfdata2&lt;/srvpath&gt;&lt;andchild&gt;true&lt;/andchild&gt;&lt;matchname&gt;*.XML,*.CSV,*.JSON&lt;/matchname&gt;&lt;clientpath&gt;/tmp/tcp/surfdata3&lt;/clientpath&gt;&lt;timetvl&gt;10&lt;/timetvl&gt;&lt;timeout&gt;50&lt;/timeout&gt;&lt;pname&gt;tcpgetfiles_surfdata&lt;/pname&gt;\\&quot;\\n&quot;);  printf(&quot;       /project/tools1/bin/procctl 20 /project/tools1/bin/tcpgetfiles /log/idc/tcpgetfiles_surfdata.log \\&quot;&lt;ip&gt;192.168.174.132&lt;/ip&gt;&lt;port&gt;5005&lt;/port&gt;&lt;ptype&gt;2&lt;/ptype&gt;&lt;srvpath&gt;/tmp/tcp/surfdata2&lt;/srvpath&gt;&lt;srvpathbak&gt;/tmp/tcp/surfdata2bak&lt;/srvpathbak&gt;&lt;andchild&gt;true&lt;/andchild&gt;&lt;matchname&gt;*.XML,*.CSV,*.JSON&lt;/matchname&gt;&lt;clientpath&gt;/tmp/tcp/surfdata3&lt;/clientpath&gt;&lt;timetvl&gt;10&lt;/timetvl&gt;&lt;timeout&gt;50&lt;/timeout&gt;&lt;pname&gt;tcpgetfiles_surfdata&lt;/pname&gt;\\&quot;\\n\\n\\n&quot;);  printf(&quot;本程序是数据中心的公共功能模块，采用tcp协议从服务端下载文件。\\n&quot;);  printf(&quot;logfilename   本程序运行的日志文件。\\n&quot;);  printf(&quot;xmlbuffer     本程序运行的参数，如下：\\n&quot;);  printf(&quot;ip            服务端的IP地址。\\n&quot;);  printf(&quot;port          服务端的端口。\\n&quot;);  printf(&quot;ptype         文件下载成功后服务端文件的处理方式：1-删除文件；2-移动到备份目录。\\n&quot;);  printf(&quot;srvpath       服务端文件存放的根目录。\\n&quot;);  printf(&quot;srvpathbak    文件成功下载后，服务端文件备份的根目录，当ptype==2时有效。\\n&quot;);  printf(&quot;andchild      是否下载srvpath目录下各级子目录的文件，true-是；false-否，缺省为false。\\n&quot;);  printf(&quot;matchname     待下载文件名的匹配规则，如\\&quot;*.TXT,*.XML\\&quot;\\n&quot;);  printf(&quot;clientpath    客户端文件存放的根目录。\\n&quot;);  printf(&quot;timetvl       扫描服务目录文件的时间间隔，单位：秒，取值在1-30之间。\\n&quot;);  printf(&quot;timeout       本程序的超时时间，单位：秒，视文件大小和网络带宽而定，建议设置50以上。\\n&quot;);  printf(&quot;pname         进程名，尽可能采用易懂的、与其它进程不同的名称，方便故障排查。\\n\\n&quot;);&#125;// 把xml解析到参数starg结构bool _xmltoarg(char *strxmlbuffer)&#123;  memset(&amp;starg,0,sizeof(struct st_arg));  GetXMLBuffer(strxmlbuffer,&quot;ip&quot;,starg.ip);  if (strlen(starg.ip)==0) &#123; logfile.Write(&quot;ip is null.\\n&quot;); return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;port&quot;,&amp;starg.port);  if ( starg.port==0) &#123; logfile.Write(&quot;port is null.\\n&quot;); return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;ptype&quot;,&amp;starg.ptype);  if ((starg.ptype!=1)&amp;&amp;(starg.ptype!=2)) &#123; logfile.Write(&quot;ptype not in (1,2).\\n&quot;); return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;srvpath&quot;,starg.srvpath);  if (strlen(starg.srvpath)==0) &#123; logfile.Write(&quot;srvpath is null.\\n&quot;); return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;srvpathbak&quot;,starg.srvpathbak);  if ((starg.ptype==2)&amp;&amp;(strlen(starg.srvpathbak)==0)) &#123; logfile.Write(&quot;srvpathbak is null.\\n&quot;); return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;andchild&quot;,&amp;starg.andchild);  GetXMLBuffer(strxmlbuffer,&quot;matchname&quot;,starg.matchname);  if (strlen(starg.matchname)==0) &#123; logfile.Write(&quot;matchname is null.\\n&quot;); return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;clientpath&quot;,starg.clientpath);  if (strlen(starg.clientpath)==0) &#123; logfile.Write(&quot;clientpath is null.\\n&quot;); return false; &#125;  GetXMLBuffer(strxmlbuffer,&quot;timetvl&quot;,&amp;starg.timetvl);  if (starg.timetvl==0) &#123; logfile.Write(&quot;timetvl is null.\\n&quot;); return false; &#125;  // 扫描服务端目录文件的时间间隔，单位：秒。  // starg.timetvl没有必要超过30秒。  if (starg.timetvl&gt;30) starg.timetvl=30;  // 进程心跳的超时时间，一定要大于starg.timetvl，没有必要小于50秒。  GetXMLBuffer(strxmlbuffer,&quot;timeout&quot;,&amp;starg.timeout);  if (starg.timeout==0) &#123; logfile.Write(&quot;timeout is null.\\n&quot;); return false; &#125;  if (starg.timeout&lt;50) starg.timeout=50;  GetXMLBuffer(strxmlbuffer,&quot;pname&quot;,starg.pname,50);  if (strlen(starg.pname)==0) &#123; logfile.Write(&quot;pname is null.\\n&quot;); return false; &#125;  return true;&#125;// 文件下载的主函数。void _tcpgetfiles()&#123;  PActive.AddPInfo(starg.timeout,starg.pname);  while (true)  &#123;    memset(strsendbuffer,0,sizeof(strsendbuffer));    memset(strrecvbuffer,0,sizeof(strrecvbuffer));    PActive.UptATime();    // 接收服务端的报文。    // 第二个参数的取值必须大于starg.timetvl，小于starg.timeout。    if (TcpClient.Read(strrecvbuffer,starg.timetvl+10)==false)    &#123;      logfile.Write(&quot;TcpClient.Read() failed.\\n&quot;); return;    &#125;    // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);    // 处理心跳报文。    if (strcmp(strrecvbuffer,&quot;&lt;activetest&gt;ok&lt;/activetest&gt;&quot;)==0)    &#123;      strcpy(strsendbuffer,&quot;ok&quot;);      // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);      if (TcpClient.Write(strsendbuffer)==false)      &#123;        logfile.Write(&quot;TcpClient.Write() failed.\\n&quot;); return;      &#125;    &#125;    // 处理下载文件的请求报文。    if (strncmp(strrecvbuffer,&quot;&lt;filename&gt;&quot;,10)==0)    &#123;      // 解析下载文件请求报文的xml。      char serverfilename[301];  memset(serverfilename,0,sizeof(serverfilename));      char mtime[21];            memset(mtime,0,sizeof(mtime));      int  filesize=0;      GetXMLBuffer(strrecvbuffer,&quot;filename&quot;,serverfilename,300);      GetXMLBuffer(strrecvbuffer,&quot;mtime&quot;,mtime,19);      GetXMLBuffer(strrecvbuffer,&quot;size&quot;,&amp;filesize);      // 客户端和服务端文件的目录是不一样的，以下代码生成客户端的文件名。      // 把文件名中的srvpath替换成clientpath，要小心第三个参数      char clientfilename[301];  memset(clientfilename,0,sizeof(clientfilename));      strcpy(clientfilename,serverfilename);      UpdateStr(clientfilename,starg.srvpath,starg.clientpath,false);      // 接收文件的内容。      logfile.Write(&quot;recv %s(%d) ...&quot;,clientfilename,filesize);      if (RecvFile(TcpClient.m_connfd,clientfilename,mtime,filesize)==true)      &#123;        logfile.WriteEx(&quot;ok.\\n&quot;);        SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;result&gt;ok&lt;/result&gt;&quot;,serverfilename);      &#125;      else      &#123;        logfile.WriteEx(&quot;failed.\\n&quot;);        SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;result&gt;failed&lt;/result&gt;&quot;,serverfilename);      &#125;      // 把接收结果返回给对端。      // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);      if (TcpClient.Write(strsendbuffer)==false)      &#123;        logfile.Write(&quot;TcpClient.Write() failed.\\n&quot;); return;      &#125;    &#125;  &#125;&#125;// 接收文件的内容。bool RecvFile(const int sockfd,const char *filename,const char *mtime,int filesize)&#123;  // 生成临时文件名。  char strfilenametmp[301];  SNPRINTF(strfilenametmp,sizeof(strfilenametmp),300,&quot;%s.tmp&quot;,filename);  int  totalbytes=0;        // 已接收文件的总字节数。  int  onread=0;            // 本次打算接收的字节数。  char buffer[1000];        // 接收文件内容的缓冲区。  FILE *fp=NULL;  // 创建临时文件。  if ( (fp=FOPEN(strfilenametmp,&quot;wb&quot;))==NULL ) return false;  while (true)  &#123;    memset(buffer,0,sizeof(buffer));    // 计算本次应该接收的字节数。    if (filesize-totalbytes&gt;1000) onread=1000;    else onread=filesize-totalbytes;    // 接收文件内容。    if (Readn(sockfd,buffer,onread)==false) &#123; fclose(fp); return false; &#125;    // 把接收到的内容写入文件。    fwrite(buffer,1,onread,fp);    // 计算已接收文件的总字节数，如果文件接收完，跳出循环。    totalbytes=totalbytes+onread;    if (totalbytes==filesize) break;  &#125;  // 关闭临时文件。  fclose(fp);  // 重置文件的时间。  UTime(strfilenametmp,mtime);  // 把临时文件RENAME为正式的文件。  if (RENAME(strfilenametmp,filename)==false) return false;  return true;&#125;\n\n\n\n\n\ntcp服务端fileserver.cpp\n/* * 程序名：fileserver.cpp，文件传输的服务端。*/#include &quot;_public.h&quot;// 程序运行的参数结构体。struct st_arg&#123;  int  clienttype;          // 客户端类型，1-上传文件；2-下载文件。  char ip[31];              // 服务端的IP地址。  int  port;                // 服务端的端口。  int  ptype;               // 文件成功传输后的处理方式：1-删除文件；2-移动到备份目录。  char clientpath[301];     // 客户端文件存放的根目录。  bool andchild;            // 是否传输各级子目录的文件，true-是；false-否。  char matchname[301];      // 待传输文件名的匹配规则，如&quot;*.TXT,*.XML&quot;。  char srvpath[301];        // 服务端文件存放的根目录。  char srvpathbak[301];     // 文件成功下载后，服务端文件备份的根目录，当ptype==2时有效。  int  timetvl;             // 扫描目录文件的时间间隔，单位：秒。  int  timeout;             // 进程心跳的超时时间。  char pname[51];           // 进程名，建议用&quot;tcpgetfiles_后缀&quot;的方式。&#125; starg;// 把xml解析到参数starg结构中。bool _xmltoarg(char *strxmlbuffer);CLogFile logfile;      // 服务程序的运行日志。CTcpServer TcpServer;  // 创建服务端对象。void FathEXIT(int sig);  // 父进程退出函数。void ChldEXIT(int sig);  // 子进程退出函数。bool ActiveTest();    // 心跳。char strrecvbuffer[1024];   // 发送报文的buffer。char strsendbuffer[1024];   // 接收报文的buffer。// 文件下载的主函数，执行一次文件下载的任务。bool _tcpputfiles();bool bcontinue=true;   // 如果调用_tcpputfiles发送了文件，bcontinue为true，初始化为true。// 把文件的内容发送给对端。bool SendFile(const int sockfd,const char *filename,const int filesize);// 删除或者转存本地的文件。bool AckMessage(const char *strrecvbuffer);// 登录业务处理函数。bool ClientLogin();// 上传文件的主函数。void RecvFilesMain();// 下载文件的主函数。void SendFilesMain();// 接收文件的内容。bool RecvFile(const int sockfd,const char *filename,const char *mtime,int filesize);CPActive PActive;  // 进程心跳。int main(int argc,char *argv[])&#123;  if (argc!=3)  &#123;    printf(&quot;Using:./fileserver port logfile\\n&quot;);    printf(&quot;Example:./fileserver 5005 /log/idc/fileserver.log\\n&quot;);     printf(&quot;         /project/tools1/bin/procctl 10 /project/tools1/bin/fileserver 5005 /log/idc/fileserver.log\\n\\n\\n&quot;);     return -1;  &#125;  // 关闭全部的信号和输入输出。  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止  CloseIOAndSignal(); signal(SIGINT,FathEXIT); signal(SIGTERM,FathEXIT);  if (logfile.Open(argv[2],&quot;a+&quot;)==false) &#123; printf(&quot;logfile.Open(%s) failed.\\n&quot;,argv[2]); return -1; &#125;  // 服务端初始化。  if (TcpServer.InitServer(atoi(argv[1]))==false)  &#123;    logfile.Write(&quot;TcpServer.InitServer(%s) failed.\\n&quot;,argv[1]); return -1;  &#125;  while (true)  &#123;    // 等待客户端的连接请求。    if (TcpServer.Accept()==false)    &#123;      logfile.Write(&quot;TcpServer.Accept() failed.\\n&quot;); FathEXIT(-1);    &#125;    logfile.Write(&quot;客户端（%s）已连接。\\n&quot;,TcpServer.GetIP());    if (fork()&gt;0) &#123; TcpServer.CloseClient(); continue; &#125;  // 父进程继续回到Accept()。       // 子进程重新设置退出信号。    signal(SIGINT,ChldEXIT); signal(SIGTERM,ChldEXIT);    TcpServer.CloseListen();    // 子进程与客户端进行通讯，处理业务。    // 处理登录客户端的登录报文。    if (ClientLogin()==false) ChldEXIT(-1);    // 如果clienttype==1，调用上传文件的主函数。    if (starg.clienttype==1) RecvFilesMain();    // 如果clienttype==2，调用下载文件的主函数。    if (starg.clienttype==2) SendFilesMain();    ChldEXIT(0);  &#125;&#125;// 父进程退出函数。void FathEXIT(int sig)  &#123;  // 以下代码是为了防止信号处理函数在执行的过程中被信号中断。  signal(SIGINT,SIG_IGN); signal(SIGTERM,SIG_IGN);  logfile.Write(&quot;父进程退出，sig=%d。\\n&quot;,sig);  TcpServer.CloseListen();    // 关闭监听的socket。  kill(0,15);     // 通知全部的子进程退出。  exit(0);&#125;// 子进程退出函数。void ChldEXIT(int sig)  &#123;  // 以下代码是为了防止信号处理函数在执行的过程中被信号中断。  signal(SIGINT,SIG_IGN); signal(SIGTERM,SIG_IGN);  logfile.Write(&quot;子进程退出，sig=%d。\\n&quot;,sig);  TcpServer.CloseClient();    // 关闭客户端的socket。  exit(0);&#125;// 登录。bool ClientLogin()&#123;  memset(strrecvbuffer,0,sizeof(strrecvbuffer));  memset(strsendbuffer,0,sizeof(strsendbuffer));  if (TcpServer.Read(strrecvbuffer,20)==false)  &#123;    logfile.Write(&quot;TcpServer.Read() failed.\\n&quot;); return false;  &#125;  logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);  // 解析客户端登录报文。  _xmltoarg(strrecvbuffer);  if ( (starg.clienttype!=1) &amp;&amp; (starg.clienttype!=2) )    strcpy(strsendbuffer,&quot;failed&quot;);  else    strcpy(strsendbuffer,&quot;ok&quot;);  if (TcpServer.Write(strsendbuffer)==false)  &#123;    logfile.Write(&quot;TcpServer.Write() failed.\\n&quot;); return false;  &#125;  logfile.Write(&quot;%s login %s.\\n&quot;,TcpServer.GetIP(),strsendbuffer);    return true;&#125;// 把xml解析到参数starg结构中bool _xmltoarg(char *strxmlbuffer)&#123;  memset(&amp;starg,0,sizeof(struct st_arg));  // 不需要对参数做合法性判断，客户端已经判断过了。  GetXMLBuffer(strxmlbuffer,&quot;clienttype&quot;,&amp;starg.clienttype);  GetXMLBuffer(strxmlbuffer,&quot;ptype&quot;,&amp;starg.ptype);  GetXMLBuffer(strxmlbuffer,&quot;clientpath&quot;,starg.clientpath);  GetXMLBuffer(strxmlbuffer,&quot;andchild&quot;,&amp;starg.andchild);  GetXMLBuffer(strxmlbuffer,&quot;matchname&quot;,starg.matchname);  GetXMLBuffer(strxmlbuffer,&quot;srvpath&quot;,starg.srvpath);  GetXMLBuffer(strxmlbuffer,&quot;srvpathbak&quot;,starg.srvpathbak);  GetXMLBuffer(strxmlbuffer,&quot;timetvl&quot;,&amp;starg.timetvl);  if (starg.timetvl&gt;30) starg.timetvl=30;  GetXMLBuffer(strxmlbuffer,&quot;timeout&quot;,&amp;starg.timeout);  if (starg.timeout&lt;50) starg.timeout=50;  GetXMLBuffer(strxmlbuffer,&quot;pname&quot;,starg.pname,50);  strcat(starg.pname,&quot;_srv&quot;);  return true;&#125;// 上传文件的主函数。void RecvFilesMain()&#123;  PActive.AddPInfo(starg.timeout,starg.pname);  while (true)  &#123;    memset(strsendbuffer,0,sizeof(strsendbuffer));    memset(strrecvbuffer,0,sizeof(strrecvbuffer));    PActive.UptATime();    // 接收客户端的报文。    // 第二个参数的取值必须大于starg.timetvl，小于starg.timeout。    if (TcpServer.Read(strrecvbuffer,starg.timetvl+10)==false)    &#123;      logfile.Write(&quot;TcpServer.Read() failed.\\n&quot;); return;    &#125;    // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);    // 处理心跳报文。    if (strcmp(strrecvbuffer,&quot;&lt;activetest&gt;ok&lt;/activetest&gt;&quot;)==0)    &#123;      strcpy(strsendbuffer,&quot;ok&quot;);      // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);      if (TcpServer.Write(strsendbuffer)==false)      &#123;        logfile.Write(&quot;TcpServer.Write() failed.\\n&quot;); return;      &#125;    &#125;    // 处理上传文件的请求报文。    if (strncmp(strrecvbuffer,&quot;&lt;filename&gt;&quot;,10)==0)    &#123;      // 解析上传文件请求报文的xml。      char clientfilename[301];  memset(clientfilename,0,sizeof(clientfilename));      char mtime[21];            memset(mtime,0,sizeof(mtime));      int  filesize=0;      GetXMLBuffer(strrecvbuffer,&quot;filename&quot;,clientfilename,300);      GetXMLBuffer(strrecvbuffer,&quot;mtime&quot;,mtime,19);      GetXMLBuffer(strrecvbuffer,&quot;size&quot;,&amp;filesize);      // 客户端和服务端文件的目录是不一样的，以下代码生成服务端的文件名。      // 把文件名中的clientpath替换成srvpath，要小心第三个参数      char serverfilename[301];  memset(serverfilename,0,sizeof(serverfilename));      strcpy(serverfilename,clientfilename);      UpdateStr(serverfilename,starg.clientpath,starg.srvpath,false);      // 接收文件的内容。      logfile.Write(&quot;recv %s(%d) ...&quot;,serverfilename,filesize);      if (RecvFile(TcpServer.m_connfd,serverfilename,mtime,filesize)==true)      &#123;        logfile.WriteEx(&quot;ok.\\n&quot;);        SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;result&gt;ok&lt;/result&gt;&quot;,clientfilename);      &#125;      else      &#123;        logfile.WriteEx(&quot;failed.\\n&quot;);        SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;result&gt;failed&lt;/result&gt;&quot;,clientfilename);      &#125;      // 把接收结果返回给对端。      // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);      if (TcpServer.Write(strsendbuffer)==false)      &#123;        logfile.Write(&quot;TcpServer.Write() failed.\\n&quot;); return;      &#125;    &#125;  &#125;&#125;// 接收文件的内容。bool RecvFile(const int sockfd,const char *filename,const char *mtime,int filesize)&#123;  // 生成临时文件名。  char strfilenametmp[301];  SNPRINTF(strfilenametmp,sizeof(strfilenametmp),300,&quot;%s.tmp&quot;,filename);  int  totalbytes=0;        // 已接收文件的总字节数。  int  onread=0;            // 本次打算接收的字节数。  char buffer[1000];        // 接收文件内容的缓冲区。  FILE *fp=NULL;  // 创建临时文件。  if ( (fp=FOPEN(strfilenametmp,&quot;wb&quot;))==NULL ) return false;  while (true)  &#123;    memset(buffer,0,sizeof(buffer));    // 计算本次应该接收的字节数。    if (filesize-totalbytes&gt;1000) onread=1000;    else onread=filesize-totalbytes;    // 接收文件内容。    if (Readn(sockfd,buffer,onread)==false) &#123; fclose(fp); return false; &#125;    // 把接收到的内容写入文件。    fwrite(buffer,1,onread,fp);    // 计算已接收文件的总字节数，如果文件接收完，跳出循环。    totalbytes=totalbytes+onread;    if (totalbytes==filesize) break;  &#125;  // 关闭临时文件。  fclose(fp);  // 重置文件的时间。  UTime(strfilenametmp,mtime);  // 把临时文件RENAME为正式的文件。  if (RENAME(strfilenametmp,filename)==false) return false;  return true;&#125;// 下载文件的主函数。void SendFilesMain()&#123;  PActive.AddPInfo(starg.timeout,starg.pname);  while (true)  &#123;    // 调用文件下载的主函数，执行一次文件下载的任务。    if (_tcpputfiles()==false) &#123; logfile.Write(&quot;_tcpputfiles() failed.\\n&quot;); return; &#125;    if (bcontinue==false)    &#123;      sleep(starg.timetvl);      if (ActiveTest()==false) break;    &#125;    PActive.UptATime();  &#125;&#125;// 心跳。bool ActiveTest()&#123;  memset(strsendbuffer,0,sizeof(strsendbuffer));  memset(strrecvbuffer,0,sizeof(strrecvbuffer));  SPRINTF(strsendbuffer,sizeof(strsendbuffer),&quot;&lt;activetest&gt;ok&lt;/activetest&gt;&quot;);  // logfile.Write(&quot;发送：%s\\n&quot;,strsendbuffer);  if (TcpServer.Write(strsendbuffer)==false) return false; // 向服务端发送请求报文。  if (TcpServer.Read(strrecvbuffer,20)==false) return false; // 接收服务端的回应报文。  // logfile.Write(&quot;接收：%s\\n&quot;,strrecvbuffer);  return true;&#125;// 文件下载的主函数，执行一次文件下载的任务。bool _tcpputfiles()&#123;  CDir Dir;  // 调用OpenDir()打开starg.srvpath目录。  if (Dir.OpenDir(starg.srvpath,starg.matchname,10000,starg.andchild)==false)  &#123;    logfile.Write(&quot;Dir.OpenDir(%s) 失败。\\n&quot;,starg.srvpath); return false;  &#125;  int delayed=0;        // 未收到对端确认报文的文件数量。  int buflen=0;         // 用于存放strrecvbuffer的长度。  bcontinue=false;  while (true)  &#123;    memset(strsendbuffer,0,sizeof(strsendbuffer));    memset(strrecvbuffer,0,sizeof(strrecvbuffer));    // 遍历目录中的每个文件，调用ReadDir()获取一个文件名。    if (Dir.ReadDir()==false) break;    bcontinue=true;    // 把文件名、修改时间、文件大小组成报文，发送给对端。    SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;&lt;size&gt;%d&lt;/size&gt;&quot;,Dir.m_FullFileName,Dir.m_ModifyTime,Dir.m_FileSize);    // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);    if (TcpServer.Write(strsendbuffer)==false)    &#123;      logfile.Write(&quot;TcpServer.Write() failed.\\n&quot;); return false;    &#125;    // 把文件的内容发送给对端。    logfile.Write(&quot;send %s(%d) ...&quot;,Dir.m_FullFileName,Dir.m_FileSize);    if (SendFile(TcpServer.m_connfd,Dir.m_FullFileName,Dir.m_FileSize)==true)    &#123;      logfile.WriteEx(&quot;ok.\\n&quot;); delayed++;    &#125;    else    &#123;      logfile.WriteEx(&quot;failed.\\n&quot;); TcpServer.CloseClient(); return false;    &#125;    PActive.UptATime();    // 接收对端的确认报文。    while (delayed&gt;0)    &#123;      memset(strrecvbuffer,0,sizeof(strrecvbuffer));      if (TcpRead(TcpServer.m_connfd,strrecvbuffer,&amp;buflen,-1)==false) break;      // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);      // 删除或者转存本地的文件。      delayed--;      AckMessage(strrecvbuffer);    &#125;  &#125;  // 继续接收对端的确认报文。  while (delayed&gt;0)  &#123;    memset(strrecvbuffer,0,sizeof(strrecvbuffer));    if (TcpRead(TcpServer.m_connfd,strrecvbuffer,&amp;buflen,10)==false) break;    // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);    // 删除或者转存本地的文件。    delayed--;    AckMessage(strrecvbuffer);  &#125;  return true;&#125;// 把文件的内容发送给对端。bool SendFile(const int sockfd,const char *filename,const int filesize)&#123;  int  onread=0;        // 每次调用fread时打算读取的字节数。  int  bytes=0;         // 调用一次fread从文件中读取的字节数。  char buffer[1000];    // 存放读取数据的buffer。  int  totalbytes=0;    // 从文件中已读取的字节总数。  FILE *fp=NULL;  // 以&quot;rb&quot;的模式打开文件。  if ( (fp=fopen(filename,&quot;rb&quot;))==NULL )  return false;  while (true)  &#123;    memset(buffer,0,sizeof(buffer));    // 计算本次应该读取的字节数，如果剩余的数据超过1000字节，就打算读1000字节。    if (filesize-totalbytes&gt;1000) onread=1000;    else onread=filesize-totalbytes;    // 从文件中读取数据。    bytes=fread(buffer,1,onread,fp);    // 把读取到的数据发送给对端。    if (bytes&gt;0)    &#123;      if (Writen(sockfd,buffer,bytes)==false) &#123; fclose(fp); return false; &#125;    &#125;    // 计算文件已读取的字节总数，如果文件已读完，跳出循环。    totalbytes=totalbytes+bytes;    if (totalbytes==filesize) break;  &#125;  fclose(fp);  return true;&#125;// 删除或者转存本地的文件。bool AckMessage(const char *strrecvbuffer)&#123;  char filename[301];  char result[11];  memset(filename,0,sizeof(filename));  memset(result,0,sizeof(result));  GetXMLBuffer(strrecvbuffer,&quot;filename&quot;,filename,300);  GetXMLBuffer(strrecvbuffer,&quot;result&quot;,result,10);  // 如果服务端接收文件不成功，直接返回。  if (strcmp(result,&quot;ok&quot;)!=0) return true;  // ptype==1，删除文件。  if (starg.ptype==1)  &#123;    if (REMOVE(filename)==false) &#123; logfile.Write(&quot;REMOVE(%s) failed.\\n&quot;,filename); return false; &#125;  &#125;  // ptype==2，移动到备份目录。  if (starg.ptype==2)  &#123;    // 生成转存后的备份目录文件名。    char bakfilename[301];    STRCPY(bakfilename,sizeof(bakfilename),filename);    UpdateStr(bakfilename,starg.srvpath,starg.srvpathbak,false);    if (RENAME(filename,bakfilename)==false)    &#123; logfile.Write(&quot;RENAME(%s,%s) failed.\\n&quot;,filename,bakfilename); return false; &#125;  &#125;  return true;&#125;\n\n\n\n\n\ntcp编译makefile\n# 开发框架头文件路径。PUBINCL = -I/project/public# 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。PUBCPP = /project/public/_public.cpp# 编译参数。CFLAGS = -gall:tcpputfiles fileserver tcpgetfiles tcpputfiles:tcpputfiles.cpp\tg++ $(CFLAGS) -o tcpputfiles tcpputfiles.cpp $(PUBINCL) $(PUBCPP) -lm -lc\tcp tcpputfiles ../bin/.fileserver:fileserver.cpp\tg++ $(CFLAGS) -o fileserver fileserver.cpp $(PUBINCL) $(PUBCPP) -lm -lc\tcp fileserver ../bin/.tcpgetfiles:tcpgetfiles.cpp\tg++ $(CFLAGS) -o tcpgetfiles tcpgetfiles.cpp $(PUBINCL) $(PUBCPP) -lm -lc\tcp tcpgetfiles ../bin/.clean:\trm -f tcpputfiles fileserver tcpgetfiles \n\nmysql数据库开发查看修改数据库字符集mysql -u root -pSHOW VARIABLES LIKE &#x27;character%&#x27;;quitvi /etc/my.cnf[mysqld]character-set-server=utf8 [client]default-character-set=utf8\n\nA. 查看修改数据库的字符集方式-- database_name 为数据库名称SHOW CREATE DATABASE database_name;-- database_name 为数据库名称-- utf8为目标字符编码ALTER DATABSE database_name DEFAULT CHARACTER SET utf8;\n\nB. 查看修改表的字符集方式-- table_name为表的名称SHOW CREATE TABLE table_name;-- table_name为表的名称-- utf8为目标字符编码ALTER TABLE table_name DEFAULT CHARACTER SET utf8;\n\nC. 查看字段的字符集方式-- column_name为字段名称SHOW FULL COLUMNS FROM column_name;-- table_name为表的名称-- column_name为字段名称-- varchar(20)为字段的类型-- utf8为目标字符集ALTER TABLE table_name CHANGE column_name column_name VARCHAR(20) CHARACTER SET utf8;\n\nD. 同时修改表和表中所有字符类型的字段字符集方式-- 例子：alter table user2 convert to character set utf8 collate utf8_general_ci;ALTER TABLE tbl_name CONVERT TO CHARACTER SET character_name [COLLATE ...]\n\n创建表createtable.cpp\n/* *  程序名：createtable.cpp，此程序演示开发框架操作MySQL数据库（创建表）。*/#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。int main(int argc,char *argv[])&#123;  connection conn;   // 数据库连接类。  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)  &#123;    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;  &#125;    sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。  // 准备创建表的SQL语句。  // 超女表girls，超女编号id，超女姓名name，体重weight，报名时间btime，超女说明memo，超女图片pic。  stmt.prepare(&quot;create table girls(id      bigint(10),\\                   name    varchar(30),\\                   weight  decimal(8,2),\\                   btime   datetime,\\                   memo    longtext,\\                   pic     longblob,\\                   primary key (id))&quot;);  /*  1、int prepare(const char *fmt,...)，SQL语句可以多行书写。  2、SQL语句最后的分号可有可无，建议不要写（兼容性考虑）。  3、SQL语句中不能有说明文字。  4、可以不用判断stmt.prepare()的返回值，stmt.execute()时再判断。  */  // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。  // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。  if (stmt.execute()!=0)  &#123;    printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;  &#125;  printf(&quot;create table girls ok.\\n&quot;);  return 0;&#125;/*-- 超女基本信息表。create table girls(id      bigint(10),    -- 超女编号。                   name    varchar(30),   -- 超女姓名。                   weight  decimal(8,2),  -- 超女体重。                   btime   datetime,      -- 报名时间。                   memo    longtext,      -- 备注。                   pic     longblob,      -- 照片。                   primary key (id));*/\n\n\n\n插入数据inserttable.cpp\n/* *  程序名：inserttable.cpp，此程序演示开发框架操作MySQL数据库（向表中插入5条记录）。*/#include &lt;unistd.h&gt;#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。int main(int argc,char *argv[])&#123;  connection conn;   // 数据库连接类。  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)  &#123;    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;  &#125;  // 定义用于超女信息的结构，与表中的字段对应。  struct st_girls  &#123;    long   id;        // 超女编号    char   name[31];  // 超女姓名    double weight;    // 超女体重    char   btime[20]; // 报名时间  &#125; stgirls;  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。  // 准备插入表的SQL语句。  stmt.prepare(&quot;\\    insert into girls(id,name,weight,btime) values(:1+1,:2,:3+45.35,str_to_date(:4,&#x27;%%Y-%%m-%%d %%H:%%i:%%s&#x27;))&quot;);    //insert into girls(id,name,weight,btime) values(?+1,?,?+45.35,to_date(?,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;))&quot;);  /*    注意事项：    1、参数的序号从1开始，连续、递增，参数也可以用问号表示，但是，问号的兼容性不好，不建议；    2、SQL语句中的右值才能作为参数，表名、字段名、关键字、函数名等都不能作为参数；    3、参数可以参与运算或用于函数的参数；    4、如果SQL语句的主体没有改变，只需要prepare()一次就可以了；    5、SQL语句中的每个参数，必须调用bindin()绑定变量的地址；    6、如果SQL语句的主体已改变，prepare()后，需重新用bindin()绑定变量；    7、prepare()方法有返回值，一般不检查，如果SQL语句有问题，调用execute()方法时能发现；    8、bindin()方法的返回值固定为0，不用判断返回值；    9、prepare()和bindin()之后，每调用一次execute()，就执行一次SQL语句，SQL语句的数据来自被绑定变量的值。  */  stmt.bindin(1,&amp;stgirls.id);  stmt.bindin(2, stgirls.name,30);  stmt.bindin(3,&amp;stgirls.weight);  stmt.bindin(4, stgirls.btime,19);  // 模拟超女数据，向表中插入5条测试数据。  for (int ii=0;ii&lt;5;ii++)  &#123;    memset(&amp;stgirls,0,sizeof(struct st_girls));         // 结构体变量初始化。    // 为结构体变量的成员赋值。    stgirls.id=ii;                                     // 超女编号。    sprintf(stgirls.name,&quot;西施%05dgirl&quot;,ii+1);         // 超女姓名。    stgirls.weight=ii;                                 // 超女体重。    sprintf(stgirls.btime,&quot;2021-08-25 10:33:%02d&quot;,ii); // 报名时间。     // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。    // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。    if (stmt.execute()!=0)    &#123;      printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;    &#125;    printf(&quot;成功插入了%ld条记录。\\n&quot;,stmt.m_cda.rpc); // stmt.m_cda.rpc是本次执行SQL影响的记录数。  &#125;  printf(&quot;insert table girls ok.\\n&quot;);  conn.commit();   // 提交数据库事务。  return 0;&#125;\n\n修改数据updatetable.cpp\n/* *  程序名：updatetable.cpp，此程序演示开发框架操作MySQL数据库（修改表中的记录）。*/#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。int main(int argc,char *argv[])&#123;  connection conn;   // 数据库连接类。  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)  &#123;    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;  &#125;  // 定义用于超女信息的结构，与表中的字段对应。  struct st_girls  &#123;    long   id;        // 超女编号    char   name[31];  // 超女姓名    double weight;    // 超女体重    char   btime[20]; // 报名时间  &#125; stgirls;  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。  // 准备修改表的SQL语句。  stmt.prepare(&quot;\\    update girls set name=:1,weight=:2,btime=str_to_date(:3,&#x27;%%Y-%%m-%%d %%H:%%i:%%s&#x27;) where id=:4&quot;);  /*    注意事项：    1、参数的序号从1开始，连续、递增，参数也可以用问号表示，但是，问号的兼容性不好，不建议；    2、SQL语句中的右值才能作为参数，表名、字段名、关键字、函数名等都不能作为参数；    3、参数可以参与运算或用于函数的参数；    4、如果SQL语句的主体没有改变，只需要prepare()一次就可以了；    5、SQL语句中的每个参数，必须调用bindin()绑定变量的地址；    6、如果SQL语句的主体已改变，prepare()后，需重新用bindin()绑定变量；    7、prepare()方法有返回值，一般不检查，如果SQL语句有问题，调用execute()方法时能发现；    8、bindin()方法的返回值固定为0，不用判断返回值；    9、prepare()和bindin()之后，每调用一次execute()，就执行一次SQL语句，SQL语句的数据来自被绑定变量的值。  */  stmt.bindin(1, stgirls.name,30);  stmt.bindin(2,&amp;stgirls.weight);  stmt.bindin(3, stgirls.btime,19);  stmt.bindin(4,&amp;stgirls.id);  // 模拟超女数据，修改超女信息表中的全部记录。  for (int ii=0;ii&lt;5;ii++)  &#123;    memset(&amp;stgirls,0,sizeof(struct st_girls));         // 结构体变量初始化。    // 为结构体变量的成员赋值。    stgirls.id=ii+1;                                   // 超女编号。    sprintf(stgirls.name,&quot;貂蝉%05dgirl&quot;,ii+1);         // 超女姓名。    stgirls.weight=ii+48.39;                           // 超女体重。    sprintf(stgirls.btime,&quot;2021-10-02 11:25:%02d&quot;,ii); // 报名时间。     // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。    // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。    if (stmt.execute()!=0)    &#123;      printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;    &#125;    printf(&quot;成功修改了%ld条记录。\\n&quot;,stmt.m_cda.rpc); // stmt.m_cda.rpc是本次执行SQL影响的记录数。  &#125;  printf(&quot;update table girls ok.\\n&quot;);  conn.commit();   // 提交数据库事务。  return 0;&#125;\n\n\n\n查询数据selecttable.cpp\n/* *  程序名：selecttable.cpp，此程序演示开发框架操作MySQL数据库（查询表中的记录）。*/#include &lt;unistd.h&gt;#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。int main(int argc,char *argv[])&#123;  connection conn;   // 数据库连接类。  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)  &#123;    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;  &#125;  // 定义用于超女信息的结构，与表中的字段对应。  struct st_girls  &#123;    long   id;        // 超女编号    char   name[31];  // 超女姓名    double weight;    // 超女体重    char   btime[20]; // 报名时间  &#125; stgirls;  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。  int iminid,imaxid;  // 查询条件最小和最大的id。  // 准备查询表的SQL语句。  stmt.prepare(&quot;\\    select id,name,weight,date_format(btime,&#x27;%%Y-%%m-%%d %%H:%%i:%%s&#x27;) from girls where id&gt;=:1 and id&lt;=:2&quot;);  /*    注意事项：    1、如果SQL语句的主体没有改变，只需要prepare()一次就可以了；    2、结果集中的字段，调用bindout()绑定变量的地址；    3、bindout()方法的返回值固定为0，不用判断返回值；    4、如果SQL语句的主体已改变，prepare()后，需重新用bindout()绑定变量；    5、调用execute()方法执行SQL语句，然后再循环调用next()方法获取结果集中的记录；    6、每调用一次next()方法，从结果集中获取一条记录，字段内容保存在已绑定的变量中。  */  // 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。  stmt.bindin(1,&amp;iminid);  stmt.bindin(2,&amp;imaxid);  // 为SQL语句绑定输出变量的地址，bindout方法不需要判断返回值。  stmt.bindout(1,&amp;stgirls.id);  stmt.bindout(2, stgirls.name,30);  stmt.bindout(3,&amp;stgirls.weight);  stmt.bindout(4, stgirls.btime,19);  iminid=1;    // 指定待查询记录的最小id的值。  imaxid=3;    // 指定待查询记录的最大id的值。  // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。  // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。  if (stmt.execute() != 0)  &#123;    printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;  &#125;  // 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。  while (true)  &#123;    memset(&amp;stgirls,0,sizeof(struct st_girls));         // 结构体变量初始化。    // 从结果集中获取一条记录，一定要判断返回值，0-成功，1403-无记录，其它-失败。    // 在实际开发中，除了0和1403，其它的情况极少出现。    if (stmt.next()!=0) break;    // 把获取到的记录的值打印出来。    printf(&quot;id=%ld,name=%s,weight=%.02f,btime=%s\\n&quot;,stgirls.id,stgirls.name,stgirls.weight,stgirls.btime);  &#125;  // 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。  printf(&quot;本次查询了girls表%ld条记录。\\n&quot;,stmt.m_cda.rpc);  return 0;&#125;\n\n\n\n删除数据deletetable.cpp\n/* *  程序名：deletetable.cpp，此程序演示开发框架操作MySQL数据库（删除表中的记录）。*/#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。int main(int argc,char *argv[])&#123;  connection conn;   // 数据库连接类。  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)  &#123;    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;  &#125;  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。  int iminid,imaxid;  // 删除条件最小和最大的id。  // 准备删除表的SQL语句。  stmt.prepare(&quot;delete from girls where id&gt;=:1 and id&lt;=:2&quot;);  // 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。  stmt.bindin(1,&amp;iminid);  stmt.bindin(2,&amp;imaxid);  iminid=1;    // 指定待删除记录的最小id的值。  imaxid=3;    // 指定待删除记录的最大id的值。  // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。  // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。  if (stmt.execute() != 0)  &#123;    printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;  &#125;  // 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。  printf(&quot;本次删除了girls表%ld条记录。\\n&quot;,stmt.m_cda.rpc);  conn.commit();   // 提交数据库事务。  return 0;&#125;\n\n二进制大对象存放filetoblob.cpp\n/* *  程序名：filetoblob.cpp，此程序演示开发框架操作MySQL数据库（把图片文件存入BLOB字段）。*/#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。int main(int argc,char *argv[])&#123;  connection conn;   // 数据库连接类。  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)  &#123;    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;  &#125;  // 定义用于超女信息的结构，与表中的字段对应。  struct st_girls  &#123;    long   id;             // 超女编号    char   pic[100000];    // 超女图片的内容。    unsigned long picsize; // 图片内容占用的字节数。  &#125; stgirls;  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。  // 准备修改表的SQL语句。  stmt.prepare(&quot;update girls set pic=:1 where id=:2&quot;);  stmt.bindinlob(1, stgirls.pic,&amp;stgirls.picsize);  stmt.bindin(2,&amp;stgirls.id);  // 修改超女信息表中id为1、2的记录。  for (int ii=1;ii&lt;3;ii++)  &#123;    memset(&amp;stgirls,0,sizeof(struct st_girls));         // 结构体变量初始化。    // 为结构体变量的成员赋值。    stgirls.id=ii;                                   // 超女编号。    // 把图片的内容加载到stgirls.pic中。    if (ii==1) stgirls.picsize=filetobuf(&quot;1.jpg&quot;,stgirls.pic);    if (ii==2) stgirls.picsize=filetobuf(&quot;2.jpg&quot;,stgirls.pic);    // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。    // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。    if (stmt.execute()!=0)    &#123;      printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;    &#125;    printf(&quot;成功修改了%ld条记录。\\n&quot;,stmt.m_cda.rpc); // stmt.m_cda.rpc是本次执行SQL影响的记录数。  &#125;  printf(&quot;update table girls ok.\\n&quot;);  conn.commit();   // 提交数据库事务。  return 0;&#125;\n\n二进制大对象抽取blobtofile.cpp\n/* *  程序名：blobtofile.cpp，此程序演示开发框架操作MySQL数据库（提取BLOB字段内容到图片文件中）。*/#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。int main(int argc,char *argv[])&#123;  connection conn;   // 数据库连接类。  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)  &#123;    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;  &#125;  // 定义用于超女信息的结构，与表中的字段对应。  struct st_girls  &#123;    long   id;             // 超女编号    char   pic[100000];    // 超女图片的内容。    unsigned long picsize; // 图片内容占用的字节数。  &#125; stgirls;  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。  // 准备查询表的SQL语句。  stmt.prepare(&quot;select id,pic from girls where id in (1,2)&quot;);  stmt.bindout(1,&amp;stgirls.id);  stmt.bindoutlob(2, stgirls.pic,100000,&amp;stgirls.picsize);  // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。  // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。  if (stmt.execute()!=0)  &#123;    printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;  &#125;  // 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。  while (true)  &#123;    memset(&amp;stgirls,0,sizeof(stgirls)); // 先把结构体变量初始化。    // 从结果集中获取一条记录，一定要判断返回值，0-成功，1403-无记录，其它-失败。    // 在实际开发中，除了0和1403，其它的情况极少出现。    if (stmt.next()!=0) break;    // 生成文件名。    char filename[101]; memset(filename,0,sizeof(filename));    sprintf(filename,&quot;%d_out.jpg&quot;,stgirls.id);        // 把内容写入文件。    buftofile(filename,stgirls.pic,stgirls.picsize);  &#125;  // 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。  printf(&quot;本次查询了girls表%ld条记录。\\n&quot;,stmt.m_cda.rpc);  return 0;&#125;\n\n\n\n编译文件makefile\n# mysql头文件存放的目录。locate mysql.hMYSQLINCL = -I/usr/include/mysql# mysql库文件存放的目录。locate libmysqlclient.aMYSQLLIB = -L/usr/lib64/mysql#_mysql.h _mysql.cpp在当前文件夹# 需要链接的mysql库。MYSQLLIBS = -lmysqlclientCFLAGS=-g -Wno-write-stringsall:createtable  inserttable updatetable selecttable deletetable filetoblob blobtofile book1 book2createtable:createtable.cpp _mysql.h _mysql.cpp\tg++ $(CFLAGS) -o createtable createtable.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lcinserttable:inserttable.cpp _mysql.h _mysql.cpp\tg++ $(CFLAGS) -o inserttable inserttable.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lcupdatetable:updatetable.cpp _mysql.h _mysql.cpp\tg++ $(CFLAGS) -o updatetable updatetable.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lcselecttable:selecttable.cpp _mysql.h _mysql.cpp\tg++ $(CFLAGS) -o selecttable selecttable.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lcdeletetable:deletetable.cpp _mysql.h _mysql.cpp\tg++ $(CFLAGS) -o deletetable deletetable.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lcfiletoblob:filetoblob.cpp _mysql.h _mysql.cpp\tg++ $(CFLAGS) -o filetoblob filetoblob.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lcblobtofile:blobtofile.cpp _mysql.h _mysql.cpp\tg++ $(CFLAGS) -o blobtofile blobtofile.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lcbook1:book1.cpp _mysql.h _mysql.cpp\tg++ $(CFLAGS) -o book1 book1.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lcbook2:book2.cpp _mysql.h _mysql.cpp\tg++ $(CFLAGS) -o book2 book2.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lcclean:\trm -rf createtable  inserttable updatetable selecttable deletetable filetoblob blobtofile book1 book2\n\n\n\n","slug":"cpp开发","date":"2022-07-29T16:00:00.000Z","categories_index":"开发经验","tags_index":"C++","author_index":"暗使开开"},{"id":"293c17b4d2a4292133cc4d1ffd7f8725","title":"计算机网络","content":"超五类网线接法橙白，橙，绿白，蓝，蓝白，绿，棕白，棕\nVPN核心功能：用于建立安全的远程访问或在不同地点的网络之间建立加密通信。VPN（Virtual Private Network，虚拟专用网络）点对点传输则是一种特定的网络技术，用于通过公共网络安全地传输数据。使用多种协议，如IPsec、SSL&#x2F;TLS、PPTP等，以提供不同层次的安全性。可以用于连接整个网络，将远程用户或分支机构安全地连接到公司内部网络。\n注意使用VP实需要至少一方拥有公网IP地址。因为VPN通常在互联网上建立安全连接，而公网IP地址是用于在全球范围内唯一标识设备的地址。有两种主要的VPN连接方式，分别是站点到站点（Site-to-Site）VPN和远程访问（Remote Access）VPN。\n\n站点到站点（Site-to-Site）VPN：\n\n在站点到站点的VPN连接中，两个网络或两个路由器之间建立安全连接。\n至少一方需要有公网IP地址，以便另一方能够访问它并建立VPN隧道。\n这种情况通常适用于不同地理位置的分支机构或公司总部之间的安全连接。\n\n\n远程访问（Remote Access）VPN：\n\n在远程访问VPN中，个人设备（例如笔记本电脑、智能手机）通过互联网连接到公司网络。\n公司网络端通常需要有一个公网IP地址，以便远程用户能够建立到公司网络的VPN连接。\n这种情况适用于员工在外部地点需要安全地访问公司网络资源的场景。\n\n\n\nSSH核心功能：用于通过加密的连接远程访问和管理服务器。使用SSH协议，主要运行在应用层，提供终端访问和文件传输等功能。主要用于远程登录和执行命令，通常连接到单个服务器。\nDHCP核心功能：动态自动配置主机ip mask gw dns\nIDC核心功能：部署网络服务，是互联网数据中心，简单来说就是服务器机房\neMMCeMMC 将 NAND 闪存、控制器和高速MMC（MultiMediaCard）接口集成到一个小型的封装中，提供了一种紧凑、低功耗的存储解决方案。\nUPNP核心功能：端口映射\n通用即插即用（Universal Plug and Play）的缩写，是一种网络协议和架构，旨在使各种设备能够自动发现、配置和通信，以实现简化的设备间互操作性。\nCDN核心功能：内容分发网络，实现访问分流到最优服务器\nPCDN核心功能：内容分发网络，但是是p2p的CDN，人人为我，我为人人，但是严重影响资本利益\nDNS核心功能：映射域名ip\n\n\n\n记得ping一下\n谷歌好用点（个人主观）国内用不了用百度\n\n\n\n微软\n4.2.2.2\n\n\n谷歌\n8.8.8.8\n\n\n阿里云\n233.6.6.6\n\n\n百度\n180.76.76.76\n\n\n腾讯\n119.29.29.29\n\n\n电信\n101.226.4.6\n\n\n联通\n123.125.81.6\n\n\n移动\n101.226.4.6\n\n\n铁通\n101.226.4.6\n\n\ncloudflare\n1.1.1.1\n\n\n网关核心功能：数据采集管理\n主要工业化场所，协议转换器，数据重新打包，多方式传递数据\n路由器核心功能：用来拨号上网\n无线路由器相当于交换机+路由+ap的组合，可以拨号上网+拓展有线网口+提供wifi信号\nAC+AP核心功能：增加wifi信号覆盖面积\naccess control + access point\n面积大使用，ap就是一个信号发射器，优点是信号无缝，属于同一个网络，可以通过AC管理配置网络，缺点太贵，需要poe交换机，poe交换机可以通过网线给ap供电\n交换机核心功能：拓展有线网口\n网管交换机：可以通过后台，命令行等配置网络\n非网管交换机：傻瓜式交换机，就是单纯拓展网口\npoe交换机：提供供电的非网管交换机\nVLAN交换机：单线复用，实现有线回程mesh\nFTTR简单来说就是每个屋子放一个光猫，入户是主光猫，其他是从光猫\nMesh组网简单来说就是每个屋子放一个支持mesh同品牌路由器\n入户是主光猫，光电信号转换后连上主路由WAN口，然后主路由LAN口连接其他路由的WAN口，其他是从路由\n","slug":"计算机网络","date":"2022-07-29T16:00:00.000Z","categories_index":"计网","tags_index":"","author_index":"暗使开开"},{"id":"75d33a392d03942d61d72e896069198e","title":"VScode","content":"VScodeMacvscode开发flutter\n安装插件：Flutter Snippets：实现自动补全\n\nfcol：创建一个Column Widget\n\nfcont：创建一个Container Widget\n\nfrow：创建一个Row Widget\n\nftxt：创建一个Text Widget\n\n快速创建Widget：在dart文件中输入stf或stl出现提示后按回车键\n\n快速修复：command + .\n\n自动生成构造函数：选中final参数，快捷键command + .\n\n添加父组件、变成子组件、删除子组件：command + .\n\n重新打开 关闭的编辑页面：Command + shift +T\n\n通过匹配文本打开文件：command + T\n\n代码格式化：shift+option+F\n\n打开console：command+3\n\n查看源码：长按command 点击方法名类名\n\n查看类的子类：选中要查看的类，然后command+F12\n\n后退：当跟踪代码的时候经常跳到其它类，后退：ctrl + -\n\n导入类的快捷键：把光标放在要导入的类上，然后按command + -\n\n全局搜索：command + shift + F\n\n当前行代码交换位置：option + 上&#x2F;下\n\n快速复制当前行：option + shift + 下\n\n\ncmd：\nflutter run\nflutter run -d 设备id\nq:终止运行\nc:清除屏幕\nr:热重载\ncommand+k：清除终端输出的信息\nflutter clean：清理缓存，可用于更改代码后运行有些异常的处理方式\nflutter –version：查看flutter版本\n问题解决vscode编译 不允许使用与号(&amp;)不允许使用与号(&amp;)。&amp; 运算符是为将来使用而保留的；请用双引号将与号引起来(“&amp;”)，以将其作为字符串的一部分传递。\n原因：vscode终端（terminal）默认是powershell，vscode在powershell中输入指令时会出现某种我无法理解的问题\n解决方法：将默认终端设置为cmd\n\n点击Select Default Profile\n\n选择Command Prompt\n\n\n","slug":"vscode","date":"2021-08-29T15:02:22.000Z","categories_index":"","tags_index":"","author_index":"暗使开开"},{"id":"4df92e277050af68278af1388258011f","title":"C++高并发解决方案","content":"C++高并发解决方案\nTCP+多线程 对服务器性能要求比较高\n\nselect（是一个文件描述符（fd）的集合，一个文件描述符对应一个客户端）对服务器性能要求比较低，是单线程在循环，并发量有限，处理效率低（循环遍历整合集合）\n\nepoll 理论上并发量无限，处理效率较高，不用遍历整个事件，有事件发生时直接跳过去（epoll_event结构体）集合\n\nepoll+多线程 频繁启动线程浪费时间\n\nepoll+线程池\n\nlibevent（bufferevent的集合，每个bufferevent对应一个客户端）\n\nlibevent+多线程（和epoll+多线程不同，它不允许由多个线程来操作这个集合）\n\n\n","slug":"cpp高并发解决方案","date":"2021-07-30T03:48:58.000Z","categories_index":"","tags_index":"","author_index":"暗使开开"},{"id":"70bdb136fcc9be9f5265bb4b276d5137","title":"阿里云服务器漏洞","content":"阿里云服务器漏洞\nRHSA-2022:0274: polkit pkexec 本地提权漏洞（CVE-2021-4034）\nyum update -y polkit或者chmod 0755 /usr/bin/pkexec\n\n","slug":"阿里云服务器漏洞","date":"2021-05-14T16:00:00.000Z","categories_index":"","tags_index":"开发经验","author_index":"暗使开开"},{"id":"d9dac0651d88133d91d5d44b27ff2c44","title":"logo","content":"𝗔𝗺𝗦𝗵𝗮𝗱𝗼𝘄 +𝗔𝗻. 𝗘𝗻𝘃𝗼𝘆 +","slug":"anenvoy","date":"2019-02-05T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"暗使开开"}]