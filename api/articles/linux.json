{"title":"Linux","uid":"3fe1ee3f3830128bf539e5f4ed9fbbe9","slug":"linux","date":"2024-07-30T07:18:43.000Z","updated":"2024-07-30T07:20:50.449Z","comments":true,"path":"api/articles/linux.json","keywords":null,"cover":[],"content":"<h1 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h1><h2 id=\"知识\"><a href=\"#知识\" class=\"headerlink\" title=\"知识\"></a>知识</h2><p>centos漏洞<br>yum clean all &amp;&amp; yum makecache<br>yum update polkit -y</p>\n<h3 id=\"shell编程\"><a href=\"#shell编程\" class=\"headerlink\" title=\"shell编程\"></a>shell编程</h3><h4 id=\"shell脚本\"><a href=\"#shell脚本\" class=\"headerlink\" title=\"shell脚本\"></a>shell脚本</h4><ul>\n<li><p>开头，以什么shell执行 &#x2F;bash</p>\n<p>#!&#x2F;bin&#x2F;bash</p>\n</li>\n<li><p>执行</p>\n<ul>\n<li><p>chmod u+x</p>\n<p>.&#x2F;xxx.sh</p>\n</li>\n<li><p>sh xxx.sh</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"输出echo\"><a href=\"#输出echo\" class=\"headerlink\" title=\"输出echo\"></a>输出echo</h4><p>echo xxx</p>\n<p>echo “xxx”</p>\n<p>echo xxx&#x3D;$变量名</p>\n<h4 id=\"系统变量\"><a href=\"#系统变量\" class=\"headerlink\" title=\"系统变量\"></a>系统变量</h4><ul>\n<li><p>HOME $PWD $SHELL $USER等</p>\n</li>\n<li><p>显示当前shell中所有变量 set</p>\n</li>\n</ul>\n<h4 id=\"自定义变量\"><a href=\"#自定义变量\" class=\"headerlink\" title=\"自定义变量\"></a>自定义变量</h4><ul>\n<li><p>通常变量名大写</p>\n</li>\n<li><p>定义变量：变量名&#x3D;值</p>\n<p>值：`函数`或$(函数)  都能得到函数返回值</p>\n<p>echo a&#x3D;$(date)</p>\n</li>\n<li><p>输出变量：echo $变量名</p>\n</li>\n<li><p>撤销变量：unset 变量</p>\n</li>\n<li><p>声明静态变量：readonly变量，注意不能unset</p>\n</li>\n</ul>\n<h4 id=\"设置环境变量\"><a href=\"#设置环境变量\" class=\"headerlink\" title=\"设置环境变量\"></a>设置环境变量</h4><p>vim &#x2F;etc&#x2F;profile</p>\n<ul>\n<li><p>把shell变量输出成环境变量&#x2F;全局变量：export 变量名&#x3D;变量值</p>\n</li>\n<li><p>让修改的配置信息立即生效：source 配置文件</p>\n</li>\n</ul>\n<h4 id=\"多行注释\"><a href=\"#多行注释\" class=\"headerlink\" title=\"多行注释\"></a>多行注释</h4><p>:&lt;&lt;！</p>\n<p>xxxx</p>\n<p>xxxx </p>\n<p>！</p>\n<h3 id=\"linux解压缩\"><a href=\"#linux解压缩\" class=\"headerlink\" title=\"linux解压缩\"></a>linux解压缩</h3><h4 id=\"gzip-gunzip-指令\"><a href=\"#gzip-gunzip-指令\" class=\"headerlink\" title=\"gzip&#x2F;gunzip 指令\"></a>gzip&#x2F;gunzip 指令</h4><p>gzip 用于压缩文件， gunzip 用于解压的</p>\n<p>gzip 文件 （功能描述：压缩文件，只能将文件压缩为*.gz 文件）</p>\n<p>gunzip 文件.gz （功能描述：解压缩文件命令）</p>\n<p>案例 1: gzip 压缩， 将 &#x2F;home 下的 hello.txt 文件进行压缩</p>\n<p>gzip &#x2F;home&#x2F;hello.txt</p>\n<p>案例 2: gunzip 压缩， 将 &#x2F;home 下的 hello.txt.gz 文件进行解压缩</p>\n<p>gunzip &#x2F;home&#x2F;hello.txt.gz</p>\n<h4 id=\"zip-unzip-指令\"><a href=\"#zip-unzip-指令\" class=\"headerlink\" title=\"zip&#x2F;unzip 指令\"></a>zip&#x2F;unzip 指令</h4><p>zip 用于压缩文件， unzip 用于解压的，这个在项目打包发布中很有用的</p>\n<p>zip [选项] XXX.zip 将要压缩的内容（功能描述：压缩文件和目录的命令）</p>\n<p>unzip [选项] XXX.zip （功能描述：解压缩文件）</p>\n<p>zip 常用选项</p>\n<p>-r：递归压缩，即压缩目录</p>\n<p>unzip 的常用选项</p>\n<p>-d&lt;目录&gt; ：指定解压后文件的存放目录</p>\n<p>应用实例</p>\n<p>案例 1: 将 &#x2F;home 下的 所有文件&#x2F;文件夹进行压缩成 myhome.zip</p>\n<p>zip -r myhome.zip &#x2F;home&#x2F; [将 home 目录及其包含的文件和子文件夹都压缩] 案例 2: 将 myhome.zip 解压到 &#x2F;opt&#x2F;tmp 目录下</p>\n<p>mkdir &#x2F;opt&#x2F;tmp</p>\n<p>unzip -d &#x2F;opt&#x2F;tmp &#x2F;home&#x2F;myhome.zip</p>\n<h4 id=\"tar-指令\"><a href=\"#tar-指令\" class=\"headerlink\" title=\"tar 指令\"></a>tar 指令</h4><p>tar 指令 是打包指令，最后打包后的文件是 .tar.gz 的文件。</p>\n<p>tar [选项] XXX.tar.gz 打包的内容 (功能描述：打包目录，压缩后的文件格式.tar.gz)</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">-e</td>\n<td align=\"left\">产生.tar打包文件</td>\n</tr>\n<tr>\n<td align=\"left\">-v</td>\n<td align=\"left\">显示详细信息</td>\n</tr>\n<tr>\n<td align=\"left\">-f</td>\n<td align=\"left\">指定压缩后的文件名</td>\n</tr>\n<tr>\n<td align=\"left\">-z</td>\n<td align=\"left\">打包同时压缩</td>\n</tr>\n<tr>\n<td align=\"left\">-x</td>\n<td align=\"left\">解包.tar文件</td>\n</tr>\n</tbody></table>\n<p>案例 1: 压缩多个文件，将 &#x2F;home&#x2F;pig.txt 和 &#x2F;home&#x2F;cat.txt 压缩成 pc.tar.gz tar -zcvf pc.tar.gz &#x2F;home&#x2F;pig.txt &#x2F;home&#x2F;cat.txt</p>\n<p>案例 2: 将&#x2F;home 的文件夹 压缩成 myhome.tar.gz tar -zcvf myhome.tar.gz &#x2F;home&#x2F;</p>\n<p>案例 3: 将 pc.tar.gz 解压到当前目录</p>\n<p>tar -zxvf pc.tar.gz</p>\n<p>案例4: 将myhome.tar.gz 解压到 &#x2F;opt&#x2F;tmp2 目录下 (1) mkdir &#x2F;opt&#x2F;tmp2 (2) tar -zxvf &#x2F;home&#x2F;myhome.tar.gz -C &#x2F;opt&#x2F;tmp2</p>\n<h3 id=\"静态库和动态库\"><a href=\"#静态库和动态库\" class=\"headerlink\" title=\"静态库和动态库\"></a>静态库和动态库</h3><p><a href=\"https://blog.csdn.net/Pxx520Tangtian/article/details/122931769\">https://blog.csdn.net/Pxx520Tangtian/article/details/122931769</a></p>\n<h3 id=\"linux帮助指令\"><a href=\"#linux帮助指令\" class=\"headerlink\" title=\"linux帮助指令\"></a>linux帮助指令</h3><h4 id=\"man-获得帮助信息\"><a href=\"#man-获得帮助信息\" class=\"headerlink\" title=\"man 获得帮助信息\"></a>man 获得帮助信息</h4><p>基本语法：man [命令或配置文件]（功能描述：获得帮助信息）</p>\n<h4 id=\"help-指令\"><a href=\"#help-指令\" class=\"headerlink\" title=\"help 指令\"></a>help 指令</h4><p>基本语法：help 命令 （功能描述：获得 shell 内置命令的帮助信息）</p>\n<h3 id=\"软链接-ln-指令\"><a href=\"#软链接-ln-指令\" class=\"headerlink\" title=\"软链接 ln 指令\"></a>软链接 ln 指令</h3><p>软链接也称为符号链接，类似于 windows 里的快捷方式，主要存放了链接其他文件的路径<br>ln -s [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接）</p>\n<p>案例 1: 在&#x2F;home 目录下创建一个软连接 myroot，连接到 &#x2F;root 目录</p>\n<p>ln -s &#x2F;root &#x2F;home&#x2F;myroot</p>\n<p>案例 2: 删除软连接 myroot</p>\n<p>rm &#x2F;home&#x2F;myroot</p>\n<p>当我们使用 pwd 指令查看目录时，仍然看到的是软链接所在目录。</p>\n<h3 id=\"搜索文件和文件中的内容\"><a href=\"#搜索文件和文件中的内容\" class=\"headerlink\" title=\"搜索文件和文件中的内容\"></a>搜索文件和文件中的内容</h3><h4 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h4><p>find 目录名 -name 文件名 -print</p>\n<p>从&#x2F;tmp目录开始搜索，把全部的*.c文件显示出来。</p>\n<p>find &#x2F;tmp -name *.c -print</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">-name</td>\n<td align=\"left\">按照指定的文件名查找模式查找文件</td>\n</tr>\n<tr>\n<td align=\"left\">-user</td>\n<td align=\"left\">查找属于指定用户名的所有文件</td>\n</tr>\n<tr>\n<td align=\"left\">-size</td>\n<td align=\"left\">按照指定的囚犯们大小查找文件</td>\n</tr>\n</tbody></table>\n<p>案例 1: 按文件名：根据名称查找&#x2F;home 目录下的 hello.txt 文件</p>\n<p>find &#x2F;home -name hello.txt</p>\n<p>案例 2：按拥有者：查找&#x2F;opt 目录下，用户名称为 nobody 的文件</p>\n<p>find &#x2F;opt -user nobody</p>\n<p>案例 3：查找整个 linux 系统下大于 200M 的文件（+n 大于 -n 小于 n 等于, 单位有 k,M,G）<br>find &#x2F; -size +200M</p>\n<h4 id=\"locate\"><a href=\"#locate\" class=\"headerlink\" title=\"locate\"></a>locate</h4><p>yum -y install mlocate</p>\n<p>locate 指令可以快速定位文件路径。locate 指令利用事先建立的系统中所有文件名称及路径的 locate 数据库实现快速定位给定的文件。Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新 locate 时刻</p>\n<p>updatedb</p>\n<p>locate 搜索文件</p>\n<p>由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库。</p>\n<p>案例 1: 请使用 locate 指令快速定位 hello.txt 文件所在目录</p>\n<h4 id=\"which\"><a href=\"#which\" class=\"headerlink\" title=\"which\"></a>which</h4><p>可以查看某个指令在哪个目录下，比如 ls 指令在哪个目录</p>\n<p>which ls</p>\n<h4 id=\"grep-和-管道符号\"><a href=\"#grep-和-管道符号\" class=\"headerlink\" title=\"grep 和 管道符号 |\"></a>grep 和 管道符号 |</h4><p>grep 过滤查找 ， 管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。</p>\n<p>grep [选项] 查找内容 源文件</p>\n<p>-n 显示匹配行及行号</p>\n<p>-i 忽略字母大小写</p>\n<p>案例 1: 请在 hello.txt 文件中，查找 “yes” 所在行，并且显示行号</p>\n<p>写法 1: cat &#x2F;home&#x2F;hello.txt | grep “yes”</p>\n<p>写法 2: grep -n “yes” &#x2F;home&#x2F;hello.txt</p>\n<h3 id=\"显示文本文件的内容\"><a href=\"#显示文本文件的内容\" class=\"headerlink\" title=\"显示文本文件的内容\"></a>显示文本文件的内容</h3><h4 id=\"cat\"><a href=\"#cat\" class=\"headerlink\" title=\"cat\"></a>cat</h4><p>cat 文件名</p>\n<h4 id=\"more\"><a href=\"#more\" class=\"headerlink\" title=\"more\"></a>more</h4><p>more 文件名</p>\n<p>按空格键显示下一页，按b键显上一页，按q键退出。</p>\n<h4 id=\"tail\"><a href=\"#tail\" class=\"headerlink\" title=\"tail\"></a>tail</h4><p>tail 文件 （功能描述：查看文件尾 10 行内容）</p>\n<p>tail -n 5 文件 （功能描述：查看文件尾 5 行内容，5 可以是任意行数）</p>\n<p>tail -f 文件 （功能描述：实时追踪该文档的所有更新）</p>\n<h4 id=\"head\"><a href=\"#head\" class=\"headerlink\" title=\"head\"></a>head</h4><p>head 文件 (功能描述：查看文件头 10 行内容)</p>\n<p>head -n 5 文件 (功能描述：查看文件头 5 行内容，5 可以是任意行数)</p>\n<h4 id=\"less\"><a href=\"#less\" class=\"headerlink\" title=\"less\"></a>less</h4><p>less 文件名</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">操作</th>\n<th align=\"left\">功能说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">空格</td>\n<td align=\"left\">向下翻动一页</td>\n</tr>\n<tr>\n<td align=\"left\">pagedown</td>\n<td align=\"left\">向下翻动一页</td>\n</tr>\n<tr>\n<td align=\"left\">pageup</td>\n<td align=\"left\">向上翻动一页</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;或者？字符</td>\n<td align=\"left\">向下搜索字串，n向下找，N向上找</td>\n</tr>\n<tr>\n<td align=\"left\">q</td>\n<td align=\"left\">离开less这个程序</td>\n</tr>\n</tbody></table>\n<h4 id=\"wc\"><a href=\"#wc\" class=\"headerlink\" title=\"wc\"></a>wc</h4><p>统计文本文件的行数、单词数和字节数</p>\n<p>wc 文件名</p>\n<p>文件行数 文件字数 文件大小</p>\n<h3 id=\"linux修改ssh端口\"><a href=\"#linux修改ssh端口\" class=\"headerlink\" title=\"linux修改ssh端口\"></a>linux修改ssh端口</h3><h4 id=\"centos修改ssh端口\"><a href=\"#centos修改ssh端口\" class=\"headerlink\" title=\"centos修改ssh端口\"></a>centos修改ssh端口</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi /etc/ssh/sshd_config</span><br><span class=\"line\"></span><br><span class=\"line\">Port 端口号</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl restart sshd</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"debian修改ssh端口\"><a href=\"#debian修改ssh端口\" class=\"headerlink\" title=\"debian修改ssh端口\"></a>debian修改ssh端口</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi /etc/ssh/sshd_config</span><br><span class=\"line\"></span><br><span class=\"line\">Port 端口号</span><br><span class=\"line\"></span><br><span class=\"line\">service ssh restart </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ubuntu修改ssh端口\"><a href=\"#ubuntu修改ssh端口\" class=\"headerlink\" title=\"ubuntu修改ssh端口\"></a>ubuntu修改ssh端口</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi /etc/ssh/sshd_config</span><br><span class=\"line\"></span><br><span class=\"line\">Port 端口号</span><br><span class=\"line\"></span><br><span class=\"line\">service ssh restart </span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"RPM、YUM、wget\"><a href=\"#RPM、YUM、wget\" class=\"headerlink\" title=\"RPM、YUM、wget\"></a>RPM、YUM、wget</h3><h4 id=\"rpm-包的管理\"><a href=\"#rpm-包的管理\" class=\"headerlink\" title=\"rpm 包的管理\"></a>rpm 包的管理</h4><p>rpm 用于互联网下载包的打包及安装工具，它包含在某些 Linux 分发版中。它生成具有.RPM 扩展名的文件。RPM 是 RedHat Package Manager（RedHat 软件包管理工具）的缩写，类似 windows 的 setup.exe，这一文件格式名称虽然打上了 RedHat 的标志，但理念是通用的。</p>\n<p>Linux 的分发版本都有采用（suse,redhat, centos 等等），可以算是公认的行业标准了。</p>\n<h5 id=\"rpm-包的简单查询指令\"><a href=\"#rpm-包的简单查询指令\" class=\"headerlink\" title=\"rpm 包的简单查询指令\"></a>rpm 包的简单查询指令</h5><p>查询已安装的 rpm 列表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">rpm –qa|grep xx</span><br></pre></td></tr></table></figure>\n\n<p>举例： 看看当前系统，是否安装了 firefox 指令: rpm -qa | grep firefox</p>\n<h5 id=\"rpm-包名基本格式\"><a href=\"#rpm-包名基本格式\" class=\"headerlink\" title=\"rpm 包名基本格式\"></a>rpm 包名基本格式</h5><p>一个 rpm 包名：firefox-60.2.2-1.el7.centos.x86_64 名称:firefox</p>\n<p>版本号：60.2.2-1</p>\n<p>适用操作系统: el7.centos.x86_64</p>\n<p>表示 centos7.x 的 64 位系统</p>\n<p>如果是 i686、i386 表示 32 位系统，noarch 表示通用</p>\n<h5 id=\"rpm-包的其它查询指令：\"><a href=\"#rpm-包的其它查询指令：\" class=\"headerlink\" title=\"rpm 包的其它查询指令：\"></a>rpm 包的其它查询指令：</h5><p>rpm -qa :查询所安装的所有 rpm 软件包</p>\n<p>rpm -qa | more</p>\n<p>rpm -qa | grep X [rpm -qa | grep firefox ]</p>\n<p>rpm -q 软件包名 :查询软件包是否安装案例：rpm -q firefox</p>\n<p>rpm -qi 软件包名 ：查询软件包信息案例: rpm -qi firefox</p>\n<p>rpm -ql 软件包名 : 查询软件包中的文件比如： rpm -ql firefox</p>\n<p>rpm -qf 文件全路径名 查询文件所属的软件包</p>\n<p>rpm -qf &#x2F;etc&#x2F;passwd rpm -qf &#x2F;root&#x2F;install.log</p>\n<h5 id=\"卸载rpm-包：\"><a href=\"#卸载rpm-包：\" class=\"headerlink\" title=\"卸载rpm 包：\"></a>卸载rpm 包：</h5><ul>\n<li>基本语法</li>\n</ul>\n<p>rpm -e RPM 包的名称 &#x2F;&#x2F;erase</p>\n<ul>\n<li>应用案例</li>\n</ul>\n<p>删除 firefox 软件包</p>\n<p>rpm -e firefox</p>\n<ul>\n<li>细节讨论</li>\n</ul>\n<ol>\n<li>如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息。如： $ rpm -e foo</li>\n</ol>\n<p>removing these packages would break dependencies:foo is needed by bar-1.0-1</p>\n<ol>\n<li>如果我们就是要删除 foo 这个 rpm 包，可以增加参数 –nodeps ,就可以强制删除，但是一般不推荐这样做，因为依赖于该软件包的程序可能无法运行。如：$ rpm -e –nodeps foo</li>\n</ol>\n<h5 id=\"安装rpm-包\"><a href=\"#安装rpm-包\" class=\"headerlink\" title=\"安装rpm 包\"></a>安装rpm 包</h5><ul>\n<li>基本语法</li>\n</ul>\n<p>rpm -ivh RPM 包全路径名称</p>\n<ul>\n<li>参数说明</li>\n</ul>\n<p>i&#x3D;install 安装</p>\n<p>v&#x3D;verbose 提示</p>\n<p>h&#x3D;hash 进度条</p>\n<ul>\n<li>应用实例</li>\n</ul>\n<p>演示卸载和安装 firefox 浏览器</p>\n<p>rpm -e firefox</p>\n<p>rpm -ivh firefox</p>\n<h4 id=\"yum\"><a href=\"#yum\" class=\"headerlink\" title=\"yum\"></a>yum</h4><p>Yum 是一个 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。</p>\n<h5 id=\"yum-的基本指令\"><a href=\"#yum-的基本指令\" class=\"headerlink\" title=\"yum 的基本指令\"></a>yum 的基本指令</h5><p>查询 yum 服务器是否有需要安装的软件</p>\n<p>yum list|grep xx 软件列表</p>\n<h5 id=\"安装指定的yum-包\"><a href=\"#安装指定的yum-包\" class=\"headerlink\" title=\"安装指定的yum 包\"></a>安装指定的yum 包</h5><p>yum install xxx 下载安装</p>\n<p>yum -y install xxx 自动同意询问</p>\n<h5 id=\"yum-应用实例：\"><a href=\"#yum-应用实例：\" class=\"headerlink\" title=\"yum 应用实例：\"></a>yum 应用实例：</h5><p>案例：请使用 yum 的方式来安装 firefox</p>\n<p>rpm -e firefox</p>\n<p>yum list | grep firefox</p>\n<p>yum install firefox</p>\n<h4 id=\"wget\"><a href=\"#wget\" class=\"headerlink\" title=\"wget\"></a>wget</h4><p>wget 链接 下载文件</p>\n<h3 id=\"ubuntu系统ssh服务\"><a href=\"#ubuntu系统ssh服务\" class=\"headerlink\" title=\"ubuntu系统ssh服务\"></a>ubuntu系统ssh服务</h3><p>终端输入ifconfig查看ip</p>\n<ol>\n<li>进入root用户模式：</li>\n<li>执行命令： apt-get install ssh（安装ssh服务）</li>\n<li>apt-get install vim（安装vim编辑器）</li>\n<li>vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config (更改SSH服务的配置文件，允许远程登录root)</li>\n<li>将PermitRootLogin 的值设为 yes</li>\n</ol>\n<h3 id=\"ubuntu终端下MySQL输入中文\"><a href=\"#ubuntu终端下MySQL输入中文\" class=\"headerlink\" title=\"ubuntu终端下MySQL输入中文\"></a>ubuntu终端下MySQL输入中文</h3><ol>\n<li><p>编辑mysql.cnf文件<br>首先编辑&#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;mysql.cnf文件,应当无内容</p>\n</li>\n<li><p>编辑mysqld.cnf文件</p>\n</li>\n</ol>\n<p>vi &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</p>\n<p>在[mysqld]下加入character-set-server&#x3D;utf8</p>\n<ol start=\"3\">\n<li>重启服务器<br>sudo &#x2F;etc&#x2F;init.d&#x2F;mysql restart</li>\n</ol>\n<h3 id=\"ubuntu的默认root密码设置\"><a href=\"#ubuntu的默认root密码设置\" class=\"headerlink\" title=\"ubuntu的默认root密码设置\"></a>ubuntu的默认root密码设置</h3><p>一、Ubuntu的默认root密码是随机的，即每次开机都有一个新的root密码。可以在终端输入命令 sudo passwd，然后输入当前用户的密码，enter.</p>\n<p>二、终端会提示输入新的密码并确认，此时的密码就是root新密码。修改成功后，输入命令 su root，再输入新的密码就ok了。</p>\n<h3 id=\"找回Linux-root密码\"><a href=\"#找回Linux-root密码\" class=\"headerlink\" title=\"找回Linux root密码\"></a>找回Linux root密码</h3><ol>\n<li>启动系统，进入开机界面，在界面中按“e”进入编辑界面。</li>\n<li>进入编辑界面，使用键盘上的上下键把光标往下移动，找到以““Linux16”开头内容所在的行数”，在行的最后面输入：init&#x3D;&#x2F;bin&#x2F;sh。</li>\n<li>输入完成后，直接按快捷键：Ctrl+x 进入<strong>单用户模式</strong>。</li>\n<li>在光标闪烁的位置中输入：mount -o remount,rw &#x2F;（注意：各个单词间有空格），完成后按键盘的回车键（Enter）。</li>\n<li>在新的一行最后面输入：passwd， 完成后按键盘的回车键（Enter）。输入密码，<strong>然后再次确认密码即</strong>可, 密码修改成功后，会显示passwd…..的样式，说明密码修改成功</li>\n<li>在鼠标闪烁的位置中（最后一行中）输入：touch &#x2F;.autorelabel（注意：touch与 &#x2F;后面有一个空格），完成后按键盘的回车键（Enter）</li>\n<li>继续在光标闪烁的位置中，输入：exec &#x2F;sbin&#x2F;init（注意：exec与 &#x2F;后面有一个空格），完成后按键盘的回车键（Enter）,等待系统自动修改密码，完成后，系统会自动重启, <strong>新的密码生效</strong>了</li>\n</ol>\n<h3 id=\"Linux运行级别\"><a href=\"#Linux运行级别\" class=\"headerlink\" title=\"Linux运行级别\"></a>Linux运行级别</h3><h4 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h4><p>运行级别说明：</p>\n<p>0 ：关机</p>\n<p>1 ：单用户【找回丢失密码】</p>\n<p>2：多用户状态没有网络服务</p>\n<p>3：多用户状态有网络服务</p>\n<p>4：系统未使用保留给用户</p>\n<p>5：图形界面</p>\n<p>6：系统重启</p>\n<p>常用运行级别是 3 和 5 ，也可以指定默认运行级别</p>\n<p>命令：init [0123456] 通过 init 来切换不同的运行级别</p>\n<h4 id=\"centos7-后运行级别说明\"><a href=\"#centos7-后运行级别说明\" class=\"headerlink\" title=\"centos7 后运行级别说明\"></a>centos7 后运行级别说明</h4><p>在 centos7 以前， &#x2F;etc&#x2F;inittab 文件中 .</p>\n<p>进行了简化 ，如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">multi-user.target: analogous to runlevel 3 </span><br><span class=\"line\">graphical.target: analogous to runlevel 5 </span><br><span class=\"line\"># To view current default target, run: </span><br><span class=\"line\">systemctl get-default</span><br><span class=\"line\"># To set a default target, run:</span><br><span class=\"line\">systemctl set-default TARGET.target</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Linux目录结构\"><a href=\"#Linux目录结构\" class=\"headerlink\" title=\"Linux目录结构\"></a>Linux目录结构</h3><p>在 Linux 世界里，一切皆文件</p>\n<ul>\n<li><p>&#x2F;bin [常用] (&#x2F;usr&#x2F;bin 、 &#x2F;usr&#x2F;local&#x2F;bin) 是 Binary 的缩写, 这个目录存放着最经常使用的命令</p>\n</li>\n<li><p>&#x2F;sbin (&#x2F;usr&#x2F;sbin 、 &#x2F;usr&#x2F;local&#x2F;sbin) s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。</p>\n</li>\n<li><p>&#x2F;home [常用] 存放普通用户的主目录，在 Linux 中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名</p>\n</li>\n<li><p>&#x2F;root [常用] 该目录为系统管理员，也称作超级权限者的用户主目录</p>\n</li>\n<li><p>&#x2F;lib 系统开机所需要最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库</p>\n</li>\n<li><p>&#x2F;lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件</p>\n</li>\n<li><p>&#x2F;etc [常用] 所有的系统管理所需要的配置文件和子目录, 比如安装 mysql 数据库 my.conf</p>\n</li>\n<li><p>&#x2F;usr [常用] 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与 windows 下的 program files 目录。</p>\n</li>\n<li><p>&#x2F;boot [常用] 存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件</p>\n</li>\n<li><p>&#x2F;proc [不能动] 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息</p>\n</li>\n<li><p>&#x2F;srv [不能动] service 缩写，该目录存放一些服务启动之后需要提取的数据</p>\n</li>\n<li><p>&#x2F;sys [不能动]这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs &#x3D;》【别动】</p>\n</li>\n<li><p>&#x2F;tmp 这个目录是用来存放一些临时文件的</p>\n</li>\n<li><p>&#x2F;dev 类似于 windows 的设备管理器，把所有的硬件用文件的形式存储</p>\n</li>\n<li><p>&#x2F;media [常用] linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下</p>\n</li>\n<li><p>&#x2F;mnt [常用] 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看里的内容了。 d:&#x2F;myshare</p>\n</li>\n<li><p>&#x2F;opt 这是给主机额外安装软件所存放的目录。如安装 ORACLE 数据库就可放到该目录下。默认为空</p>\n</li>\n<li><p>&#x2F;usr&#x2F;local [常用]这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序</p>\n</li>\n<li><p>&#x2F;var [常用]这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件</p>\n</li>\n<li><p>&#x2F;selinux [security-enhanced linux]SELinux 是一种安全子系统,它能控制程序只能访问特定文件, 有三种工作模式，可以自行设置.</p>\n</li>\n</ul>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h3 id=\"centos安装使用Ftp\"><a href=\"#centos安装使用Ftp\" class=\"headerlink\" title=\"centos安装使用Ftp\"></a>centos安装使用Ftp</h3><h4 id=\"安装ftp\"><a href=\"#安装ftp\" class=\"headerlink\" title=\"安装ftp\"></a>安装ftp</h4><p>在CentOS7中，采用yum来安装ftp软件包，包括ftp服务器和ftp客户端。如果已经安装，再次执行yum就会把软件包升级到最新版本。</p>\n<h5 id=\"1、安装ftp服务器\"><a href=\"#1、安装ftp服务器\" class=\"headerlink\" title=\"1、安装ftp服务器\"></a>1、安装ftp服务器</h5><p>yum -y install vsftpd</p>\n<h5 id=\"2、安装ftp客户端\"><a href=\"#2、安装ftp客户端\" class=\"headerlink\" title=\"2、安装ftp客户端\"></a>2、安装ftp客户端</h5><p>yum -y install ftp</p>\n<h4 id=\"配置ftp服务器\"><a href=\"#配置ftp服务器\" class=\"headerlink\" title=\"配置ftp服务器\"></a>配置ftp服务器</h4><p>ftp的传输模式有被动模式和主动式两种，缺省是被动模式，主动模式的应用场景极少，为了方便表达，在接下来的内容中只介绍被动模式，主动模式在本文中也有介绍。</p>\n<h5 id=\"1、关闭SELINUX\"><a href=\"#1、关闭SELINUX\" class=\"headerlink\" title=\"1、关闭SELINUX\"></a>1、关闭SELINUX</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi /etc/selinux/config</span><br><span class=\"line\"></span><br><span class=\"line\">SELINUX =disabled</span><br><span class=\"line\"></span><br><span class=\"line\">setenforce 0</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2、配置ftp数据端口参数\"><a href=\"#2、配置ftp数据端口参数\" class=\"headerlink\" title=\"2、配置ftp数据端口参数\"></a>2、配置ftp数据端口参数</h5><p>ftp的数据端口也称为高端口，在&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf文件中配置，由pasv_min_port和pasv_max_port两个参数指定，如果文件中没有这两个参数，手工的加进去。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi /etc/vsftpd/vsftpd.conf</span><br><span class=\"line\"></span><br><span class=\"line\">listen=YES </span><br><span class=\"line\"></span><br><span class=\"line\">listen_ipv6=NO</span><br><span class=\"line\"></span><br><span class=\"line\">pasv_address=&lt;EIP&gt;</span><br><span class=\"line\">pasv_min_port=5000  # 高端口范围的最小值。</span><br><span class=\"line\">pasv_max_port=5500  # 高端口范围的最大值。</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3、开通防火墙\"><a href=\"#3、开通防火墙\" class=\"headerlink\" title=\"3、开通防火墙\"></a>3、开通防火墙</h5><p>开通防火墙的方法有两种：</p>\n<p>1）开通ftp服务。</p>\n<p>firewall-cmd –zone&#x3D;public –add-service&#x3D;ftp –permanent</p>\n<p>2）开通ftp服务需要的端口，21是控制端口，5000-5500是数据端口范围，也就是上一节中在&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf文件中配置的pasv_min_port和pasv_max_port参数。</p>\n<p>firewall-cmd –zone&#x3D;public –add-port&#x3D;21&#x2F;tcp –permanent</p>\n<p>firewall-cmd –zone&#x3D;public –add-port&#x3D;5000-5500&#x2F;tcp –permanent</p>\n<p>重启防火墙：</p>\n<p>systemctl restart firewalld.service</p>\n<h5 id=\"4、启动vsftpd服务\"><a href=\"#4、启动vsftpd服务\" class=\"headerlink\" title=\"4、启动vsftpd服务\"></a>4、启动vsftpd服务</h5><p>ftp服务器的服务名是vsftpd，相关的操作如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl start  vsftpd  # 启动服务。</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl stop  vsftpd  # 停止服务。</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl restart vsftpd  # 重启服务。</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl status vsftpd  # 查看服务状态。</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl enable vsftpd  # 启用开机自动动vsftpd服务。</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl disable vsftpd  # 禁用开机自动动vsftpd服务。</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"5、云平台访问策略配置\"><a href=\"#5、云平台访问策略配置\" class=\"headerlink\" title=\"5、云平台访问策略配置\"></a>5、云平台访问策略配置</h5><p>如果您购买的是云服务器上，需要登录云服务器提供商的管理平台开通访问策略（或安全组），开通21和高端口的访问策略。</p>\n<p>不同云服务器提供商的管理平台操作方法不同，具体操作方法阅读操作手册、或者百度，或者咨询云服务器提供商的客服。</p>\n<p>如果云服务器的ftp服务不能建立数据会话，在百度中输入<strong>“被动模式下FTP不能建立数据会话问题“</strong>可以找到解决问题的方法，目前的阿里云服务器就存在这个问题。</p>\n<h4 id=\"ftp开发\"><a href=\"#ftp开发\" class=\"headerlink\" title=\"ftp开发\"></a>ftp开发</h4><p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi ftpclient.cpp</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#include  &quot;_ftp.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Cftp ftp;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (ftp.login(&quot;127.0.0.1:21&quot;,&quot;lijialin&quot;,&quot;mima&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;ftp.login(127.0.0.1:21) failed.\\n&quot;); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;ftp.login(127.0.0.1:21) success.\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  if (ftp.mtime(&quot;/home/lijialin/text.cpp&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;ftp.mtime(/home/lijialin/text.cpp) failed.\\n&quot;); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  printf(&quot;ftp.mtime(/home/lijialin/text.cpp) success,mtime=%s.\\n&quot;,ftp.m_mtime);</span><br><span class=\"line\"></span><br><span class=\"line\">  if (ftp.size(&quot;/home/lijialin/text.cpp&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;ftp.size(/home/lijialin/text.cpp) failed.\\n&quot;); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  printf(&quot;ftp.size(/home/lijialin/text.cpp) success,size=%d.\\n&quot;,ftp.m_size);</span><br><span class=\"line\"></span><br><span class=\"line\">  if (ftp.nlist(&quot;/home/lijialin&quot;,&quot;/tmp/lijialin.lst&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;ftp.nlist(/home/lijialin) failed.\\n&quot;); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  printf(&quot;ftp.nlist(/home/lijialin) success.\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  if (ftp.get(&quot;/home/lijialin/text.cpp&quot;,&quot;/tmp/text.cpp.bak&quot;,true)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;ftp.get() failed.\\n&quot;); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  printf(&quot;ftp.get() success.\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">  if (ftp.put(&quot;/root/ftpclient.cpp&quot;,&quot;/home/zhangkun/bbb/ftpclient.cpp&quot;,true)===</span><br><span class=\"line\">false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;ftp.put() failed.\\n&quot;); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  printf(&quot;ftp.put() success.\\n&quot;);</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">  ftp.logout();</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">g++ -g -o ftpclient ftpclient.cpp /project/public/_ftp.cpp /project/public/_public.cpp -I/project/public -L/project/public -lftp -lm -lc</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"动态链接库问题\"><a href=\"#动态链接库问题\" class=\"headerlink\" title=\"动态链接库问题\"></a>动态链接库问题</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">./ftpclient: error while loading shared libraries: libftp.so: cannot open shared object file: No such file or directory</span><br><span class=\"line\"></span><br><span class=\"line\">export LD_LIBRARY_PATH=/project/public:.</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ftp.nlist(/home/lijialin) failed. </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"centos安装使用nginx\"><a href=\"#centos安装使用nginx\" class=\"headerlink\" title=\"centos安装使用nginx\"></a>centos安装使用nginx</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo yum -y install nginx </span><br><span class=\"line\"></span><br><span class=\"line\">nginx  </span><br><span class=\"line\">ps -ef|grep nginx</span><br><span class=\"line\"></span><br><span class=\"line\">yum install lsof</span><br><span class=\"line\">lsof -i:80</span><br><span class=\"line\"></span><br><span class=\"line\">nginx -s signal // quit/stop/reload/reopen</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx -V  </span><br><span class=\"line\">//--conf-path=/etc/nginx/nginx.conf 配置文件位置</span><br><span class=\"line\">//--prefix=/usr/share/nginx   nginx根目录</span><br><span class=\"line\"></span><br><span class=\"line\">nginx -t //检查配置文件内容是否正确</span><br><span class=\"line\">nginx -s reload </span><br><span class=\"line\"></span><br><span class=\"line\">vi /etc/nginx/nginx.conf</span><br><span class=\"line\"></span><br><span class=\"line\">//全局块 配置worker进程的数量、指定运行服务的用户等</span><br><span class=\"line\">worker_processes auto; //配置worker进程的数量</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//events块 配置服务器和客户端网络连接的配置</span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    worker_connections 1024; //每个worker进程可以接收网络连接的数量</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//http块     配置虚拟主机（server块）、 反向代理、负载均衡等等  </span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class=\"line\">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class=\"line\">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">    access_log  /var/log/nginx/access.log  main;</span><br><span class=\"line\"></span><br><span class=\"line\">    sendfile            on;</span><br><span class=\"line\">    tcp_nopush          on;</span><br><span class=\"line\">    tcp_nodelay         on;</span><br><span class=\"line\">    keepalive_timeout   65;</span><br><span class=\"line\">    types_hash_max_size 4096;</span><br><span class=\"line\"></span><br><span class=\"line\">    include             /etc/nginx/mime.types; \t//包含其他配置文件</span><br><span class=\"line\">    default_type        application/octet-stream;</span><br><span class=\"line\"></span><br><span class=\"line\">    # Load modular configuration files from the /etc/nginx/conf.d directory.</span><br><span class=\"line\">    # See http://nginx.org/en/docs/ngx_core_module.html#include</span><br><span class=\"line\">    # for more information.</span><br><span class=\"line\">    include /etc/nginx/conf.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       80; //监听端口</span><br><span class=\"line\">        listen       [::]:80;</span><br><span class=\"line\">        server_name  _;\t//服务名</span><br><span class=\"line\">        root         /usr/share/nginx/html; //配置根目录文件夹</span><br><span class=\"line\"></span><br><span class=\"line\">        # Load configuration files for the default server block.</span><br><span class=\"line\">        include /etc/nginx/default.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 404 /404.html;</span><br><span class=\"line\">        location = /404.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 500 502 503 504 /50x.html;</span><br><span class=\"line\">        location = /50x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    include servers/* //把servers目录下的所有配置文件都包含进来，每个虚拟主机（server块）的配置放在一个单独的文件里 </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"网站部署\"><a href=\"#网站部署\" class=\"headerlink\" title=\"网站部署\"></a>网站部署</h4><p>例如：Hexo，基于Node.js的博客框架</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\"></span><br><span class=\"line\">mkdir ~/nginx</span><br><span class=\"line\">cd ~/nginx</span><br><span class=\"line\">hexo init blog</span><br><span class=\"line\"></span><br><span class=\"line\">cd blog/public</span><br><span class=\"line\">cp -rf * /usr/share/nginx/html //把public下的文件都复制到nginx配置的server的根目录中</span><br><span class=\"line\"></span><br><span class=\"line\">hexo使用：</span><br><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\">hexo init blog</span><br><span class=\"line\">hexo s //运行一下</span><br><span class=\"line\">hexo d //自动部署 需要配置config文件</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>例如：Vue </p>\n<p>可以修改配置文件server块实现一个服务器代理多个域名访问</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm create vite</span><br><span class=\"line\">cd vite-project</span><br><span class=\"line\">npm install</span><br><span class=\"line\">//打包一下</span><br><span class=\"line\">npm run build</span><br><span class=\"line\"></span><br><span class=\"line\">把打包后的dist文件放在一个有权限访问的位置 在servers文件夹中添加配置文件 name.conf 写上server块</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        listen       [::]:80;</span><br><span class=\"line\">        server_name  _;</span><br><span class=\"line\">        root         /usr/share/nginx/dist;</span><br><span class=\"line\"></span><br><span class=\"line\">        # Load configuration files for the default server block.</span><br><span class=\"line\">        include /etc/nginx/default.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 404 /404.html;</span><br><span class=\"line\">        location = /404.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 500 502 503 504 /50x.html;</span><br><span class=\"line\">        location = /50x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">nginx -s reload</span><br><span class=\"line\"></span><br><span class=\"line\">vite使用：</span><br><span class=\"line\">npm create vite</span><br><span class=\"line\">npm install</span><br><span class=\"line\">npm run build</span><br><span class=\"line\">npm run dev //运行一下</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"反向代理、负载均衡\"><a href=\"#反向代理、负载均衡\" class=\"headerlink\" title=\"反向代理、负载均衡\"></a>反向代理、负载均衡</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi /etc/nginx/nginx.conf</span><br><span class=\"line\"></span><br><span class=\"line\">在http块中添加反向代理配置</span><br><span class=\"line\">upstream name357&#123;</span><br><span class=\"line\">\tip_hash;\t//这个负载均衡策略会对客户端的ip进行哈希，同一个客户端的请会分配到同一个服务器上可以解决一些session的问题</span><br><span class=\"line\">\t//另一种负载均衡策略weight</span><br><span class=\"line\">\tserver 127.0.0.1（ip）:8000 weight=5 //这个服务器性能好，就配置权重（weight）大点，能分配到的请求次数越多</span><br><span class=\"line\">\tserver 127.0.0.1（ip）:8001</span><br><span class=\"line\">\tserver 127.0.0.1（ip）:8002</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">访问localhost/app 就相当于 轮流（默认）或负载均衡（weight分配的权重） 的访问对应ip服务器的对应8000/8001/8002端口得到的内容</span><br><span class=\"line\">server&#123;</span><br><span class=\"line\">\tlocation /app&#123;//所有以app开头的请求都被代理到upstream中访问8000，8001......</span><br><span class=\"line\">\t\tproxy_pass http://name357  //地址要和upstream中的名字保持一致</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h4><p>http+ssl&#x3D;https</p>\n<p>ssl证书可以通过云平台获取</p>\n<p>在nginx中配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi /etc/nginx/nginx.conf</span><br><span class=\"line\"></span><br><span class=\"line\">在server中 </span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen       443 ssl http2;</span><br><span class=\"line\">        listen       [::]:443 ssl http2;</span><br><span class=\"line\">        server_name  url; //网站域名</span><br><span class=\"line\">        root         /usr/share/nginx/html;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t#证书文件名称</span><br><span class=\"line\">        ssl_certificate &quot;/root/nginx/cacert.pem&quot;;</span><br><span class=\"line\">        #证书私钥文件名称</span><br><span class=\"line\">        ssl_certificate_key &quot;/root/nginx/private.key&quot;;</span><br><span class=\"line\">        #ssl_session_cache shared:SSL:1m;</span><br><span class=\"line\">        #ssl验证配置</span><br><span class=\"line\">        ssl_session_timeout  10m;</span><br><span class=\"line\">        #配置加密套件/算法加密，写法遵循openssl标准</span><br><span class=\"line\">        ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class=\"line\">        #使用服务器端的首选算法</span><br><span class=\"line\">        ssl_prefer_server_ciphers on;</span><br><span class=\"line\">        #安全链接可选加密协议</span><br><span class=\"line\">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;</span><br><span class=\"line\"></span><br><span class=\"line\">        # Load configuration files for the default server block.</span><br><span class=\"line\">        include /etc/nginx/default.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 404 /404.html;</span><br><span class=\"line\">            location = /40x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 500 502 503 504 /50x.html;</span><br><span class=\"line\">            location = /50x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"centos安装git\"><a href=\"#centos安装git\" class=\"headerlink\" title=\"centos安装git\"></a>centos安装git</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum -y install git</span><br><span class=\"line\"></span><br><span class=\"line\">git --version</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"centos安装使用nvm\"><a href=\"#centos安装使用nvm\" class=\"headerlink\" title=\"centos安装使用nvm\"></a>centos安装使用nvm</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone git://github.com/creationix/nvm.git ~/nvm</span><br><span class=\"line\">or</span><br><span class=\"line\">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash</span><br><span class=\"line\"></span><br><span class=\"line\">command -v nvm</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;source ~/nvm/nvm.sh&quot; &gt;&gt; ~/.bashrc</span><br><span class=\"line\">source ~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">常用命令</span><br><span class=\"line\">1. nvm list 是查找本电脑上所有的node版本</span><br><span class=\"line\">    - nvm list 查看已经安装的版本</span><br><span class=\"line\">    - nvm list installed 查看已经安装的版本</span><br><span class=\"line\">    - nvm list available 查看网络可以安装的版本</span><br><span class=\"line\">2. nvm install &lt;version&gt; 安装指定版本node</span><br><span class=\"line\">3. nvm use &lt;version&gt; 切换使用指定的版本node</span><br><span class=\"line\">4. nvm ls 列出所有版本</span><br><span class=\"line\">5. nvm current显示当前版本</span><br><span class=\"line\">6. nvm alias &lt;name&gt; &lt;version&gt; ## 给不同的版本号添加别名</span><br><span class=\"line\">7. nvm unalias &lt;name&gt; ## 删除已定义的别名</span><br><span class=\"line\">8. nvm reinstall-packages &lt;version&gt; ## 在当前版本node环境下，重新全局安装指定版本号的npm包</span><br><span class=\"line\">9. nvm on 打开nodejs控制</span><br><span class=\"line\">10. nvm off 关闭nodejs控制</span><br><span class=\"line\">11. nvm proxy 查看设置与代理</span><br><span class=\"line\">12. nvm node_mirror [url] 设置或者查看setting.txt中的node_mirror，如果不设置的默认是 https://nodejs.org/dist/</span><br><span class=\"line\">　　nvm npm_mirror [url] 设置或者查看setting.txt中的npm_mirror,如果不设置的话默认的是： https://github.com/npm/npm/archive/.</span><br><span class=\"line\">13. nvm uninstall &lt;version&gt; 卸载制定的版本</span><br><span class=\"line\">14. nvm use [version] [arch] 切换制定的node版本和位数</span><br><span class=\"line\">15. nvm root [path] 设置和查看root路径</span><br><span class=\"line\">16. nvm version 查看当前的版本</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"centos安装node-js\"><a href=\"#centos安装node-js\" class=\"headerlink\" title=\"centos安装node.js\"></a>centos安装node.js</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">nvm install 16</span><br><span class=\"line\"></span><br><span class=\"line\">node -v</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"centos7升级GCC\"><a href=\"#centos7升级GCC\" class=\"headerlink\" title=\"centos7升级GCC\"></a>centos7升级GCC</h3><p><a href=\"https://blog.csdn.net/b_ingram/article/details/121569398\">https://blog.csdn.net/b_ingram/article/details/121569398</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y gcc gcc-c++</span><br><span class=\"line\">gcc --version</span><br><span class=\"line\">g++ --version</span><br><span class=\"line\">切换用户：</span><br><span class=\"line\">su - root</span><br><span class=\"line\">安装centos-release-scl：</span><br><span class=\"line\">sudo yum install -y http://mirror.centos.org/centos/7/extras/x86_64/Packages/centos-release-scl-rh-2-3.el7.centos.noarch.rpm</span><br><span class=\"line\"></span><br><span class=\"line\">sudo yum install -y http://mirror.centos.org/centos/7/extras/x86_64/Packages/centos-release-scl-2-3.el7.centos.noarch.rpm</span><br><span class=\"line\"></span><br><span class=\"line\">安装devtoolset：</span><br><span class=\"line\">sudo yum install -y devtoolset-9-gcc-c++</span><br><span class=\"line\"></span><br><span class=\"line\">激活对应的devtoolset:</span><br><span class=\"line\">scl enable devtoolset-9 bash</span><br><span class=\"line\">source /opt/rh/devtoolset-9/enable</span><br><span class=\"line\">gcc --version</span><br><span class=\"line\">1.直接替换旧版本的gcc:</span><br><span class=\"line\">mv /usr/bin/gcc /usr/bin/gcc-4.8.5</span><br><span class=\"line\">ln -s /opt/rh/devtoolset-9/root/bin/gcc /usr/bin/gcc</span><br><span class=\"line\">2.启动gcc（永久）</span><br><span class=\"line\">echo &quot;source /opt/rh/devtoolset-9/enable&quot; &gt;&gt;/etc/profile</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"centos安装g\"><a href=\"#centos安装g\" class=\"headerlink\" title=\"centos安装g++\"></a>centos安装g++</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install gcc-c++ libstdc++-devel </span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"centos安装tomcat\"><a href=\"#centos安装tomcat\" class=\"headerlink\" title=\"centos安装tomcat\"></a>centos安装tomcat</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir /opt/tomcat</span><br><span class=\"line\"></span><br><span class=\"line\">apache-tomcat-8.5.59.tar.gz上传到/opt/tomcat</span><br><span class=\"line\"></span><br><span class=\"line\">cd /opt/tomcat</span><br><span class=\"line\">tar -zxvf apache-tomcat-8.5.59.tar.gz</span><br><span class=\"line\">cd apache-tomcat-8.5.59/bin/</span><br><span class=\"line\">./startup.sh</span><br></pre></td></tr></table></figure>\n\n<p>开放端口（防火墙或安全组） 8080</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">firewall -cmd --permanent add-port=8080/tcp</span><br><span class=\"line\">firewall -cmd --reload</span><br><span class=\"line\">firewall -cmd --query-port=8080/tcp</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"ubuntu安装mysql\"><a href=\"#ubuntu安装mysql\" class=\"headerlink\" title=\"ubuntu安装mysql\"></a>ubuntu安装mysql</h3><p>1、#查看有没有安装MySQL：</p>\n<p>dpkg -l | grep mysql</p>\n<p>2、 安装MySQL：</p>\n<p>sudo apt install mysql-server</p>\n<p>3、检查是否安装成功：</p>\n<p>netstat -tap | grep mysql</p>\n<h3 id=\"centos安装mysql5-7\"><a href=\"#centos安装mysql5-7\" class=\"headerlink\" title=\"centos安装mysql5.7\"></a>centos安装mysql5.7</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir /opt/mysql</span><br><span class=\"line\">cd /opt/mysql</span><br><span class=\"line\"></span><br><span class=\"line\">wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar</span><br><span class=\"line\"></span><br><span class=\"line\">tar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar</span><br><span class=\"line\"></span><br><span class=\"line\">rpm -qa|grep mari  原本可能有的数据库 提前删干净</span><br><span class=\"line\">rpm -e --nodeps mariadb-libs 删除mari相关的所有</span><br><span class=\"line\">rpm -e --nodeps marisa</span><br><span class=\"line\"></span><br><span class=\"line\">rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm</span><br><span class=\"line\">rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm</span><br><span class=\"line\">rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm</span><br><span class=\"line\">rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm --force --nodeps </span><br><span class=\"line\"> 如果失败 可能缺少依赖numactl </span><br><span class=\"line\"> yum -y install libaio</span><br><span class=\"line\"> yum -y install numactl</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl start mysqld.service</span><br><span class=\"line\"></span><br><span class=\"line\">如果报错Job for mysqld.service failed because the control process exited with error code. See &quot;systemctl status mysqld.service&quot; and &quot;journalctl -xe&quot; for details.</span><br><span class=\"line\"></span><br><span class=\"line\">mkdir -p /var/run/mysqld/</span><br><span class=\"line\">chown mysql.mysql /var/run/mysqld/</span><br><span class=\"line\">//or</span><br><span class=\"line\">mkdir /var/lib/mysql/data</span><br><span class=\"line\">vi /etc/my.cnf</span><br><span class=\"line\">datadir=/var/lib/mysql/data</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">systemctl status mysqld.service</span><br><span class=\"line\"></span><br><span class=\"line\">grep &quot;password&quot; /var/log/mysqld.log</span><br><span class=\"line\"></span><br><span class=\"line\">mysql -uroot -p</span><br><span class=\"line\">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;;</span><br><span class=\"line\">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">配置远程连接</span><br><span class=\"line\">USE mysql;</span><br><span class=\"line\">UPDATE mysql.user SET host = &#x27;%&#x27; WHERE user = &#x27;root&#x27;;</span><br><span class=\"line\">SELECT user, host, plugin, authentication_string FROM mysql.user;</span><br><span class=\"line\">FLUSH PRIVILEGES;</span><br><span class=\"line\"></span><br><span class=\"line\">quit</span><br><span class=\"line\"></span><br><span class=\"line\">配置开机启动启动</span><br><span class=\"line\">查看MySQL是否自启：systemctl is-enabled mysqld</span><br><span class=\"line\">开启自启 ：systemctl enable mysqld</span><br><span class=\"line\">关闭自启 ：systemctl disable mysqld</span><br><span class=\"line\">systemctl enable mysqld.service # 开机自启动</span><br><span class=\"line\">systemctl disable mysqld.service # 禁用开机自启动</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"mysql找回root密码\"><a href=\"#mysql找回root密码\" class=\"headerlink\" title=\"mysql找回root密码\"></a>mysql找回root密码</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1. vi /etc/my.cnf</span><br><span class=\"line\">2. skip-grant-tables</span><br><span class=\"line\">3. service mysqld restart</span><br><span class=\"line\">4. mysql -u root -p</span><br><span class=\"line\">5. show databases;</span><br><span class=\"line\">6. use mysql;</span><br><span class=\"line\">7. show tables;</span><br><span class=\"line\">8. desc user;</span><br><span class=\"line\">9. update user set authentication_string=password(&quot;lijialin&quot;)  where user=&#x27;root&#x27;; </span><br><span class=\"line\"> 或者改成空密码&#x27;&#x27;登录以后再修改</span><br><span class=\"line\">10. flush privileges;</span><br><span class=\"line\">11. exit</span><br><span class=\"line\">12. vi /etc/my.cnf</span><br><span class=\"line\">13. #skip-grant-tables</span><br><span class=\"line\">14. service mysqld restart</span><br><span class=\"line\">15. mysql -u root -p</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"连接mysql\"><a href=\"#连接mysql\" class=\"headerlink\" title=\"连接mysql\"></a>连接mysql</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql -u root -p</span><br><span class=\"line\">use mysql;</span><br><span class=\"line\">update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;</span><br><span class=\"line\">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.ping IP 查看是否开放公网 </span><br><span class=\"line\">2.telnet IP port 查看端口是否开放</span><br><span class=\"line\">上面不通畅登录进入服务器登录mysql root</span><br><span class=\"line\">如果是docker安装</span><br><span class=\"line\">docker exec -it mysql /bin/bash  执行docker容器的mysql，这里容器名是mysql</span><br><span class=\"line\">mysql -u root -p</span><br><span class=\"line\">3.use mysql;</span><br><span class=\"line\">4. select host,user from user;</span><br><span class=\"line\">5. grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;lijialin&#x27;; //5.7</span><br><span class=\"line\"> GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; WITH GRANT OPTION; //8.0</span><br><span class=\"line\">6. flush privileges;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"一、查看3306端口是否开放\"><a href=\"#一、查看3306端口是否开放\" class=\"headerlink\" title=\"一、查看3306端口是否开放\"></a>一、查看3306端口是否开放</h4><figure class=\"highlight perl\"><table><tr><td class=\"code\"><pre><span class=\"line\">netstat -an|<span class=\"keyword\">grep</span> <span class=\"number\">3306</span></span><br></pre></td></tr></table></figure>\n\n<p>如果看到下图这样的，说明端口并未打开：</p>\n<p><img src=\"https://img-blog.csdn.net/20170811100345823?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZnJlZXppbmd4dQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"img\"></p>\n<h4 id=\"二、修改访问权限\"><a href=\"#二、修改访问权限\" class=\"headerlink\" title=\"二、修改访问权限\"></a>二、修改访问权限</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd /etc/mysql/mysql.conf.d/</span><br><span class=\"line\">sudo vim mysqld.cnf</span><br><span class=\"line\"># </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight r\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># bind-address = 127.0.0.1</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CentOS-‘mysql-mysql-h‘-No-such-file-or-directory\"><a href=\"#CentOS-‘mysql-mysql-h‘-No-such-file-or-directory\" class=\"headerlink\" title=\"CentOS ‘mysql&#x2F;mysql.h‘: No such file or directory\"></a>CentOS ‘mysql&#x2F;mysql.h‘: No such file or directory</h4><p>yum install mysql-devel</p>\n<p>然后</p>\n<p>mysql_config</p>\n<p>查看-lmysqlclient这个库 在哪个目录</p>\n<p>然后只需要把之前的编译命令- lmysqlclient替换成 -L&#x2F;usr&#x2F;lib64&#x2F;mysql -lmysqlclient（目录）这个就好了，就能编译过了。</p>\n<p>意思是 不从默认的文件夹&#x2F;usr&#x2F;lib里边取动态库-lmysqlclient从绝对目录里边取。</p>\n<p>所以也可以分析出来出现这个 找不到这个库的原因不是 因为linux机器上没有这个库。</p>\n<p>而是 找错了 位置，如果嫌加绝对目录太麻烦，直接复制一份到&#x2F;usr&#x2F;lib一份就行了</p>\n<h3 id=\"centos安装-JDK\"><a href=\"#centos安装-JDK\" class=\"headerlink\" title=\"centos安装 JDK\"></a>centos安装 JDK</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir /opt/jdk</span><br><span class=\"line\"></span><br><span class=\"line\">jdk-8u261-linux-x64.tar.gz上传到 /opt/jdk 下</span><br><span class=\"line\"></span><br><span class=\"line\">cd /opt/jdk</span><br><span class=\"line\">tar -zxvf jdk-8u261-linux-x64.tar.gz</span><br><span class=\"line\">mkdir /usr/local/java</span><br><span class=\"line\">mv /opt/jdk/jdk1.8.0_261 /usr/local/java</span><br><span class=\"line\">vim /etc/profile</span><br><span class=\"line\"></span><br><span class=\"line\">export JAVA_HOME=/usr/local/java/jdk1.8.0_261</span><br><span class=\"line\">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class=\"line\"></span><br><span class=\"line\">source /etc/profile</span><br><span class=\"line\">java -version</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"centos安装Hexo\"><a href=\"#centos安装Hexo\" class=\"headerlink\" title=\"centos安装Hexo\"></a>centos安装Hexo</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd nginx</span><br><span class=\"line\"></span><br><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\"></span><br><span class=\"line\">hexo init blog</span><br><span class=\"line\"></span><br><span class=\"line\">cd blog;npm install</span><br><span class=\"line\"></span><br><span class=\"line\">hexo server / hexo s</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"ubuntu安装redis\"><a href=\"#ubuntu安装redis\" class=\"headerlink\" title=\"ubuntu安装redis\"></a>ubuntu安装redis</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">apt update</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">apt install redis-server</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"centos安装redis\"><a href=\"#centos安装redis\" class=\"headerlink\" title=\"centos安装redis\"></a>centos安装redis</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc -v</span><br><span class=\"line\">yum install -y gcc</span><br><span class=\"line\"></span><br><span class=\"line\">cd /opt</span><br><span class=\"line\"># 下载，我是在root下执行的下载，所以我的下载目录为：/root/redis-6.2.6，这里按照自己的实际情况调整</span><br><span class=\"line\">wget https://download.redis.io/releases/redis-6.2.6.tar.gz</span><br><span class=\"line\"># 解压</span><br><span class=\"line\">tar -zxvf redis-6.2.6.tar.gz</span><br><span class=\"line\"># 进入解压目录</span><br><span class=\"line\">cd redis-6.2.6</span><br><span class=\"line\"># 编译</span><br><span class=\"line\">make</span><br><span class=\"line\"></span><br><span class=\"line\">yum install tcl tcl-devel -y</span><br><span class=\"line\">make test</span><br><span class=\"line\"></span><br><span class=\"line\">make install </span><br><span class=\"line\"></span><br><span class=\"line\">通过守护进程方式启动</span><br><span class=\"line\">vi redis.conf</span><br><span class=\"line\"># 修改内容如下：</span><br><span class=\"line\">daemonize 的值从 no 修改成 yes</span><br><span class=\"line\"></span><br><span class=\"line\">redis-server redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\">ps -ef |grep redis</span><br><span class=\"line\">redis-cli</span><br><span class=\"line\"></span><br><span class=\"line\">设置开机自动启动</span><br><span class=\"line\">cd /lib/systemd/system/</span><br><span class=\"line\">vi redis.service</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">redis.service</span><br><span class=\"line\">--------------------------------------------------------</span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=redis-server</span><br><span class=\"line\">After=network.target</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\"></span><br><span class=\"line\">Type=forking</span><br><span class=\"line\"></span><br><span class=\"line\"># ExecStart需要按照实际情况修改成自己的地址</span><br><span class=\"line\"></span><br><span class=\"line\">ExecStart=/usr/local/bin/redis-server /opt/redis-6.2.6/redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\">PrivateTmp=true</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\"></span><br><span class=\"line\">WantedBy=multi-user.target</span><br><span class=\"line\"></span><br><span class=\"line\">--------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"># 开机自动启动</span><br><span class=\"line\">systemctl enable redis.service</span><br><span class=\"line\"># 启动redis服务</span><br><span class=\"line\">systemctl start redis.service</span><br><span class=\"line\"># 查看服务状态</span><br><span class=\"line\">systemctl status redis.service</span><br><span class=\"line\"># 停止服务</span><br><span class=\"line\">systemctl stop redis.service</span><br><span class=\"line\"># 取消开机自动启动(卸载服务)</span><br><span class=\"line\">systemctl disabled redis.service</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"ubuntu安装webbench\"><a href=\"#ubuntu安装webbench\" class=\"headerlink\" title=\"ubuntu安装webbench\"></a>ubuntu安装webbench</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install exuberant-cTags</span><br><span class=\"line\">wget  http://home.tiscali.cz/cz210552/distfiles/webbench-1.5.tar.gz</span><br><span class=\"line\">tar -zvxf webbench-1.5.tar.gz</span><br><span class=\"line\">cd webbench-1.5</span><br><span class=\"line\">make &amp;&amp; sudo make install</span><br><span class=\"line\">webbench --version</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<p>用法：webbench -c 100 -t 10 <a href=\"http://www.iteye.com/\">http://www.iteye.com/</a> </p>\n<p>其中：<br>-c表示并发数，<br>-t表示时间(秒)</p>\n<p> 注意url结尾一定要加上&#x2F;</p>\n<h3 id=\"ubuntu16-04-安装boost1-65\"><a href=\"#ubuntu16-04-安装boost1-65\" class=\"headerlink\" title=\"ubuntu16.04 安装boost1.65\"></a>ubuntu16.04 安装boost1.65</h3><p>参考：<a href=\"https://blog.csdn.net/jiandanjinxin/article/details/65632653\">https://blog.csdn.net/jiandanjinxin/article/details/65632653</a></p>\n<h4 id=\"1-下载源码\"><a href=\"#1-下载源码\" class=\"headerlink\" title=\"1. 下载源码\"></a>1. 下载源码</h4><p><a href=\"https://www.boost.org/users/history/version_1_65_1.html\">https://www.boost.org/users/history/version_1_65_1.html</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">tar -zxvf boost_1_65_1.tar.gz</span><br><span class=\"line\">cd boost_1_65_1</span><br><span class=\"line\">./bootstrap.sh --with-python=PYTHON</span><br><span class=\"line\">./bootstrap.sh –with-libraries=all</span><br><span class=\"line\">会生成 b2和bjam文件。可查看使用方法</span><br><span class=\"line\">./bootstrap.sh -help</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-编译-boost\"><a href=\"#2-编译-boost\" class=\"headerlink\" title=\"2. 编译 boost\"></a>2. 编译 boost</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo ./b2 install </span><br><span class=\"line\">./b2 cxxflags=-fPIC cflags=-fPIC --c++11</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><h3 id=\"ubuntu系统“软件中心”闪退或者打不开解决方法\"><a href=\"#ubuntu系统“软件中心”闪退或者打不开解决方法\" class=\"headerlink\" title=\"ubuntu系统“软件中心”闪退或者打不开解决方法\"></a>ubuntu系统“软件中心”闪退或者打不开解决方法</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get dist-upgrade</span><br><span class=\"line\">sudo apt-get install --reinstall software-center</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"killall-command-not-found\"><a href=\"#killall-command-not-found\" class=\"headerlink\" title=\"killall: command not found\"></a>killall: command not found</h3><h4 id=\"解决：\"><a href=\"#解决：\" class=\"headerlink\" title=\"解决：\"></a>解决：</h4><p>centos 执行如下安装命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install psmisc</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"CentOS-‘mysql-mysql-h‘-No-such-file-or-directory-1\"><a href=\"#CentOS-‘mysql-mysql-h‘-No-such-file-or-directory-1\" class=\"headerlink\" title=\"CentOS ‘mysql&#x2F;mysql.h‘: No such file or directory\"></a>CentOS ‘mysql&#x2F;mysql.h‘: No such file or directory</h3><h4 id=\"解决：-1\"><a href=\"#解决：-1\" class=\"headerlink\" title=\"解决：\"></a>解决：</h4><p>yum install mysql-devel</p>\n<p>然后</p>\n<p>mysql_config</p>\n<p>查看-lmysqlclient这个库 在哪个目录</p>\n<p>然后只需要把之前的编译命令- lmysqlclient替换成 -L&#x2F;usr&#x2F;lib64&#x2F;mysql -lmysqlclient（目录）这个就好了，就能编译过了。</p>\n<p>意思是 不从默认的文件夹&#x2F;usr&#x2F;lib里边取动态库-lmysqlclient从绝对目录里边取。</p>\n<p>所以也可以分析出来出现这个 找不到这个库的原因不是 因为linux机器上没有这个库。</p>\n<p>而是 找错了 位置，如果嫌加绝对目录太麻烦，直接复制一份到&#x2F;usr&#x2F;lib一份就行了</p>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><h3 id=\"linux共享内存\"><a href=\"#linux共享内存\" class=\"headerlink\" title=\"linux共享内存\"></a>linux共享内存</h3><h4 id=\"查看当前共享内存\"><a href=\"#查看当前共享内存\" class=\"headerlink\" title=\"查看当前共享内存\"></a>查看当前共享内存</h4><p>ipcs -m</p>\n<h4 id=\"删除指定共享内存\"><a href=\"#删除指定共享内存\" class=\"headerlink\" title=\"删除指定共享内存\"></a>删除指定共享内存</h4><p>ipcrm -m 32575(shmid)</p>\n<h3 id=\"进程操作\"><a href=\"#进程操作\" class=\"headerlink\" title=\"进程操作\"></a>进程操作</h3><h4 id=\"查看进程\"><a href=\"#查看进程\" class=\"headerlink\" title=\"查看进程\"></a>查看进程</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ps -ef |grep procctl(程序名)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"开机启动进程\"><a href=\"#开机启动进程\" class=\"headerlink\" title=\"开机启动进程\"></a>开机启动进程</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">用root登录 看看有没有这个文件</span><br><span class=\"line\">ls -l /etc/rc.d/rc.local</span><br><span class=\"line\"></span><br><span class=\"line\">vi /etc/rc.d/rc.local</span><br><span class=\"line\"></span><br><span class=\"line\">需要开机启动什么直接在后面加，例如</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"># THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES</span><br><span class=\"line\">#</span><br><span class=\"line\"># It is highly advisable to create own systemd services or udev rules</span><br><span class=\"line\"># to run scripts during boot instead of using this file.</span><br><span class=\"line\">#</span><br><span class=\"line\"># In contrast to previous versions due to parallel execution during boot</span><br><span class=\"line\"># this script will NOT be run after all other services.</span><br><span class=\"line\">#</span><br><span class=\"line\"># Please note that you must run &#x27;chmod +x /etc/rc.d/rc.local&#x27; to ensure</span><br><span class=\"line\"># that this script will be executed during boot.</span><br><span class=\"line\"></span><br><span class=\"line\">touch /var/lock/subsys/local</span><br><span class=\"line\"></span><br><span class=\"line\">#启动守护进程</span><br><span class=\"line\">/project/tools1/bin/procctl 30 /project/tools1/bin/checkproc</span><br><span class=\"line\"></span><br><span class=\"line\">#启动后台服务程序</span><br><span class=\"line\"># su -lijialin -c &quot;/bin/sh /project/idc1/c/start.sh&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">chmod +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"时间操作\"><a href=\"#时间操作\" class=\"headerlink\" title=\"时间操作\"></a>时间操作</h3><h4 id=\"1）查看时间。\"><a href=\"#1）查看时间。\" class=\"headerlink\" title=\"1）查看时间。\"></a>1）查看时间。</h4><p>date （功能描述：显示当前时间）</p>\n<p>date +%Y （功能描述：显示当前年份）</p>\n<p>date +%m（功能描述：显示当前月份）</p>\n<p>date +%d （功能描述：显示当前是哪一天）</p>\n<p>date “+%Y-%m-%d %H:%M:%S”（功能描述：显示年月日时分秒）</p>\n<h4 id=\"2）设置时区为中国上海时间（注意不是北京时间）。\"><a href=\"#2）设置时区为中国上海时间（注意不是北京时间）。\" class=\"headerlink\" title=\"2）设置时区为中国上海时间（注意不是北京时间）。\"></a>2）设置时区为中国上海时间（注意不是北京时间）。</h4><p>cp &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime</p>\n<h4 id=\"3）设置时间。\"><a href=\"#3）设置时间。\" class=\"headerlink\" title=\"3）设置时间。\"></a>3）设置时间。</h4><p>date -s “yyyy-mm-dd hh:mi:ss”</p>\n<h4 id=\"4）cal-指令\"><a href=\"#4）cal-指令\" class=\"headerlink\" title=\"4）cal 指令\"></a>4）cal 指令</h4><p>查看日历指令 cal</p>\n<p>cal [选项] （功能描述：不加选项，显示本月日历）</p>\n<p>案例 1: 显示当前日历 cal</p>\n<p>案例 2: 显示 2020 年日历 : cal 2020</p>\n<h3 id=\"重启和关机\"><a href=\"#重启和关机\" class=\"headerlink\" title=\"重启和关机\"></a>重启和关机</h3><p>1）重启</p>\n<p>init 6 或 reboot</p>\n<p>2）关机</p>\n<p>init 0 或 halt</p>\n<h3 id=\"清屏\"><a href=\"#清屏\" class=\"headerlink\" title=\"清屏\"></a>清屏</h3><p>clear</p>\n<h3 id=\"查看服务器的ip地址\"><a href=\"#查看服务器的ip地址\" class=\"headerlink\" title=\"查看服务器的ip地址\"></a>查看服务器的ip地址</h3><p>ip addr</p>\n<h3 id=\"查看当前工作目录\"><a href=\"#查看当前工作目录\" class=\"headerlink\" title=\"查看当前工作目录\"></a>查看当前工作目录</h3><p>pwd</p>\n<h3 id=\"改变当前工作目录\"><a href=\"#改变当前工作目录\" class=\"headerlink\" title=\"改变当前工作目录\"></a>改变当前工作目录</h3><p>cd 目录名</p>\n<h3 id=\"列出目录和文件信息\"><a href=\"#列出目录和文件信息\" class=\"headerlink\" title=\"列出目录和文件信息\"></a>列出目录和文件信息</h3><p>ls -lt 目录或文件名</p>\n<p>正则表达式</p>\n<p>ls &#x2F;tmp&#x2F;exp*.dmp</p>\n<h3 id=\"创建目录文件\"><a href=\"#创建目录文件\" class=\"headerlink\" title=\"创建目录文件\"></a>创建目录文件</h3><p>mkdir 目录名<br>touch 文件名</p>\n<h3 id=\"删除目录和文件\"><a href=\"#删除目录和文件\" class=\"headerlink\" title=\"删除目录和文件\"></a>删除目录和文件</h3><p>rm -rf 目录或文件列表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">rm -f .*.*.swp</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"移动目录和文件\"><a href=\"#移动目录和文件\" class=\"headerlink\" title=\"移动目录和文件\"></a>移动目录和文件</h3><p>mv 旧目录或文件名 新目录或文件名</p>\n<h3 id=\"复制目录和文件\"><a href=\"#复制目录和文件\" class=\"headerlink\" title=\"复制目录和文件\"></a>复制目录和文件</h3><p>cp -r 旧目录或文件名 新目录或文件名</p>\n<h3 id=\"判断网络是否连通\"><a href=\"#判断网络是否连通\" class=\"headerlink\" title=\"判断网络是否连通\"></a>判断网络是否连通</h3><p>Windows系统：</p>\n<p>ping -n 包的个数 ip地址或域名</p>\n<p>Linux系统：</p>\n<p>ping -c 包的个数 ip地址或域名</p>\n<h3 id=\"用户管理\"><a href=\"#用户管理\" class=\"headerlink\" title=\"用户管理\"></a>用户管理</h3><h4 id=\"查询用户信息\"><a href=\"#查询用户信息\" class=\"headerlink\" title=\"查询用户信息\"></a>查询用户信息</h4><p>id 用户名<br>whoami&#x2F;who am I</p>\n<h4 id=\"用户和组相关文件\"><a href=\"#用户和组相关文件\" class=\"headerlink\" title=\"用户和组相关文件\"></a>用户和组相关文件</h4><ul>\n<li><p>&#x2F;etc&#x2F;passwd 文件<br>用户（user）的配置文件，记录用户的各种信息<br>每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 Shell</p>\n</li>\n<li><p>&#x2F;etc&#x2F;shadow 文件<br>口令的配置文件<br>每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</p>\n</li>\n<li><p>&#x2F;etc&#x2F;group 文件<br>组(group)的配置文件，记录 Linux 包含的组的信息<br>每行含义：组名:口令:组标识号:组内用户列表</p>\n</li>\n</ul>\n<h4 id=\"增加-删除用户组\"><a href=\"#增加-删除用户组\" class=\"headerlink\" title=\"增加&#x2F;删除用户组\"></a>增加&#x2F;删除用户组</h4><p>1）增加用户组</p>\n<p>groupadd 组名</p>\n<p>2）删除用户组</p>\n<p>groupdel 组名</p>\n<h4 id=\"增加-删除用户\"><a href=\"#增加-删除用户\" class=\"headerlink\" title=\"增加&#x2F;删除用户\"></a>增加&#x2F;删除用户</h4><p>1）增加用户</p>\n<p>useradd 用户名<br>useradd -d 指定目录 用户名<br>useradd -g 用户组 用户名<br>passwd 用户名</p>\n<p>useradd -n 用户名 -g 组名 -d 用户的主目录</p>\n<p>2）删除用户</p>\n<p>&#x2F;&#x2F;保留用户主目录<br>userdel 用户名<br>&#x2F;&#x2F;删除用户以及主目录<br>userdel -r 用户名</p>\n<p>userdel 用户名</p>\n<h4 id=\"修改用户的组\"><a href=\"#修改用户的组\" class=\"headerlink\" title=\"修改用户的组\"></a>修改用户的组</h4><p>usermod –g 用户组 用户名</p>\n<h4 id=\"修改用户的密码\"><a href=\"#修改用户的密码\" class=\"headerlink\" title=\"修改用户的密码\"></a>修改用户的密码</h4><p>passwd 用户名</p>\n<h4 id=\"切换用户\"><a href=\"#切换用户\" class=\"headerlink\" title=\"切换用户\"></a>切换用户</h4><p>su - 用户名</p>\n<p>exit&#x2F;logout</p>\n<p>从root用户切换到其它普通用户不需要输入密码</p>\n<h3 id=\"修改目录和文件的主人和组\"><a href=\"#修改目录和文件的主人和组\" class=\"headerlink\" title=\"修改目录和文件的主人和组\"></a>修改目录和文件的主人和组</h3><p>chown [-R] 用户名:组名 目录或文件名列表</p>\n<p>-R 选项表示处理各及子目录。</p>\n<p>1）把&#x2F;oracle&#x2F;home和&#x2F;oracle&#x2F;base及其子目录的主人改为oracle，组改为dba。</p>\n<p>chown -R oracle:dba &#x2F;oracle&#x2F;home &#x2F;oracle&#x2F;base</p>\n<h3 id=\"查看系统磁盘空间\"><a href=\"#查看系统磁盘空间\" class=\"headerlink\" title=\"查看系统磁盘空间\"></a>查看系统磁盘空间</h3><p>df [-h] [-T]</p>\n<p>-h 以方便阅读的方式显示信息。</p>\n<p>-T 列出文件系统类型。</p>\n<h3 id=\"echo-指令\"><a href=\"#echo-指令\" class=\"headerlink\" title=\"echo 指令\"></a>echo 指令</h3><p>echo 输出内容到控制台</p>\n<ul>\n<li>基本语法</li>\n</ul>\n<p>echo [选项] [输出内容]</p>\n<h2 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h2><h3 id=\"public框架\"><a href=\"#public框架\" class=\"headerlink\" title=\"public框架:\"></a>public框架:</h3><h4 id=\"心跳程序-框架中的心跳类\"><a href=\"#心跳程序-框架中的心跳类\" class=\"headerlink\" title=\"心跳程序-框架中的心跳类\"></a>心跳程序-框架中的心跳类</h4><h5 id=\"public-h\"><a href=\"#public-h\" class=\"headerlink\" title=\"_public.h\"></a>_public.h</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 信号量。</span><br><span class=\"line\">class CSEM</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">  union semun  // 用于信号量操作的共同体。</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    int val;</span><br><span class=\"line\">    struct semid_ds *buf;</span><br><span class=\"line\">    unsigned short  *arry;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  int   m_semid;         // 信号量描述符。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 如果把sem_flg设置为SEM_UNDO，操作系统将跟踪进程对信号量的修改情况，</span><br><span class=\"line\">  // 在全部修改过信号量的进程（正常或异常）终止后，操作系统将把信号量恢</span><br><span class=\"line\">  // 复为初始值（就像撤消了全部进程对信号的操作）。</span><br><span class=\"line\">  // 如果信号量用于表示可用资源的数量（不变的），设置为SEM_UNDO更合适。</span><br><span class=\"line\">  // 如果信号量用于生产消费者模型，设置为0更合适。</span><br><span class=\"line\">  // 注意，网上查到的关于sem_flg的用法基本上是错的，一定要自己动手多测试。</span><br><span class=\"line\">  short m_sem_flg;</span><br><span class=\"line\">public:</span><br><span class=\"line\">  CSEM();</span><br><span class=\"line\">  // 如果信号量已存在，获取信号量；如果信号量不存在，则创建它并初始化为value。</span><br><span class=\"line\">  bool init(key_t key,unsigned short value=1,short sem_flg=SEM_UNDO); </span><br><span class=\"line\">  bool P(short sem_op=-1); // 信号量的P操作。</span><br><span class=\"line\">  bool V(short sem_op=1);  // 信号量的V操作。</span><br><span class=\"line\">  int  value();            // 获取信号量的值，成功返回信号量的值，失败返回-1。</span><br><span class=\"line\">  bool destroy();          // 销毁信号量。</span><br><span class=\"line\"> ~CSEM();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 进程心跳信息的结构体。</span><br><span class=\"line\">struct st_procinfo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int    pid;         // 进程id。</span><br><span class=\"line\">  char   pname[51];   // 进程名称，可以为空。</span><br><span class=\"line\">  int    timeout;     // 超时时间，单位：秒。</span><br><span class=\"line\">  time_t atime;       // 最后一次心跳的时间，用整数表示。</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">#define MAXNUMP     1000    // 最大的进程数量。</span><br><span class=\"line\">#define SHMKEYP   0x5095    // 共享内存的key。</span><br><span class=\"line\">#define SEMKEYP   0x5095    // 信号量的key。</span><br><span class=\"line\"></span><br><span class=\"line\">// 查看共享内存：  ipcs -m</span><br><span class=\"line\">// 删除共享内存：  ipcrm -m shmid</span><br><span class=\"line\">// 查看信号量：    ipcs -s</span><br><span class=\"line\">// 删除信号量：    ipcrm sem semid</span><br><span class=\"line\"></span><br><span class=\"line\">// 进程心跳操作类。</span><br><span class=\"line\">class CPActive</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">  CSEM m_sem;                 // 用于给共享内存加锁的信号量id。</span><br><span class=\"line\">  int  m_shmid;               // 共享内存的id。</span><br><span class=\"line\">  int  m_pos;                 // 当前进程在共享内存进程组中的位置。</span><br><span class=\"line\">  st_procinfo *m_shm;         // 指向共享内存的地址空间。</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">  CPActive();  // 初始化成员变量。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把当前进程的心跳信息加入共享内存进程组中。</span><br><span class=\"line\">  bool AddPInfo(const int timeout,const char *pname=0,CLogFile *logfile=0);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 更新共享内存进程组中当前进程的心跳时间。</span><br><span class=\"line\">  bool UptATime();</span><br><span class=\"line\"></span><br><span class=\"line\">  ~CPActive();  // 从共享内存中删除当前进程的心跳记录。</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"public-cpp\"><a href=\"#public-cpp\" class=\"headerlink\" title=\"_public.cpp\"></a>_public.cpp</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CSEM::CSEM()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  m_semid=-1;</span><br><span class=\"line\">  m_sem_flg=SEM_UNDO;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果信号量已存在，获取信号量；如果信号量不存在，则创建它并初始化为value。</span><br><span class=\"line\">bool CSEM::init(key_t key,unsigned short value,short sem_flg)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (m_semid!=-1) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  m_sem_flg=sem_flg;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 信号量的初始化不能直接用semget(key,1,0666|IPC_CREAT)，因为信号量创建后，初始值是0。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 信号量的初始化分三个步骤：</span><br><span class=\"line\">  // 1）获取信号量，如果成功，函数返回。</span><br><span class=\"line\">  // 2）如果失败，则创建信号量。</span><br><span class=\"line\">  // 3) 设置信号量的初始值。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取信号量。</span><br><span class=\"line\">  if ( (m_semid=semget(key,1,0666)) == -1)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 如果信号量不存在，创建它。</span><br><span class=\"line\">    if (errno==2)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 用IPC_EXCL标志确保只有一个进程创建并初始化信号量，其它进程只能获取。</span><br><span class=\"line\">      if ( (m_semid=semget(key,1,0666|IPC_CREAT|IPC_EXCL)) == -1)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        if (errno!=EEXIST)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          perror(&quot;init 1 semget()&quot;); return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if ( (m_semid=semget(key,1,0666)) == -1)</span><br><span class=\"line\">        &#123; perror(&quot;init 2 semget()&quot;); return false; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 信号量创建成功后，还需要把它初始化成value。</span><br><span class=\"line\">      union semun sem_union;</span><br><span class=\"line\">      sem_union.val = value;   // 设置信号量的初始值。</span><br><span class=\"line\">      if (semctl(m_semid,0,SETVAL,sem_union) &lt;  0) &#123; perror(&quot;init semctl()&quot;); return false; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123; perror(&quot;init 3 semget()&quot;); return false; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool CSEM::P(short sem_op)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (m_semid==-1) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  struct sembuf sem_b;</span><br><span class=\"line\">  sem_b.sem_num = 0;      // 信号量编号，0代表第一个信号量。</span><br><span class=\"line\">  sem_b.sem_op = sem_op;  // P操作的sem_op必须小于0。</span><br><span class=\"line\">  sem_b.sem_flg = m_sem_flg;   </span><br><span class=\"line\">  if (semop(m_semid,&amp;sem_b,1) == -1) &#123; perror(&quot;p semop()&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool CSEM::V(short sem_op)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (m_semid==-1) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  struct sembuf sem_b;</span><br><span class=\"line\">  sem_b.sem_num = 0;      // 信号量编号，0代表第一个信号量。</span><br><span class=\"line\">  sem_b.sem_op = sem_op;  // V操作的sem_op必须大于0。</span><br><span class=\"line\">  sem_b.sem_flg = m_sem_flg;</span><br><span class=\"line\">  if (semop(m_semid,&amp;sem_b,1) == -1) &#123; perror(&quot;V semop()&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 获取信号量的值，成功返回信号量的值，失败返回-1。</span><br><span class=\"line\">int CSEM::value()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return semctl(m_semid,0,GETVAL);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool CSEM::destroy()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (m_semid==-1) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (semctl(m_semid,0,IPC_RMID) == -1) &#123; perror(&quot;destroy semctl()&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CSEM::~CSEM()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CPActive::CPActive()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  m_shmid=0;</span><br><span class=\"line\">  m_pos=-1;</span><br><span class=\"line\">  m_shm=0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把当前进程的心跳信息加入共享内存进程组中。</span><br><span class=\"line\">bool CPActive::AddPInfo(const int timeout,const char *pname,CLogFile *logfile)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (m_pos!=-1) return true;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (m_sem.init(SEMKEYP) == false)  // 初始化信号量。</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    if (logfile!=0) logfile-&gt;Write(&quot;创建/获取信号量(%x)失败。\\n&quot;,SEMKEYP); </span><br><span class=\"line\">    else printf(&quot;创建/获取信号量(%x)失败。\\n&quot;,SEMKEYP);</span><br><span class=\"line\"></span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 创建/获取共享内存，键值为SHMKEYP，大小为MAXNUMP个st_procinfo结构体的大小。</span><br><span class=\"line\">  if ( (m_shmid = shmget((key_t)SHMKEYP, MAXNUMP*sizeof(struct st_procinfo), 0666|IPC_CREAT)) == -1)</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    if (logfile!=0) logfile-&gt;Write(&quot;创建/获取共享内存(%x)失败。\\n&quot;,SHMKEYP); </span><br><span class=\"line\">    else printf(&quot;创建/获取共享内存(%x)失败。\\n&quot;,SHMKEYP);</span><br><span class=\"line\"></span><br><span class=\"line\">    return false; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将共享内存连接到当前进程的地址空间。</span><br><span class=\"line\">  m_shm=(struct st_procinfo *)shmat(m_shmid, 0, 0);</span><br><span class=\"line\">  </span><br><span class=\"line\">  struct st_procinfo stprocinfo;    // 当前进程心跳信息的结构体。</span><br><span class=\"line\">  memset(&amp;stprocinfo,0,sizeof(stprocinfo));</span><br><span class=\"line\"></span><br><span class=\"line\">  stprocinfo.pid=getpid();            // 当前进程号。</span><br><span class=\"line\">  stprocinfo.timeout=timeout;         // 超时时间。</span><br><span class=\"line\">  stprocinfo.atime=time(0);           // 当前时间。</span><br><span class=\"line\">  STRNCPY(stprocinfo.pname,sizeof(stprocinfo.pname),pname,50); // 进程名。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 进程id是循环使用的，如果曾经有一个进程异常退出，没有清理自己的心跳信息，</span><br><span class=\"line\">  // 它的进程信息将残留在共享内存中，不巧的是，当前进程重用了上述进程的id，</span><br><span class=\"line\">  // 这样就会在共享内存中存在两个进程id相同的记录，守护进程检查到残留进程的</span><br><span class=\"line\">  // 心跳时，会向进程id发送退出信号，这个信号将误杀当前进程。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 如果共享内存中存在当前进程编号，一定是其它进程残留的数据，当前进程就重用该位置。</span><br><span class=\"line\">  for (int ii=0;ii&lt;MAXNUMP;ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    if ( (m_shm+ii)-&gt;pid==stprocinfo.pid ) &#123; m_pos=ii; break; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  m_sem.P();  // 给共享内存上锁。</span><br><span class=\"line\"></span><br><span class=\"line\">  if (m_pos==-1)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 如果m_pos==-1，共享内存的进程组中不存在当前进程编号，找一个空位置。</span><br><span class=\"line\">    for (int ii=0;ii&lt;MAXNUMP;ii++)</span><br><span class=\"line\">      if ( (m_shm+ii)-&gt;pid==0 ) &#123; m_pos=ii; break; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (m_pos==-1) </span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    if (logfile!=0) logfile-&gt;Write(&quot;共享内存空间已用完。\\n&quot;);</span><br><span class=\"line\">    else printf(&quot;共享内存空间已用完。\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    m_sem.V();  // 解锁。</span><br><span class=\"line\"></span><br><span class=\"line\">    return false; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把当前进程的心跳信息存入共享内存的进程组中。</span><br><span class=\"line\">  memcpy(m_shm+m_pos,&amp;stprocinfo,sizeof(struct st_procinfo)); </span><br><span class=\"line\"></span><br><span class=\"line\">  m_sem.V();   // 解锁。</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 更新共享内存进程组中当前进程的心跳时间。</span><br><span class=\"line\">bool CPActive::UptATime()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (m_pos==-1) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  (m_shm+m_pos)-&gt;atime=time(0);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CPActive::~CPActive()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 把当前进程从共享内存的进程组中移去。</span><br><span class=\"line\">  if (m_pos!=-1) memset(m_shm+m_pos,0,sizeof(struct st_procinfo));</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把共享内存从当前进程中分离。</span><br><span class=\"line\">  if (m_shm!=0) shmdt(m_shm);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"调度程序\"><a href=\"#调度程序\" class=\"headerlink\" title=\"调度程序\"></a>调度程序</h4><p>procctl.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;sys/types.h&gt;</span><br><span class=\"line\">#include &lt;sys/wait.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (argc&lt;3)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;Using:./procctl timetvl program argv ...\\n&quot;);</span><br><span class=\"line\">    printf(&quot;Example:/project/tools1/bin/procctl 5 /usr/bin/tar zcvf /tmp/tmp.tgz /usr/include\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;本程序是服务程序的调度程序，周期性启动服务程序或shell脚本。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;timetvl 运行周期，单位：秒。被调度的程序运行结束后，在timetvl秒后会被procctl重新启动。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;program 被调度的程序名，必须使用全路径。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;argvs   被调度的程序的参数。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;注意，本程序不会被kill杀死，但可以用kill -9强行杀死。\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭信号和IO，本程序不希望被打扰。</span><br><span class=\"line\">  for (int ii=0;ii&lt;64;ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    signal(ii,SIG_IGN); close(ii);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 生成子进程，父进程退出，让程序运行在后台，由系统1号进程托管。</span><br><span class=\"line\">  if (fork()!=0) exit(0);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 启用SIGCHLD信号，让父进程可以wait子进程退出的状态。</span><br><span class=\"line\">  signal(SIGCHLD,SIG_DFL);</span><br><span class=\"line\"></span><br><span class=\"line\">  char *pargv[argc];</span><br><span class=\"line\">  for (int ii=2;ii&lt;argc;ii++)</span><br><span class=\"line\">    pargv[ii-2]=argv[ii];</span><br><span class=\"line\"></span><br><span class=\"line\">  pargv[argc-2]=NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    if (fork()==0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      execv(argv[2],pargv);</span><br><span class=\"line\">      exit(0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      int status;</span><br><span class=\"line\">      wait(&amp;status);</span><br><span class=\"line\">      sleep(atoi(argv[1]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"编译文件\"><a href=\"#编译文件\" class=\"headerlink\" title=\"编译文件\"></a>编译文件</h5><p>makefile</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">all: procctl </span><br><span class=\"line\"></span><br><span class=\"line\">procctl:procctl.cpp</span><br><span class=\"line\">\tg++ -o procctl procctl.cpp</span><br><span class=\"line\">\tcp procctl ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -f procctl </span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"守护进程程序\"><a href=\"#守护进程程序\" class=\"headerlink\" title=\"守护进程程序\"></a>守护进程程序</h4><p>checkproc.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序运行的日志。</span><br><span class=\"line\">CLogFile logfile;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 程序的帮助。</span><br><span class=\"line\">  if (argc != 2)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;\\n&quot;);</span><br><span class=\"line\">    printf(&quot;Using:./checkproc logfilename\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;Example:/project/tools1/bin/procctl 10 /project/tools1/bin/checkproc /tmp/log/checkproc.log\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;本程序用于检查后台服务程序是否超时，如果已超时，就终止它。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;注意：\\n&quot;);</span><br><span class=\"line\">    printf(&quot;  1）本程序由procctl启动，运行周期建议为10秒。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;  2）为了避免被普通用户误杀，本程序应该用root用户启动。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;  3）如果要停止本程序，只能用killall -9 终止。\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 忽略全部的信号和IO，不希望程序被干扰。</span><br><span class=\"line\">  CloseIOAndSignal(true);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 打开日志文件。</span><br><span class=\"line\">  if (logfile.Open(argv[1],&quot;a+&quot;)==false)</span><br><span class=\"line\">  &#123; printf(&quot;logfile.Open(%s) failed.\\n&quot;,argv[1]); return -1; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  int shmid=0;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 创建/获取共享内存，键值为SHMKEYP，大小为MAXNUMP个st_procinfo结构体的大小。</span><br><span class=\"line\">  if ( (shmid = shmget((key_t)SHMKEYP, MAXNUMP*sizeof(struct st_procinfo), 0666|IPC_CREAT)) == -1)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;创建/获取共享内存(%x)失败。\\n&quot;,SHMKEYP); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将共享内存连接到当前进程的地址空间。</span><br><span class=\"line\">  struct st_procinfo *shm=(struct st_procinfo *)shmat(shmid, 0, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历共享内存中全部的记录。</span><br><span class=\"line\">  for (int ii=0;ii&lt;MAXNUMP;ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 如果记录的pid==0，表示空记录，continue;</span><br><span class=\"line\">    if (shm[ii].pid==0) continue;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果记录的pid!=0，表示是服务程序的心跳记录。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 程序稳定运行后，以下两行代码可以注释掉。</span><br><span class=\"line\">    //logfile.Write(&quot;ii=%d,pid=%d,pname=%s,timeout=%d,atime=%d\\n&quot;,\\</span><br><span class=\"line\">    //               ii,shm[ii].pid,shm[ii].pname,shm[ii].timeout,shm[ii].atime);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 向进程发送信号0，判断它是否还存在，如果不存在，从共享内存中删除该记录，continue;</span><br><span class=\"line\">    int iret=kill(shm[ii].pid,0);</span><br><span class=\"line\">    if (iret==-1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.Write(&quot;进程pid=%d(%s)已经不存在。\\n&quot;,(shm+ii)-&gt;pid,(shm+ii)-&gt;pname);</span><br><span class=\"line\">      memset(shm+ii,0,sizeof(struct st_procinfo)); // 从共享内存中删除该记录。</span><br><span class=\"line\">      continue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    time_t now=time(0);   // 取当前时间。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果进程未超时，continue;</span><br><span class=\"line\">    if (now-shm[ii].atime&lt;shm[ii].timeout) continue;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果已超时。</span><br><span class=\"line\">    logfile.Write(&quot;进程pid=%d(%s)已经超时。\\n&quot;,(shm+ii)-&gt;pid,(shm+ii)-&gt;pname);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 发送信号15，尝试正常终止进程。</span><br><span class=\"line\">    kill(shm[ii].pid,15);     </span><br><span class=\"line\"></span><br><span class=\"line\">    // 每隔1秒判断一次进程是否存在，累计5秒，一般来说，5秒的时间足够让进程退出。</span><br><span class=\"line\">    for (int jj=0;jj&lt;5;jj++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      sleep(1);</span><br><span class=\"line\">      iret=kill(shm[ii].pid,0);     // 向进程发送信号0，判断它是否还存在。</span><br><span class=\"line\">      if (iret==-1) break;     // 进程已退出。</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果进程仍存在，就发送信号9，强制终止它。</span><br><span class=\"line\">    if (iret==-1)</span><br><span class=\"line\">      logfile.Write(&quot;进程pid=%d(%s)已经正常终止。\\n&quot;,(shm+ii)-&gt;pid,(shm+ii)-&gt;pname);</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      kill(shm[ii].pid,9);  // 如果进程仍存在，就发送信号9，强制终止它。</span><br><span class=\"line\">      logfile.Write(&quot;进程pid=%d(%s)已经强制终止。\\n&quot;,(shm+ii)-&gt;pid,(shm+ii)-&gt;pname);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 从共享内存中删除已超时进程的心跳记录。</span><br><span class=\"line\">    memset(shm+ii,0,sizeof(struct st_procinfo)); // 从共享内存中删除该记录。</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把共享内存从当前进程中分离。</span><br><span class=\"line\">  shmdt(shm);</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"编译文件-1\"><a href=\"#编译文件-1\" class=\"headerlink\" title=\"编译文件\"></a>编译文件</h5><p>makefile</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 开发框架头文件路径。</span><br><span class=\"line\">PUBINCL = -I/project/public</span><br><span class=\"line\"></span><br><span class=\"line\"># 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。</span><br><span class=\"line\">PUBCPP = /project/public/_public.cpp</span><br><span class=\"line\"></span><br><span class=\"line\"># 编译参数。</span><br><span class=\"line\">CFLAGS = -g</span><br><span class=\"line\"></span><br><span class=\"line\">all: checkproc </span><br><span class=\"line\"></span><br><span class=\"line\">checkproc:checkproc.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o checkproc checkproc.cpp $(PUBINCL) $(PUBCPP) -lm -lc</span><br><span class=\"line\">\tcp checkproc ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -f checkproc</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"压缩文件程序\"><a href=\"#压缩文件程序\" class=\"headerlink\" title=\"压缩文件程序\"></a>压缩文件程序</h4><p>gzipfiles.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序退出和信号2、15的处理函数。</span><br><span class=\"line\">void EXIT(int sig);</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 程序的帮助。</span><br><span class=\"line\">  if (argc != 4)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;\\n&quot;);</span><br><span class=\"line\">    printf(&quot;Using:/project/tools1/bin/gzipfiles pathname matchstr timeout\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;Example:/project/tools1/bin/gzipfiles /log/idc \\&quot;*.log.20*\\&quot; 0.02\\n&quot;);</span><br><span class=\"line\">    printf(&quot;        /project/tools1/bin/gzipfiles /tmp/idc/surfdata \\&quot;*.xml,*.json\\&quot; 0.01\\n&quot;);</span><br><span class=\"line\">    printf(&quot;        /project/tools1/bin/procctl 300 /project/tools1/bin/gzipfiles /log/idc \\&quot;*.log.20*\\&quot; 0.02\\n&quot;);</span><br><span class=\"line\">    printf(&quot;        /project/tools1/bin/procctl 300 /project/tools1/bin/gzipfiles /tmp/idc/surfdata \\&quot;*.xml,*.json\\&quot; 0.01\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;这是一个工具程序，用于压缩历史的数据文件或日志文件。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;本程序把pathname目录及子目录中timeout天之前的匹配matchstr文件全部压缩，timeout可以是小数。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;本程序不写日志文件，也不会在控制台输出任何信息。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;本程序调用/usr/bin/gzip命令压缩文件。\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭全部的信号和输入输出。</span><br><span class=\"line\">  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。</span><br><span class=\"line\">  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。</span><br><span class=\"line\">  CloseIOAndSignal(true); signal(SIGINT,EXIT);  signal(SIGTERM,EXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取文件超时的时间点。</span><br><span class=\"line\">  char strTimeOut[21];</span><br><span class=\"line\">  LocalTime(strTimeOut,&quot;yyyy-mm-dd hh24:mi:ss&quot;,0-(int)(atof(argv[3])*24*60*60));</span><br><span class=\"line\"></span><br><span class=\"line\">  CDir Dir;</span><br><span class=\"line\">  // 打开目录，CDir.OpenDir()</span><br><span class=\"line\">  if (Dir.OpenDir(argv[1],argv[2],10000,true)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;Dir.OpenDir(%s) failed.\\n&quot;,argv[1]); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  char strCmd[1024]; // 存放gzip压缩文件的命令。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历目录中的文件名。</span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 得到一个文件的信息，CDir.ReadDir()</span><br><span class=\"line\">    if (Dir.ReadDir()==false) break;</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 与超时的时间点比较，如果更早，就需要压缩</span><br><span class=\"line\">    if ( (strcmp(Dir.m_ModifyTime,strTimeOut)&lt;0) &amp;&amp; (MatchStr(Dir.m_FileName,&quot;*.gz&quot;)==false) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 压缩文件，调用操作系统的gzip命令。</span><br><span class=\"line\">      SNPRINTF(strCmd,sizeof(strCmd),1000,&quot;/usr/bin/gzip -f %s 1&gt;/dev/null 2&gt;/dev/null&quot;,Dir.m_FullFileName);</span><br><span class=\"line\">      if (system(strCmd)==0) </span><br><span class=\"line\">        printf(&quot;gzip %s ok.\\n&quot;,Dir.m_FullFileName);</span><br><span class=\"line\">      else</span><br><span class=\"line\">        printf(&quot;gzip %s failed.\\n&quot;,Dir.m_FullFileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EXIT(int sig)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;程序退出，sig=%d\\n\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"编译文件-2\"><a href=\"#编译文件-2\" class=\"headerlink\" title=\"编译文件\"></a>编译文件</h5><p>makefile</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 开发框架头文件路径。</span><br><span class=\"line\">PUBINCL = -I/project/public</span><br><span class=\"line\"></span><br><span class=\"line\"># 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。</span><br><span class=\"line\">PUBCPP = /project/public/_public.cpp</span><br><span class=\"line\"></span><br><span class=\"line\"># 编译参数。</span><br><span class=\"line\">CFLAGS = -g</span><br><span class=\"line\"></span><br><span class=\"line\">all: gzipfiles</span><br><span class=\"line\"></span><br><span class=\"line\">gzipfiles:gzipfiles.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o gzipfiles gzipfiles.cpp $(PUBINCL) $(PUBCPP) -lm -lc</span><br><span class=\"line\">\tcp gzipfiles ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -f gzipfiles</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"清理文件程序\"><a href=\"#清理文件程序\" class=\"headerlink\" title=\"清理文件程序\"></a>清理文件程序</h4><p>deletefiles.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序退出和信号2、15的处理函数。</span><br><span class=\"line\">void EXIT(int sig);</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 程序的帮助。</span><br><span class=\"line\">  if (argc != 4)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;\\n&quot;);</span><br><span class=\"line\">    printf(&quot;Using:/project/tools1/bin/deletefiles pathname matchstr timeout\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;Example:/project/tools1/bin/deletefiles /log/idc \\&quot;*.log.20*\\&quot; 0.02\\n&quot;);</span><br><span class=\"line\">    printf(&quot;        /project/tools1/bin/deletefiles /tmp/idc/surfdata \\&quot;*.xml,*.json\\&quot; 0.01\\n&quot;);</span><br><span class=\"line\">    printf(&quot;        /project/tools1/bin/procctl 300 /project/tools1/bin/deletefiles /log/idc \\&quot;*.log.20*\\&quot; 0.02\\n&quot;);</span><br><span class=\"line\">    printf(&quot;        /project/tools1/bin/procctl 300 /project/tools1/bin/deletefiles /tmp/idc/surfdata \\&quot;*.xml,*.json\\&quot; 0.01\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;这是一个工具程序，用于删除历史的数据文件或日志文件。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;本程序把pathname目录及子目录中timeout天之前的匹配matchstr文件全部删除，timeout可以是小数。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;本程序不写日志文件，也不会在控制台输出任何信息。\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭全部的信号和输入输出。</span><br><span class=\"line\">  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。</span><br><span class=\"line\">  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。</span><br><span class=\"line\">  // CloseIOAndSignal(true); </span><br><span class=\"line\">  signal(SIGINT,EXIT);  signal(SIGTERM,EXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取文件超时的时间点。</span><br><span class=\"line\">  char strTimeOut[21];</span><br><span class=\"line\">  LocalTime(strTimeOut,&quot;yyyy-mm-dd hh24:mi:ss&quot;,0-(int)(atof(argv[3])*24*60*60));</span><br><span class=\"line\"></span><br><span class=\"line\">  CDir Dir;</span><br><span class=\"line\">  // 打开目录，CDir.OpenDir()</span><br><span class=\"line\">  if (Dir.OpenDir(argv[1],argv[2],10000,true)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;Dir.OpenDir(%s) failed.\\n&quot;,argv[1]); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历目录中的文件名。</span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 得到一个文件的信息，CDir.ReadDir()</span><br><span class=\"line\">    if (Dir.ReadDir()==false) break;</span><br><span class=\"line\">printf(&quot;=%s=\\n&quot;,Dir.m_FullFileName);  </span><br><span class=\"line\">    // 与超时的时间点比较，如果更早，就需要删除。</span><br><span class=\"line\">    if (strcmp(Dir.m_ModifyTime,strTimeOut)&lt;0) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      if (REMOVE(Dir.m_FullFileName)==0) </span><br><span class=\"line\">        printf(&quot;REMOVE %s ok.\\n&quot;,Dir.m_FullFileName);</span><br><span class=\"line\">      else</span><br><span class=\"line\">        printf(&quot;REMOVE %s failed.\\n&quot;,Dir.m_FullFileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EXIT(int sig)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;程序退出，sig=%d\\n\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"编译文件-3\"><a href=\"#编译文件-3\" class=\"headerlink\" title=\"编译文件\"></a>编译文件</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 开发框架头文件路径。</span><br><span class=\"line\">PUBINCL = -I/project/public</span><br><span class=\"line\"></span><br><span class=\"line\"># 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。</span><br><span class=\"line\">PUBCPP = /project/public/_public.cpp</span><br><span class=\"line\"></span><br><span class=\"line\"># 编译参数。</span><br><span class=\"line\">CFLAGS = -g</span><br><span class=\"line\"></span><br><span class=\"line\">all: deletefiles</span><br><span class=\"line\"></span><br><span class=\"line\">deletefiles:deletefiles.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o deletefiles deletefiles.cpp $(PUBINCL) $(PUBCPP) -lm -lc</span><br><span class=\"line\">\tcp deletefiles ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -f deletefiles</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"模拟生产测试数据文件\"><a href=\"#模拟生产测试数据文件\" class=\"headerlink\" title=\"模拟生产测试数据文件\"></a>模拟生产测试数据文件</h4><p>crtsurfdata.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  程序名：crtsurfdata.cpp  本程序用于生成全国气象站点观测的分钟数据。</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">CPActive PActive;   // 进程心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">// 全国气象站点参数结构体。</span><br><span class=\"line\">struct st_stcode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char provname[31]; // 省</span><br><span class=\"line\">  char obtid[11];    // 站号</span><br><span class=\"line\">  char obtname[31];  // 站名</span><br><span class=\"line\">  double lat;        // 纬度</span><br><span class=\"line\">  double lon;        // 经度</span><br><span class=\"line\">  double height;     // 海拔高度</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;struct st_stcode&gt; vstcode; // 存放全国气象站点参数的容器。</span><br><span class=\"line\"></span><br><span class=\"line\">// 把站点参数文件中加载到vstcode容器中。</span><br><span class=\"line\">bool LoadSTCode(const char *inifile);</span><br><span class=\"line\"></span><br><span class=\"line\">// 全国气象站点分钟观测数据结构</span><br><span class=\"line\">struct st_surfdata</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char obtid[11];      // 站点代码。</span><br><span class=\"line\">  char ddatetime[21];  // 数据时间：格式yyyymmddhh24miss</span><br><span class=\"line\">  int  t;              // 气温：单位，0.1摄氏度。</span><br><span class=\"line\">  int  p;              // 气压：0.1百帕。</span><br><span class=\"line\">  int  u;              // 相对湿度，0-100之间的值。</span><br><span class=\"line\">  int  wd;             // 风向，0-360之间的值。</span><br><span class=\"line\">  int  wf;             // 风速：单位0.1m/s</span><br><span class=\"line\">  int  r;              // 降雨量：0.1mm。</span><br><span class=\"line\">  int  vis;            // 能见度：0.1米。</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;struct st_surfdata&gt; vsurfdata;  // 存放全国气象站点分钟观测数据的容器</span><br><span class=\"line\"></span><br><span class=\"line\">char strddatetime[21]; // 观测数据的时间。</span><br><span class=\"line\"></span><br><span class=\"line\">// 模拟生成全国气象站点分钟观测数据，存放在vsurfdata容器中。</span><br><span class=\"line\">void CrtSurfData();</span><br><span class=\"line\"></span><br><span class=\"line\">CFile File;  // 文件操作对象。</span><br><span class=\"line\"></span><br><span class=\"line\">// 把容器vsurfdata中的全国气象站点分钟观测数据写入文件。</span><br><span class=\"line\">bool CrtSurfFile(const char *outpath,const char *datafmt);</span><br><span class=\"line\"></span><br><span class=\"line\">CLogFile logfile;    // 日志类。</span><br><span class=\"line\"></span><br><span class=\"line\">void EXIT(int sig);  // 程序退出和信号2、15的处理函数。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if ( (argc!=5) &amp;&amp; (argc!=6) )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 如果参数非法，给出帮助文档。</span><br><span class=\"line\">    printf(&quot;Using:./crtsurfdata inifile outpath logfile datafmt [datetime]\\n&quot;);</span><br><span class=\"line\">    printf(&quot;Example:/project/idc1/bin/crtsurfdata /project/idc1/ini/stcode.ini /tmp/idc/surfdata /log/idc/crtsurfdata.log xml,json,csv\\n&quot;);</span><br><span class=\"line\">    printf(&quot;        /project/idc1/bin/crtsurfdata /project/idc1/ini/stcode.ini /tmp/idc/surfdata /log/idc/crtsurfdata.log xml,json,csv 20210710123000\\n&quot;);</span><br><span class=\"line\">    printf(&quot;        /project/tools1/bin/procctl 60 /project/idc1/bin/crtsurfdata /project/idc1/ini/stcode.ini /tmp/idc/surfdata /log/idc/crtsurfdata.log xml,json,csv\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;inifile  全国气象站点参数文件名。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;outpath  全国气象站点数据文件存放的目录。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;logfile  本程序运行的日志文件名。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;datafmt  生成数据文件的格式，支持xml、json和csv三种格式，中间用逗号分隔。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;datetime 这是一个可选参数，表示生成指定时间的数据和文件。\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭全部的信号和输入输出。</span><br><span class=\"line\">  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。</span><br><span class=\"line\">  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。</span><br><span class=\"line\">  CloseIOAndSignal(true); signal(SIGINT,EXIT);  signal(SIGTERM,EXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 打开程序的日志文件。</span><br><span class=\"line\">  if (logfile.Open(argv[3],&quot;a+&quot;,false)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;logfile.Open(%s) failed.\\n&quot;,argv[3]); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  logfile.Write(&quot;crtsurfdata 开始运行。\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.AddPInfo(20,&quot;crtsurfdata&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把站点参数文件中加载到vstcode容器中。 </span><br><span class=\"line\">  if (LoadSTCode(argv[1])==false) return -1;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取当前时间，当作观测时间。</span><br><span class=\"line\">  memset(strddatetime,0,sizeof(strddatetime));</span><br><span class=\"line\">  if (argc==5)</span><br><span class=\"line\">    LocalTime(strddatetime,&quot;yyyymmddhh24miss&quot;);</span><br><span class=\"line\">  else</span><br><span class=\"line\">    STRCPY(strddatetime,sizeof(strddatetime),argv[5]);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 模拟生成全国气象站点分钟观测数据，存放在vsurfdata容器中。</span><br><span class=\"line\">  CrtSurfData();</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把容器vsurfdata中的全国气象站点分钟观测数据写入文件。</span><br><span class=\"line\">  if (strstr(argv[4],&quot;xml&quot;)!=0) CrtSurfFile(argv[2],&quot;xml&quot;);</span><br><span class=\"line\">  if (strstr(argv[4],&quot;json&quot;)!=0) CrtSurfFile(argv[2],&quot;json&quot;);</span><br><span class=\"line\">  if (strstr(argv[4],&quot;csv&quot;)!=0) CrtSurfFile(argv[2],&quot;csv&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  logfile.Write(&quot;crtsurfdata 运行结束。\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把站点参数文件中加载到vstcode容器中。 </span><br><span class=\"line\">bool LoadSTCode(const char *inifile)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 打开站点参数文件。</span><br><span class=\"line\">  if (File.Open(inifile,&quot;r&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;File.Open(%s) failed.\\n&quot;,inifile); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  char strBuffer[301];</span><br><span class=\"line\"></span><br><span class=\"line\">  CCmdStr CmdStr;</span><br><span class=\"line\"></span><br><span class=\"line\">  struct st_stcode stcode;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 从站点参数文件中读取一行，如果已读取完，跳出循环。</span><br><span class=\"line\">    if (File.Fgets(strBuffer,300,true)==false) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把读取到的一行拆分。</span><br><span class=\"line\">    CmdStr.SplitToCmd(strBuffer,&quot;,&quot;,true);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (CmdStr.CmdCount()!=6) continue;     // 扔掉无效的行。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把站点参数的每个数据项保存到站点参数结构体中。</span><br><span class=\"line\">    memset(&amp;stcode,0,sizeof(struct st_stcode));</span><br><span class=\"line\">    CmdStr.GetValue(0, stcode.provname,30); // 省</span><br><span class=\"line\">    CmdStr.GetValue(1, stcode.obtid,10);    // 站号</span><br><span class=\"line\">    CmdStr.GetValue(2, stcode.obtname,30);  // 站名</span><br><span class=\"line\">    CmdStr.GetValue(3,&amp;stcode.lat);         // 纬度</span><br><span class=\"line\">    CmdStr.GetValue(4,&amp;stcode.lon);         // 经度</span><br><span class=\"line\">    CmdStr.GetValue(5,&amp;stcode.height);      // 海拔高度</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把站点参数结构体放入站点参数容器。</span><br><span class=\"line\">    vstcode.push_back(stcode);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*</span><br><span class=\"line\">  for (int ii=0;ii&lt;vstcode.size();ii++)</span><br><span class=\"line\">    logfile.Write(&quot;provname=%s,obtid=%s,obtname=%s,lat=%.2f,lon=%.2f,height=%.2f\\n&quot;,\\</span><br><span class=\"line\">                   vstcode[ii].provname,vstcode[ii].obtid,vstcode[ii].obtname,vstcode[ii].lat,\\</span><br><span class=\"line\">                   vstcode[ii].lon,vstcode[ii].height);</span><br><span class=\"line\">  */</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 模拟生成全国气象站点分钟观测数据，存放在vsurfdata容器中。</span><br><span class=\"line\">void CrtSurfData()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 播随机数种子。</span><br><span class=\"line\">  srand(time(0));</span><br><span class=\"line\"></span><br><span class=\"line\">  struct st_surfdata stsurfdata;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历气象站点参数的vstcode容器。</span><br><span class=\"line\">  for (int ii=0;ii&lt;vstcode.size();ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stsurfdata,0,sizeof(struct st_surfdata));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 用随机数填充分钟观测数据的结构体。</span><br><span class=\"line\">    strncpy(stsurfdata.obtid,vstcode[ii].obtid,10); // 站点代码。</span><br><span class=\"line\">    strncpy(stsurfdata.ddatetime,strddatetime,14);  // 数据时间：格式yyyymmddhh24miss</span><br><span class=\"line\">    stsurfdata.t=rand()%351;       // 气温：单位，0.1摄氏度</span><br><span class=\"line\">    stsurfdata.p=rand()%265+10000; // 气压：0.1百帕</span><br><span class=\"line\">    stsurfdata.u=rand()%100+1;     // 相对湿度，0-100之间的值。</span><br><span class=\"line\">    stsurfdata.wd=rand()%360;      // 风向，0-360之间的值。</span><br><span class=\"line\">    stsurfdata.wf=rand()%150;      // 风速：单位0.1m/s</span><br><span class=\"line\">    stsurfdata.r=rand()%16;        // 降雨量：0.1mm</span><br><span class=\"line\">    stsurfdata.vis=rand()%5001+100000;  // 能见度：0.1米</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把观测数据的结构体放入vsurfdata容器。</span><br><span class=\"line\">    vsurfdata.push_back(stsurfdata);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把容器vsurfdata中的全国气象站点分钟观测数据写入文件。</span><br><span class=\"line\">bool CrtSurfFile(const char *outpath,const char *datafmt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 拼接生成数据的文件名，例如：/tmp/idc/surfdata/SURF_ZH_20210629092200_2254.csv</span><br><span class=\"line\">  char strFileName[301];</span><br><span class=\"line\">  sprintf(strFileName,&quot;%s/SURF_ZH_%s_%d.%s&quot;,outpath,strddatetime,getpid(),datafmt);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 打开文件。</span><br><span class=\"line\">  if (File.OpenForRename(strFileName,&quot;w&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;File.OpenForRename(%s) failed.\\n&quot;,strFileName); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (strcmp(datafmt,&quot;csv&quot;)==0) File.Fprintf(&quot;站点代码,数据时间,气温,气压,相对湿度,风向,风速,降雨量,能见度\\n&quot;);</span><br><span class=\"line\">  if (strcmp(datafmt,&quot;xml&quot;)==0) File.Fprintf(&quot;&lt;data&gt;\\n&quot;);</span><br><span class=\"line\">  if (strcmp(datafmt,&quot;json&quot;)==0) File.Fprintf(&quot;&#123;\\&quot;data\\&quot;:[\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历存放观测数据的vsurfdata容器。</span><br><span class=\"line\">  for (int ii=0;ii&lt;vsurfdata.size();ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 写入一条记录。</span><br><span class=\"line\">    if (strcmp(datafmt,&quot;csv&quot;)==0)</span><br><span class=\"line\">      File.Fprintf(&quot;%s,%s,%.1f,%.1f,%d,%d,%.1f,%.1f,%.1f\\n&quot;,\\</span><br><span class=\"line\">         vsurfdata[ii].obtid,vsurfdata[ii].ddatetime,vsurfdata[ii].t/10.0,vsurfdata[ii].p/10.0,\\</span><br><span class=\"line\">         vsurfdata[ii].u,vsurfdata[ii].wd,vsurfdata[ii].wf/10.0,vsurfdata[ii].r/10.0,vsurfdata[ii].vis/10.0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (strcmp(datafmt,&quot;xml&quot;)==0)</span><br><span class=\"line\">      File.Fprintf(&quot;&lt;obtid&gt;%s&lt;/obtid&gt;&lt;ddatetime&gt;%s&lt;/ddatetime&gt;&lt;t&gt;%.1f&lt;/t&gt;&lt;p&gt;%.1f&lt;/p&gt;&quot;\\</span><br><span class=\"line\">                   &quot;&lt;u&gt;%d&lt;/u&gt;&lt;wd&gt;%d&lt;/wd&gt;&lt;wf&gt;%.1f&lt;/wf&gt;&lt;r&gt;%.1f&lt;/r&gt;&lt;vis&gt;%.1f&lt;/vis&gt;&lt;endl/&gt;\\n&quot;,\\</span><br><span class=\"line\">         vsurfdata[ii].obtid,vsurfdata[ii].ddatetime,vsurfdata[ii].t/10.0,vsurfdata[ii].p/10.0,\\</span><br><span class=\"line\">         vsurfdata[ii].u,vsurfdata[ii].wd,vsurfdata[ii].wf/10.0,vsurfdata[ii].r/10.0,vsurfdata[ii].vis/10.0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (strcmp(datafmt,&quot;json&quot;)==0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      File.Fprintf(&quot;&#123;\\&quot;obtid\\&quot;:\\&quot;%s\\&quot;,\\&quot;ddatetime\\&quot;:\\&quot;%s\\&quot;,\\&quot;t\\&quot;:\\&quot;%.1f\\&quot;,\\&quot;p\\&quot;:\\&quot;%.1f\\&quot;,&quot;\\</span><br><span class=\"line\">                   &quot;\\&quot;u\\&quot;:\\&quot;%d\\&quot;,\\&quot;wd\\&quot;:\\&quot;%d\\&quot;,\\&quot;wf\\&quot;:\\&quot;%.1f\\&quot;,\\&quot;r\\&quot;:\\&quot;%.1f\\&quot;,\\&quot;vis\\&quot;:\\&quot;%.1f\\&quot;&#125;&quot;,\\</span><br><span class=\"line\">         vsurfdata[ii].obtid,vsurfdata[ii].ddatetime,vsurfdata[ii].t/10.0,vsurfdata[ii].p/10.0,\\</span><br><span class=\"line\">         vsurfdata[ii].u,vsurfdata[ii].wd,vsurfdata[ii].wf/10.0,vsurfdata[ii].r/10.0,vsurfdata[ii].vis/10.0);</span><br><span class=\"line\"></span><br><span class=\"line\">      if (ii&lt;vsurfdata.size()-1) File.Fprintf(&quot;,\\n&quot;);</span><br><span class=\"line\">      else   File.Fprintf(&quot;\\n&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (strcmp(datafmt,&quot;xml&quot;)==0) File.Fprintf(&quot;&lt;/data&gt;\\n&quot;);</span><br><span class=\"line\">  if (strcmp(datafmt,&quot;json&quot;)==0) File.Fprintf(&quot;]&#125;\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭文件。</span><br><span class=\"line\">  File.CloseAndRename();</span><br><span class=\"line\"></span><br><span class=\"line\">  UTime(strFileName,strddatetime);  // 修改文件的时间属性。</span><br><span class=\"line\"></span><br><span class=\"line\">  logfile.Write(&quot;生成数据文件%s成功，数据时间%s，记录数%d。\\n&quot;,strFileName,strddatetime,vsurfdata.size());</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序退出和信号2、15的处理函数。</span><br><span class=\"line\">void EXIT(int sig)  </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  logfile.Write(&quot;程序退出，sig=%d\\n\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"编译文件-4\"><a href=\"#编译文件-4\" class=\"headerlink\" title=\"编译文件\"></a>编译文件</h5><p>makfile</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 开发框架头文件路径。</span><br><span class=\"line\">PUBINCL = -I/project/public</span><br><span class=\"line\"></span><br><span class=\"line\"># 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。</span><br><span class=\"line\">PUBCPP = /project/public/_public.cpp</span><br><span class=\"line\"></span><br><span class=\"line\"># 编译参数。</span><br><span class=\"line\">CFLAGS = -g </span><br><span class=\"line\"></span><br><span class=\"line\">all:crtsurfdata </span><br><span class=\"line\"></span><br><span class=\"line\">crtsurfdata:crtsurfdata.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o crtsurfdata crtsurfdata.cpp $(PUBINCL) $(PUBCPP) -lm -lc</span><br><span class=\"line\">\tcp crtsurfdata ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -f crtsurfdata </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"ftp上传下载\"><a href=\"#ftp上传下载\" class=\"headerlink\" title=\"ftp上传下载\"></a>ftp上传下载</h4><h5 id=\"安装ftp-1\"><a href=\"#安装ftp-1\" class=\"headerlink\" title=\"安装ftp\"></a>安装ftp</h5><p>去看安装ftp说明</p>\n<h5 id=\"ftp客户端下载\"><a href=\"#ftp客户端下载\" class=\"headerlink\" title=\"ftp客户端下载\"></a>ftp客户端下载</h5><p>ftpgetfiles.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\">#include &quot;_ftp.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序运行参数的结构体。</span><br><span class=\"line\">struct st_arg</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char host[31];           // 远程服务端的IP和端口。</span><br><span class=\"line\">  int  mode;               // 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。</span><br><span class=\"line\">  char username[31];       // 远程服务端ftp的用户名。</span><br><span class=\"line\">  char password[31];       // 远程服务端ftp的密码。</span><br><span class=\"line\">  char remotepath[301];    // 远程服务端存放文件的目录。</span><br><span class=\"line\">  char localpath[301];     // 本地文件存放的目录。</span><br><span class=\"line\">  char matchname[101];     // 待下载文件匹配的规则。</span><br><span class=\"line\">  char listfilename[301];  // 下载前列出服务端文件名的文件。</span><br><span class=\"line\">  int  ptype;              // 下载后服务端文件的处理方式：1-什么也不做；2-删除；3-备份。</span><br><span class=\"line\">  char remotepathbak[301]; // 下载后服务端文件的备份目录。</span><br><span class=\"line\">  char okfilename[301];    // 已下载成功文件名清单。</span><br><span class=\"line\">  bool checkmtime;         // 是否需要检查服务端文件的时间，true-需要，false-不需要，缺省为false。</span><br><span class=\"line\">  int  timeout;            // 进程心跳的超时时间。</span><br><span class=\"line\">  char pname[51];          // 进程名，建议用&quot;ftpgetfiles_后缀&quot;的方式。</span><br><span class=\"line\">&#125; starg;</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件信息的结构体。</span><br><span class=\"line\">struct st_fileinfo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char filename[301];   // 文件名。</span><br><span class=\"line\">  char mtime[21];       // 文件时间。</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;struct st_fileinfo&gt; vlistfile1;    // 已下载成功文件名的容器，从okfilename中加载。</span><br><span class=\"line\">vector&lt;struct st_fileinfo&gt; vlistfile2;    // 下载前列出服务端文件名的容器，从nlist文件中加载。</span><br><span class=\"line\">vector&lt;struct st_fileinfo&gt; vlistfile3;    // 本次不需要下载的文件的容器。</span><br><span class=\"line\">vector&lt;struct st_fileinfo&gt; vlistfile4;    // 本次需要下载的文件的容器。</span><br><span class=\"line\"></span><br><span class=\"line\">// 加载okfilename文件中的内容到容器vlistfile1中。</span><br><span class=\"line\">bool LoadOKFile();</span><br><span class=\"line\"></span><br><span class=\"line\">// 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。</span><br><span class=\"line\">bool CompVector();</span><br><span class=\"line\"></span><br><span class=\"line\">// 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。</span><br><span class=\"line\">bool WriteToOKFile();</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果ptype==1，把下载成功的文件记录追加到okfilename文件中。</span><br><span class=\"line\">bool AppendToOKFile(struct st_fileinfo *stfileinfo);</span><br><span class=\"line\"></span><br><span class=\"line\">// 把ftp.nlist()方法获取到的list文件加载到容器vlistfile2中。</span><br><span class=\"line\">bool LoadListFile();</span><br><span class=\"line\"></span><br><span class=\"line\">CLogFile logfile;</span><br><span class=\"line\"></span><br><span class=\"line\">Cftp ftp;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序退出和信号2、15的处理函数。</span><br><span class=\"line\">void EXIT(int sig);</span><br><span class=\"line\"></span><br><span class=\"line\">void _help();</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构中。</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">// 下载文件功能的主函数。</span><br><span class=\"line\">bool _ftpgetfiles();</span><br><span class=\"line\"></span><br><span class=\"line\">CPActive PActive;  // 进程心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (argc!=3) &#123; _help(); return -1; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭全部的信号和输入输出。</span><br><span class=\"line\">  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。</span><br><span class=\"line\">  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。</span><br><span class=\"line\">  CloseIOAndSignal(); signal(SIGINT,EXIT); signal(SIGTERM,EXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 打开日志文件。</span><br><span class=\"line\">  if (logfile.Open(argv[1],&quot;a+&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;打开日志文件失败（%s）。\\n&quot;,argv[1]); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 解析xml，得到程序运行的参数。</span><br><span class=\"line\">  if (_xmltoarg(argv[2])==false) return -1;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.AddPInfo(starg.timeout,starg.pname);  // 把进程的心跳信息写入共享内存。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录ftp服务端。</span><br><span class=\"line\">  if (ftp.login(starg.host,starg.username,starg.password,starg.mode)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;ftp.login(%s,%s,%s) failed.\\n&quot;,starg.host,starg.username,starg.password); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // logfile.Write(&quot;ftp.login ok.\\n&quot;);  // 正式运行后，可以注释这行代码。</span><br><span class=\"line\"></span><br><span class=\"line\">  _ftpgetfiles();</span><br><span class=\"line\"></span><br><span class=\"line\">  ftp.logout();</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 下载文件功能的主函数。</span><br><span class=\"line\">bool _ftpgetfiles()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 进入ftp服务端存放文件的目录。</span><br><span class=\"line\">  if (ftp.chdir(starg.remotepath)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;ftp.chdir(%s) failed.\\n&quot;,starg.remotepath); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 调用ftp.nlist()方法列出服务端目录中的文件，结果存放到本地文件中。</span><br><span class=\"line\">  if (ftp.nlist(&quot;.&quot;,starg.listfilename)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;ftp.nlist(%s) failed.\\n&quot;,starg.remotepath); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.UptATime();   // 更新进程的心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把ftp.nlist()方法获取到的list文件加载到容器vlistfile2中。</span><br><span class=\"line\">  if (LoadListFile()==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;LoadListFile() failed.\\n&quot;);  return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.UptATime();   // 更新进程的心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">  if (starg.ptype==1)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 加载okfilename文件中的内容到容器vlistfile1中。</span><br><span class=\"line\">    LoadOKFile();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。</span><br><span class=\"line\">    CompVector();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。</span><br><span class=\"line\">    WriteToOKFile();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把vlistfile4中的内容复制到vlistfile2中。</span><br><span class=\"line\">    vlistfile2.clear(); vlistfile2.swap(vlistfile4);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.UptATime();   // 更新进程的心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">  char strremotefilename[301],strlocalfilename[301];</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历容器vlistfile2。</span><br><span class=\"line\">  for (int ii=0;ii&lt;vlistfile2.size();ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    SNPRINTF(strremotefilename,sizeof(strremotefilename),300,&quot;%s/%s&quot;,starg.remotepath,vlistfile2[ii].filename);</span><br><span class=\"line\">    SNPRINTF(strlocalfilename,sizeof(strlocalfilename),300,&quot;%s/%s&quot;,starg.localpath,vlistfile2[ii].filename);</span><br><span class=\"line\"></span><br><span class=\"line\">    logfile.Write(&quot;get %s ...&quot;,strremotefilename);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 调用ftp.get()方法从服务端下载文件。</span><br><span class=\"line\">    if (ftp.get(strremotefilename,strlocalfilename)==false) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.WriteEx(&quot;failed.\\n&quot;); return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    logfile.WriteEx(&quot;ok.\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    PActive.UptATime();   // 更新进程的心跳。</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 如果ptype==1，把下载成功的文件记录追加到okfilename文件中。</span><br><span class=\"line\">    if (starg.ptype==1) AppendToOKFile(&amp;vlistfile2[ii]);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 删除服务端的文件。</span><br><span class=\"line\">    if (starg.ptype==2) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      if (ftp.ftpdelete(strremotefilename)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;ftp.ftpdelete(%s) failed.\\n&quot;,strremotefilename); return false;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把服务端的文件转存到备份目录。</span><br><span class=\"line\">    if (starg.ptype==3) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      char strremotefilenamebak[301];</span><br><span class=\"line\">      SNPRINTF(strremotefilenamebak,sizeof(strremotefilenamebak),300,&quot;%s/%s&quot;,starg.remotepathbak,vlistfile2[ii].filename);</span><br><span class=\"line\">      if (ftp.ftprename(strremotefilename,strremotefilenamebak)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;ftp.ftprename(%s,%s) failed.\\n&quot;,strremotefilename,strremotefilenamebak); return false;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EXIT(int sig)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;程序退出，sig=%d\\n\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void _help()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;\\n&quot;);</span><br><span class=\"line\">  printf(&quot;Using:/project/tools1/bin/ftpgetfiles logfilename xmlbuffer\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;Sample:/project/tools1/bin/procctl 30 /project/tools1/bin/ftpgetfiles /log/idc/ftpgetfiles.log \\&quot;&lt;host&gt;127.0.0.1:21&lt;/host&gt;&lt;mode&gt;1&lt;/mode&gt;&lt;username&gt;lijialin&lt;/username&gt;&lt;password&gt;6VzFeKBnSoV.&lt;/password&gt;&lt;localpath&gt;/home/lijialin/ftpget&lt;/localpath&gt;&lt;remotepath&gt;/log/idc&lt;/remotepath&gt;&lt;matchname&gt;*&lt;/matchname&gt;&lt;listfilename&gt;/home/lijialin/ftpgetfiles.list&lt;/listfilename&gt;&lt;ptype&gt;1&lt;/ptype&gt;&lt;remotepathbak&gt;/tmp/idc/surfdatabak&lt;/remotepathbak&gt;&lt;okfilename&gt;/home/lijialin/ftpgetfiles.xml&lt;/okfilename&gt;&lt;checkmtime&gt;true&lt;/checkmtime&gt;&lt;timeout&gt;80&lt;/timeout&gt;&lt;pname&gt;ftplijialingetfiles&lt;/pname&gt;\\&quot;\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;本程序是通用的功能模块，用于把远程ftp服务端的文件下载到本地目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;logfilename是本程序运行的日志文件。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;xmlbuffer为文件下载的参数，如下：\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;host&gt;127.0.0.1:21&lt;/host&gt; 远程服务端的IP和端口。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;mode&gt;1&lt;/mode&gt; 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;username&gt;wucz&lt;/username&gt; 远程服务端ftp的用户名。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;password&gt;wuczpwd&lt;/password&gt; 远程服务端ftp的密码。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;remotepath&gt;/tmp/idc/surfdata&lt;/remotepath&gt; 远程服务端存放文件的目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;localpath&gt;/idcdata/surfdata&lt;/localpath&gt; 本地文件存放的目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;matchname&gt;SURF_ZH*.XML,SURF_ZH*.CSV&lt;/matchname&gt; 待下载文件匹配的规则。&quot;\\</span><br><span class=\"line\">         &quot;不匹配的文件不会被下载，本字段尽可能设置精确，不建议用*匹配全部的文件。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;listfilename&gt;/idcdata/ftplist/ftpgetfiles_surfdata.list&lt;/listfilename&gt; 下载前列出服务端文件名的文件。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;ptype&gt;1&lt;/ptype&gt; 文件下载成功后，远程服务端文件的处理方式：1-什么也不做；2-删除；3-备份，如果为3，还要指定备份的目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;remotepathbak&gt;/tmp/idc/surfdatabak&lt;/remotepathbak&gt; 文件下载成功后，服务端文件的备份目录，此参数只有当ptype=3时才有效。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;okfilename&gt;/idcdata/ftplist/ftpgetfiles_surfdata.xml&lt;/okfilename&gt; 已下载成功文件名清单，此参数只有当ptype=1时才有效。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;checkmtime&gt;true&lt;/checkmtime&gt; 是否需要检查服务端文件的时间，true-需要，false-不需要，此参数只有当ptype=1时才有效，缺省为false。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;timeout&gt;80&lt;/timeout&gt; 下载文件超时时间，单位：秒，视文件大小和网络带宽而定。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;pname&gt;ftpgetfiles_surfdata&lt;/pname&gt; 进程名，尽可能采用易懂的、与其它进程不同的名称，方便故障排查。\\n\\n\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构中。</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(&amp;starg,0,sizeof(struct st_arg));</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;host&quot;,starg.host,30);   // 远程服务端的IP和端口。</span><br><span class=\"line\">  if (strlen(starg.host)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;host is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;mode&quot;,&amp;starg.mode);   // 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。</span><br><span class=\"line\">  if (starg.mode!=2)  starg.mode=1;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;username&quot;,starg.username,30);   // 远程服务端ftp的用户名。</span><br><span class=\"line\">  if (strlen(starg.username)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;username is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;password&quot;,starg.password,30);   // 远程服务端ftp的密码。</span><br><span class=\"line\">  if (strlen(starg.password)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;password is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;remotepath&quot;,starg.remotepath,300);   // 远程服务端存放文件的目录。</span><br><span class=\"line\">  if (strlen(starg.remotepath)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;remotepath is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;localpath&quot;,starg.localpath,300);   // 本地文件存放的目录。</span><br><span class=\"line\">  if (strlen(starg.localpath)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;localpath is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;matchname&quot;,starg.matchname,100);   // 待下载文件匹配的规则。</span><br><span class=\"line\">  if (strlen(starg.matchname)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;matchname is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;listfilename&quot;,starg.listfilename,300);   // 下载前列出服务端文件名的文件。</span><br><span class=\"line\">  if (strlen(starg.listfilename)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;listfilename is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 下载后服务端文件的处理方式：1-什么也不做；2-删除；3-备份。</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;ptype&quot;,&amp;starg.ptype);   </span><br><span class=\"line\">  if ( (starg.ptype!=1) &amp;&amp; (starg.ptype!=2) &amp;&amp; (starg.ptype!=3) )</span><br><span class=\"line\">  &#123; logfile.Write(&quot;ptype is error.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;remotepathbak&quot;,starg.remotepathbak,300); // 下载后服务端文件的备份目录。</span><br><span class=\"line\">  if ( (starg.ptype==3) &amp;&amp; (strlen(starg.remotepathbak)==0) )</span><br><span class=\"line\">  &#123; logfile.Write(&quot;remotepathbak is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;okfilename&quot;,starg.okfilename,300); // 已下载成功文件名清单。</span><br><span class=\"line\">  if ( (starg.ptype==1) &amp;&amp; (strlen(starg.okfilename)==0) )</span><br><span class=\"line\">  &#123; logfile.Write(&quot;okfilename is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 是否需要检查服务端文件的时间，true-需要，false-不需要，此参数只有当ptype=1时才有效，缺省为false。</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;checkmtime&quot;,&amp;starg.checkmtime);</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;timeout&quot;,&amp;starg.timeout);   // 进程心跳的超时时间。</span><br><span class=\"line\">  if (starg.timeout==0) &#123; logfile.Write(&quot;timeout is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;pname&quot;,starg.pname,50);     // 进程名。</span><br><span class=\"line\">  if (strlen(starg.pname)==0) &#123; logfile.Write(&quot;pname is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把ftp.nlist()方法获取到的list文件加载到容器vlistfile2中。</span><br><span class=\"line\">bool LoadListFile()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  vlistfile2.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">  CFile  File;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (File.Open(starg.listfilename,&quot;r&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;File.Open(%s) 失败。\\n&quot;,starg.listfilename); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  struct st_fileinfo stfileinfo;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stfileinfo,0,sizeof(struct st_fileinfo));</span><br><span class=\"line\">   </span><br><span class=\"line\">    if (File.Fgets(stfileinfo.filename,300,true)==false) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (MatchStr(stfileinfo.filename,starg.matchname)==false) continue;</span><br><span class=\"line\"></span><br><span class=\"line\">    if ( (starg.ptype==1) &amp;&amp; (starg.checkmtime==true) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 获取ftp服务端文件时间。</span><br><span class=\"line\">      if (ftp.mtime(stfileinfo.filename)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;ftp.mtime(%s) failed.\\n&quot;,stfileinfo.filename); return false;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">      strcpy(stfileinfo.mtime,ftp.m_mtime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    vlistfile2.push_back(stfileinfo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*</span><br><span class=\"line\">  for (int ii=0;ii&lt;vlistfile2.size();ii++)</span><br><span class=\"line\">    logfile.Write(&quot;filename=%s=\\n&quot;,vlistfile2[ii].filename);</span><br><span class=\"line\">  */</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 加载okfilename文件中的内容到容器vlistfile1中。</span><br><span class=\"line\">bool LoadOKFile()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  vlistfile1.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">  CFile File;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 注意：如果程序是第一次下载，okfilename是不存在的，并不是错误，所以也返回true。</span><br><span class=\"line\">  if ( (File.Open(starg.okfilename,&quot;r&quot;))==false )  return true;</span><br><span class=\"line\"></span><br><span class=\"line\">  char strbuffer[501];</span><br><span class=\"line\"></span><br><span class=\"line\">  struct st_fileinfo stfileinfo;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stfileinfo,0,sizeof(struct st_fileinfo));</span><br><span class=\"line\"></span><br><span class=\"line\">    if (File.Fgets(strbuffer,300,true)==false) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    GetXMLBuffer(strbuffer,&quot;filename&quot;,stfileinfo.filename);</span><br><span class=\"line\">    GetXMLBuffer(strbuffer,&quot;mtime&quot;,stfileinfo.mtime);</span><br><span class=\"line\"></span><br><span class=\"line\">    vlistfile1.push_back(stfileinfo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。</span><br><span class=\"line\">bool CompVector()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  vlistfile3.clear(); vlistfile4.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">  int ii,jj;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历vlistfile2。</span><br><span class=\"line\">  for (ii=0;ii&lt;vlistfile2.size();ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 在vlistfile1中查找vlistfile2[ii]的记录。</span><br><span class=\"line\">    for (jj=0;jj&lt;vlistfile1.size();jj++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 如果找到了，把记录放入vlistfile3。</span><br><span class=\"line\">      if ( (strcmp(vlistfile2[ii].filename,vlistfile1[jj].filename)==0) &amp;&amp;</span><br><span class=\"line\">           (strcmp(vlistfile2[ii].mtime,vlistfile1[jj].mtime)==0) )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        vlistfile3.push_back(vlistfile2[ii]); break;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果没有找到，把记录放入vlistfile4。</span><br><span class=\"line\">    if (jj==vlistfile1.size()) vlistfile4.push_back(vlistfile2[ii]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。</span><br><span class=\"line\">bool WriteToOKFile()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  CFile File;    </span><br><span class=\"line\"></span><br><span class=\"line\">  if (File.Open(starg.okfilename,&quot;w&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;File.Open(%s) failed.\\n&quot;,starg.okfilename); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (int ii=0;ii&lt;vlistfile3.size();ii++)</span><br><span class=\"line\">    File.Fprintf(&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;\\n&quot;,vlistfile3[ii].filename,vlistfile3[ii].mtime);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果ptype==1，把下载成功的文件记录追加到okfilename文件中。</span><br><span class=\"line\">bool AppendToOKFile(struct st_fileinfo *stfileinfo)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  CFile File;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (File.Open(starg.okfilename,&quot;a&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;File.Open(%s) failed.\\n&quot;,starg.okfilename); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  File.Fprintf(&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;\\n&quot;,stfileinfo-&gt;filename,stfileinfo-&gt;mtime);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"ftp客户端上传\"><a href=\"#ftp客户端上传\" class=\"headerlink\" title=\"ftp客户端上传\"></a>ftp客户端上传</h5><p>ftpputfiles.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\">#include &quot;_ftp.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序运行参数的结构体。</span><br><span class=\"line\">struct st_arg</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char host[31];           // 远程服务端的IP和端口。</span><br><span class=\"line\">  int  mode;               // 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。</span><br><span class=\"line\">  char username[31];       // 远程服务端ftp的用户名。</span><br><span class=\"line\">  char password[31];       // 远程服务端ftp的密码。</span><br><span class=\"line\">  char remotepath[301];    // 远程服务端存放文件的目录。</span><br><span class=\"line\">  char localpath[301];     // 本地文件存放的目录。</span><br><span class=\"line\">  char matchname[101];     // 待上传文件匹配的规则。</span><br><span class=\"line\">  int  ptype;              // 上传后客户端文件的处理方式：1-什么也不做；2-删除；3-备份。</span><br><span class=\"line\">  char localpathbak[301];  // 上传后客户端文件的备份目录。</span><br><span class=\"line\">  char okfilename[301];    // 已上传成功文件名清单。</span><br><span class=\"line\">  int  timeout;            // 进程心跳的超时时间。</span><br><span class=\"line\">  char pname[51];          // 进程名，建议用&quot;ftpputfiles_后缀&quot;的方式。</span><br><span class=\"line\">&#125; starg;</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件信息的结构体。</span><br><span class=\"line\">struct st_fileinfo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char filename[301];   // 文件名。</span><br><span class=\"line\">  char mtime[21];       // 文件时间。</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;struct st_fileinfo&gt; vlistfile1;    // 已上传成功文件名的容器，从okfilename中加载。</span><br><span class=\"line\">vector&lt;struct st_fileinfo&gt; vlistfile2;    // 上传前列出客户端文件名的容器，从nlist文件中加载。</span><br><span class=\"line\">vector&lt;struct st_fileinfo&gt; vlistfile3;    // 本次不需要上传的文件的容器。</span><br><span class=\"line\">vector&lt;struct st_fileinfo&gt; vlistfile4;    // 本次需要上传的文件的容器。</span><br><span class=\"line\"></span><br><span class=\"line\">// 加载okfilename文件中的内容到容器vlistfile1中。</span><br><span class=\"line\">bool LoadOKFile();</span><br><span class=\"line\"></span><br><span class=\"line\">// 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。</span><br><span class=\"line\">bool CompVector();</span><br><span class=\"line\"></span><br><span class=\"line\">// 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。</span><br><span class=\"line\">bool WriteToOKFile();</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果ptype==1，把上传成功的文件记录追加到okfilename文件中。</span><br><span class=\"line\">bool AppendToOKFile(struct st_fileinfo *stfileinfo);</span><br><span class=\"line\"></span><br><span class=\"line\">// 把localpath目录下的文件加载到vlistfile2容器中。</span><br><span class=\"line\">bool LoadLocalFile();</span><br><span class=\"line\"></span><br><span class=\"line\">CLogFile logfile;</span><br><span class=\"line\"></span><br><span class=\"line\">Cftp ftp;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序退出和信号2、15的处理函数。</span><br><span class=\"line\">void EXIT(int sig);</span><br><span class=\"line\"></span><br><span class=\"line\">void _help();</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构中。</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">// 上传文件功能的主函数。</span><br><span class=\"line\">bool _ftpputfiles();</span><br><span class=\"line\"></span><br><span class=\"line\">CPActive PActive;  // 进程心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (argc!=3) &#123; _help(); return -1; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭全部的信号和输入输出。</span><br><span class=\"line\">  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。</span><br><span class=\"line\">  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。</span><br><span class=\"line\">  CloseIOAndSignal(); signal(SIGINT,EXIT); signal(SIGTERM,EXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 打开日志文件。</span><br><span class=\"line\">  if (logfile.Open(argv[1],&quot;a+&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;打开日志文件失败（%s）。\\n&quot;,argv[1]); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 解析xml，得到程序运行的参数。</span><br><span class=\"line\">  if (_xmltoarg(argv[2])==false) return -1;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.AddPInfo(starg.timeout,starg.pname);  // 把进程的心跳信息写入共享内存。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录ftp服务端。</span><br><span class=\"line\">  if (ftp.login(starg.host,starg.username,starg.password,starg.mode)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;ftp.login(%s,%s,%s) failed.\\n&quot;,starg.host,starg.username,starg.password); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // logfile.Write(&quot;ftp.login ok.\\n&quot;);  // 正式运行后，可以注释这行代码。</span><br><span class=\"line\"></span><br><span class=\"line\">  _ftpputfiles();</span><br><span class=\"line\"></span><br><span class=\"line\">  ftp.logout();</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 上传文件功能的主函数。</span><br><span class=\"line\">bool _ftpputfiles()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 把localpath目录下的文件加载到vlistfile2容器中。</span><br><span class=\"line\">  if (LoadLocalFile()==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;LoadLocalFile() failed.\\n&quot;);  return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.UptATime();   // 更新进程的心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">  if (starg.ptype==1)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 加载okfilename文件中的内容到容器vlistfile1中。</span><br><span class=\"line\">    LoadOKFile();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。</span><br><span class=\"line\">    CompVector();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。</span><br><span class=\"line\">    WriteToOKFile();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把vlistfile4中的内容复制到vlistfile2中。</span><br><span class=\"line\">    vlistfile2.clear(); vlistfile2.swap(vlistfile4);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.UptATime();   // 更新进程的心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">  char strremotefilename[301],strlocalfilename[301];</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历容器vlistfile2。</span><br><span class=\"line\">  for (int ii=0;ii&lt;vlistfile2.size();ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    SNPRINTF(strremotefilename,sizeof(strremotefilename),300,&quot;%s/%s&quot;,starg.remotepath,vlistfile2[ii].filename);</span><br><span class=\"line\">    SNPRINTF(strlocalfilename,sizeof(strlocalfilename),300,&quot;%s/%s&quot;,starg.localpath,vlistfile2[ii].filename);</span><br><span class=\"line\"></span><br><span class=\"line\">    logfile.Write(&quot;put %s ...&quot;,strlocalfilename);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 调用ftp.put()方法把文件上传到服务端，第三个参数填true的目的是确保文件上传成功，对方不可抵赖。</span><br><span class=\"line\">    if (ftp.put(strlocalfilename,strremotefilename,true)==false) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.WriteEx(&quot;failed.\\n&quot;); return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    logfile.WriteEx(&quot;ok.\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    PActive.UptATime();   // 更新进程的心跳。</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 如果ptype==1，把上传成功的文件记录追加到okfilename文件中。</span><br><span class=\"line\">    if (starg.ptype==1) AppendToOKFile(&amp;vlistfile2[ii]);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 删除文件。</span><br><span class=\"line\">    if (starg.ptype==2)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      if (REMOVE(strlocalfilename)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;REMOVE(%s) failed.\\n&quot;,strlocalfilename); return false;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 转存到备份目录。</span><br><span class=\"line\">    if (starg.ptype==3)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      char strlocalfilenamebak[301];</span><br><span class=\"line\">      SNPRINTF(strlocalfilenamebak,sizeof(strlocalfilenamebak),300,&quot;%s/%s&quot;,starg.localpathbak,vlistfile2[ii].filename);</span><br><span class=\"line\">      if (RENAME(strlocalfilename,strlocalfilenamebak)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;RENAME(%s,%s) failed.\\n&quot;,strlocalfilename,strlocalfilenamebak); return false;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EXIT(int sig)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;程序退出，sig=%d\\n\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void _help()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;\\n&quot;);</span><br><span class=\"line\">  printf(&quot;Using:/project/tools1/bin/ftpputfiles logfilename xmlbuffer\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;Sample:/project/tools1/bin/procctl 30 /project/tools1/bin/ftpputfiles /log/idc/ftpputfiles.log \\&quot;&lt;host&gt;127.0.0.1:21&lt;/host&gt;&lt;mode&gt;1&lt;/mode&gt;&lt;username&gt;lijialin&lt;/username&gt;&lt;password&gt;6VzFeKBnSoV.&lt;/password&gt;&lt;localpath&gt;/home/lijialin/ftptext&lt;/localpath&gt;&lt;remotepath&gt;/tmp/ftptext&lt;/remotepath&gt;&lt;matchname&gt;*&lt;/matchname&gt;&lt;ptype&gt;1&lt;/ptype&gt;&lt;localpathbak&gt;/tmp/idc/surfdatabak&lt;/localpathbak&gt;&lt;okfilename&gt;/home/lijialin/textlist.xml&lt;/okfilename&gt;&lt;timeout&gt;80&lt;/timeout&gt;&lt;pname&gt;ftplijialinputfiletext&lt;/pname&gt;\\&quot;\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;本程序是通用的功能模块，用于把本地目录中的文件上传到远程的ftp服务器。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;logfilename是本程序运行的日志文件。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;xmlbuffer为文件上传的参数，如下：\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;host&gt;127.0.0.1:21&lt;/host&gt; 远程服务端的IP和端口。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;mode&gt;1&lt;/mode&gt; 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;username&gt;wucz&lt;/username&gt; 远程服务端ftp的用户名。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;password&gt;wuczpwd&lt;/password&gt; 远程服务端ftp的密码。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;remotepath&gt;/tmp/ftpputest&lt;/remotepath&gt; 远程服务端存放文件的目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;localpath&gt;/tmp/idc/surfdata&lt;/localpath&gt; 本地文件存放的目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;matchname&gt;SURF_ZH*.JSON&lt;/matchname&gt; 待上传文件匹配的规则。&quot;\\</span><br><span class=\"line\">         &quot;不匹配的文件不会被上传，本字段尽可能设置精确，不建议用*匹配全部的文件。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;ptype&gt;1&lt;/ptype&gt; 文件上传成功后，本地文件的处理方式：1-什么也不做；2-删除；3-备份，如果为3，还要指定备份的目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;localpathbak&gt;/tmp/idc/surfdatabak&lt;/localpathbak&gt; 文件上传成功后，本地文件的备份目录，此参数只有当ptype=3时才有效。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;okfilename&gt;/idcdata/ftplist/ftpputfiles_surfdata.xml&lt;/okfilename&gt; 已上传成功文件名清单，此参数只有当ptype=1时才有效。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;timeout&gt;80&lt;/timeout&gt; 上传文件超时时间，单位：秒，视文件大小和网络带宽而定。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;pname&gt;ftpputfiles_surfdata&lt;/pname&gt; 进程名，尽可能采用易懂的、与其它进程不同的名称，方便故障排查。\\n\\n\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构中。</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(&amp;starg,0,sizeof(struct st_arg));</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;host&quot;,starg.host,30);   // 远程服务端的IP和端口。</span><br><span class=\"line\">  if (strlen(starg.host)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;host is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;mode&quot;,&amp;starg.mode);   // 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。</span><br><span class=\"line\">  if (starg.mode!=2)  starg.mode=1;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;username&quot;,starg.username,30);   // 远程服务端ftp的用户名。</span><br><span class=\"line\">  if (strlen(starg.username)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;username is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;password&quot;,starg.password,30);   // 远程服务端ftp的密码。</span><br><span class=\"line\">  if (strlen(starg.password)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;password is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;remotepath&quot;,starg.remotepath,300);   // 远程服务端存放文件的目录。</span><br><span class=\"line\">  if (strlen(starg.remotepath)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;remotepath is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;localpath&quot;,starg.localpath,300);   // 本地文件存放的目录。</span><br><span class=\"line\">  if (strlen(starg.localpath)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;localpath is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;matchname&quot;,starg.matchname,100);   // 待上传文件匹配的规则。</span><br><span class=\"line\">  if (strlen(starg.matchname)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;matchname is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 上传后客户端文件的处理方式：1-什么也不做；2-删除；3-备份。</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;ptype&quot;,&amp;starg.ptype);   </span><br><span class=\"line\">  if ( (starg.ptype!=1) &amp;&amp; (starg.ptype!=2) &amp;&amp; (starg.ptype!=3) )</span><br><span class=\"line\">  &#123; logfile.Write(&quot;ptype is error.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;localpathbak&quot;,starg.localpathbak,300); // 上传后客户端文件的备份目录。</span><br><span class=\"line\">  if ( (starg.ptype==3) &amp;&amp; (strlen(starg.localpathbak)==0) )</span><br><span class=\"line\">  &#123; logfile.Write(&quot;localpathbak is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;okfilename&quot;,starg.okfilename,300); // 已上传成功文件名清单。</span><br><span class=\"line\">  if ( (starg.ptype==1) &amp;&amp; (strlen(starg.okfilename)==0) )</span><br><span class=\"line\">  &#123; logfile.Write(&quot;okfilename is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;timeout&quot;,&amp;starg.timeout);   // 进程心跳的超时时间。</span><br><span class=\"line\">  if (starg.timeout==0) &#123; logfile.Write(&quot;timeout is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;pname&quot;,starg.pname,50);     // 进程名。</span><br><span class=\"line\">  if (strlen(starg.pname)==0) &#123; logfile.Write(&quot;pname is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把localpath目录下的文件加载到vlistfile2容器中。</span><br><span class=\"line\">bool LoadLocalFile()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  vlistfile2.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">  CDir Dir;</span><br><span class=\"line\"></span><br><span class=\"line\">  Dir.SetDateFMT(&quot;yyyymmddhh24miss&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 不包括子目录。</span><br><span class=\"line\">  // 注意，如果本地目录下的总文件数超过10000，增量上传文件功能将有问题。</span><br><span class=\"line\">  // 建议用deletefiles程序及时清理本地目录中的历史文件。</span><br><span class=\"line\">  if (Dir.OpenDir(starg.localpath,starg.matchname)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;Dir.OpenDir(%s) 失败。\\n&quot;,starg.localpath); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  struct st_fileinfo stfileinfo;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stfileinfo,0,sizeof(struct st_fileinfo));</span><br><span class=\"line\">   </span><br><span class=\"line\">    if (Dir.ReadDir()==false) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    strcpy(stfileinfo.filename,Dir.m_FileName);   // 文件名，不包括目录名。</span><br><span class=\"line\">    strcpy(stfileinfo.mtime,Dir.m_ModifyTime);    // 文件时间。</span><br><span class=\"line\"></span><br><span class=\"line\">    vlistfile2.push_back(stfileinfo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 加载okfilename文件中的内容到容器vlistfile1中。</span><br><span class=\"line\">bool LoadOKFile()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  vlistfile1.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">  CFile File;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 注意：如果程序是第一次上传，okfilename是不存在的，并不是错误，所以也返回true。</span><br><span class=\"line\">  if ( (File.Open(starg.okfilename,&quot;r&quot;))==false )  return true;</span><br><span class=\"line\"></span><br><span class=\"line\">  char strbuffer[501];</span><br><span class=\"line\"></span><br><span class=\"line\">  struct st_fileinfo stfileinfo;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stfileinfo,0,sizeof(struct st_fileinfo));</span><br><span class=\"line\"></span><br><span class=\"line\">    if (File.Fgets(strbuffer,300,true)==false) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    GetXMLBuffer(strbuffer,&quot;filename&quot;,stfileinfo.filename);</span><br><span class=\"line\">    GetXMLBuffer(strbuffer,&quot;mtime&quot;,stfileinfo.mtime);</span><br><span class=\"line\"></span><br><span class=\"line\">    vlistfile1.push_back(stfileinfo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。</span><br><span class=\"line\">bool CompVector()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  vlistfile3.clear(); vlistfile4.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">  int ii,jj;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历vlistfile2。</span><br><span class=\"line\">  for (ii=0;ii&lt;vlistfile2.size();ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 在vlistfile1中查找vlistfile2[ii]的记录。</span><br><span class=\"line\">    for (jj=0;jj&lt;vlistfile1.size();jj++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 如果找到了，把记录放入vlistfile3。</span><br><span class=\"line\">      if ( (strcmp(vlistfile2[ii].filename,vlistfile1[jj].filename)==0) &amp;&amp;</span><br><span class=\"line\">           (strcmp(vlistfile2[ii].mtime,vlistfile1[jj].mtime)==0) )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        vlistfile3.push_back(vlistfile2[ii]); break;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果没有找到，把记录放入vlistfile4。</span><br><span class=\"line\">    if (jj==vlistfile1.size()) vlistfile4.push_back(vlistfile2[ii]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。</span><br><span class=\"line\">bool WriteToOKFile()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  CFile File;    </span><br><span class=\"line\"></span><br><span class=\"line\">  if (File.Open(starg.okfilename,&quot;w&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;File.Open(%s) failed.\\n&quot;,starg.okfilename); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (int ii=0;ii&lt;vlistfile3.size();ii++)</span><br><span class=\"line\">    File.Fprintf(&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;\\n&quot;,vlistfile3[ii].filename,vlistfile3[ii].mtime);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果ptype==1，把上传成功的文件记录追加到okfilename文件中。</span><br><span class=\"line\">bool AppendToOKFile(struct st_fileinfo *stfileinfo)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  CFile File;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (File.Open(starg.okfilename,&quot;a&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;File.Open(%s) failed.\\n&quot;,starg.okfilename); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  File.Fprintf(&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;\\n&quot;,stfileinfo-&gt;filename,stfileinfo-&gt;mtime);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"ftp编译\"><a href=\"#ftp编译\" class=\"headerlink\" title=\"ftp编译\"></a>ftp编译</h5><p>makefile</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 开发框架头文件路径。</span><br><span class=\"line\">PUBINCL = -I/project/public</span><br><span class=\"line\"></span><br><span class=\"line\"># 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。</span><br><span class=\"line\">PUBCPP = /project/public/_public.cpp</span><br><span class=\"line\"></span><br><span class=\"line\"># 编译参数。</span><br><span class=\"line\">CFLAGS = -g</span><br><span class=\"line\"></span><br><span class=\"line\">all: ftpgetfiles ftpputfiles</span><br><span class=\"line\"></span><br><span class=\"line\">ftpgetfiles:ftpgetfiles.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o ftpgetfiles ftpgetfiles.cpp $(PUBINCL) $(PUBCPP) /project/public/libftp.a /project/public/_ftp.cpp -lm -lc</span><br><span class=\"line\">\tcp ftpgetfiles ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">ftpputfiles:ftpputfiles.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o ftpputfiles ftpputfiles.cpp $(PUBINCL) $(PUBCPP) /project/public/libftp.a /project/public/_ftp.cpp -lm -lc</span><br><span class=\"line\">\tcp ftpputfiles ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -f ftpgetfiles ftpputfiles</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"TCP上传下载\"><a href=\"#TCP上传下载\" class=\"headerlink\" title=\"TCP上传下载\"></a>TCP上传下载</h4><h5 id=\"tcp客户端上传\"><a href=\"#tcp客户端上传\" class=\"headerlink\" title=\"tcp客户端上传\"></a>tcp客户端上传</h5><p>tcpputfiles.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * 程序名：tcpputfiles.cpp，采用tcp协议，实现文件上传的客户端。</span><br><span class=\"line\">*/</span><br><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序运行的参数结构体。</span><br><span class=\"line\">struct st_arg</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int  clienttype;          // 客户端类型，1-上传文件；2-下载文件。</span><br><span class=\"line\">  char ip[31];              // 服务端的IP地址。</span><br><span class=\"line\">  int  port;                // 服务端的端口。</span><br><span class=\"line\">  int  ptype;               // 文件上传成功后本地文件的处理方式：1-删除文件；2-移动到备份目录。</span><br><span class=\"line\">  char clientpath[301];     // 本地文件存放的根目录。</span><br><span class=\"line\">  char clientpathbak[301];  // 文件成功上传后，本地文件备份的根目录，当ptype==2时有效。</span><br><span class=\"line\">  bool andchild;            // 是否上传clientpath目录下各级子目录的文件，true-是；false-否。</span><br><span class=\"line\">  char matchname[301];      // 待上传文件名的匹配规则，如&quot;*.TXT,*.XML&quot;。</span><br><span class=\"line\">  char srvpath[301];        // 服务端文件存放的根目录。</span><br><span class=\"line\">  int  timetvl;             // 扫描本地目录文件的时间间隔，单位：秒。</span><br><span class=\"line\">  int  timeout;             // 进程心跳的超时时间。</span><br><span class=\"line\">  char pname[51];           // 进程名，建议用&quot;tcpputfiles_后缀&quot;的方式。</span><br><span class=\"line\">&#125; starg;</span><br><span class=\"line\"></span><br><span class=\"line\">CLogFile logfile;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序退出和信号2、15的处理函数。</span><br><span class=\"line\">void EXIT(int sig);</span><br><span class=\"line\"></span><br><span class=\"line\">void _help();</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构中。</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">CTcpClient TcpClient;</span><br><span class=\"line\"></span><br><span class=\"line\">bool Login(const char *argv);    // 登录业务。</span><br><span class=\"line\"></span><br><span class=\"line\">bool ActiveTest();    // 心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">char strrecvbuffer[1024];   // 发送报文的buffer。</span><br><span class=\"line\">char strsendbuffer[1024];   // 接收报文的buffer。</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件上传的主函数，执行一次文件上传的任务。</span><br><span class=\"line\">bool _tcpputfiles();</span><br><span class=\"line\">bool bcontinue=true;   // 如果调用_tcpputfiles发送了文件，bcontinue为true，初始化为true。</span><br><span class=\"line\"></span><br><span class=\"line\">// 把文件的内容发送给对端。</span><br><span class=\"line\">bool SendFile(const int sockfd,const char *filename,const int filesize);</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除或者转存本地的文件。</span><br><span class=\"line\">bool AckMessage(const char *strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">CPActive PActive;  // 进程心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (argc!=3) &#123; _help(); return -1; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭全部的信号和输入输出。</span><br><span class=\"line\">  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。</span><br><span class=\"line\">  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。</span><br><span class=\"line\">  CloseIOAndSignal(); signal(SIGINT,EXIT); signal(SIGTERM,EXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 打开日志文件。</span><br><span class=\"line\">  if (logfile.Open(argv[1],&quot;a+&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;打开日志文件失败（%s）。\\n&quot;,argv[1]); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 解析xml，得到程序运行的参数。</span><br><span class=\"line\">  if (_xmltoarg(argv[2])==false) return -1;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.AddPInfo(starg.timeout,starg.pname);  // 把进程的心跳信息写入共享内存。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 向服务端发起连接请求。</span><br><span class=\"line\">  if (TcpClient.ConnectToServer(starg.ip,starg.port)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;TcpClient.ConnectToServer(%s,%d) failed.\\n&quot;,starg.ip,starg.port); EXIT(-1);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录业务。</span><br><span class=\"line\">  if (Login(argv[2])==false) &#123; logfile.Write(&quot;Login() failed.\\n&quot;); EXIT(-1); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 调用文件上传的主函数，执行一次文件上传的任务。</span><br><span class=\"line\">    if (_tcpputfiles()==false) &#123; logfile.Write(&quot;_tcpputfiles() failed.\\n&quot;); EXIT(-1); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (bcontinue==false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      sleep(starg.timetvl);</span><br><span class=\"line\"></span><br><span class=\"line\">      if (ActiveTest()==false) break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PActive.UptATime();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">  EXIT(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 心跳。 </span><br><span class=\"line\">bool ActiveTest()    </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\">  memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\"> </span><br><span class=\"line\">  SPRINTF(strsendbuffer,sizeof(strsendbuffer),&quot;&lt;activetest&gt;ok&lt;/activetest&gt;&quot;);</span><br><span class=\"line\">  // logfile.Write(&quot;发送：%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">  if (TcpClient.Write(strsendbuffer)==false) return false; // 向服务端发送请求报文。</span><br><span class=\"line\"></span><br><span class=\"line\">  if (TcpClient.Read(strrecvbuffer,20)==false) return false; // 接收服务端的回应报文。</span><br><span class=\"line\">  // logfile.Write(&quot;接收：%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 登录业务。 </span><br><span class=\"line\">bool Login(const char *argv)    </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\">  memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\"> </span><br><span class=\"line\">  SPRINTF(strsendbuffer,sizeof(strsendbuffer),&quot;%s&lt;clienttype&gt;1&lt;/clienttype&gt;&quot;,argv);</span><br><span class=\"line\">  logfile.Write(&quot;发送：%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">  if (TcpClient.Write(strsendbuffer)==false) return false; // 向服务端发送请求报文。</span><br><span class=\"line\"></span><br><span class=\"line\">  if (TcpClient.Read(strrecvbuffer,20)==false) return false; // 接收服务端的回应报文。</span><br><span class=\"line\">  logfile.Write(&quot;接收：%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">  logfile.Write(&quot;登录(%s:%d)成功。\\n&quot;,starg.ip,starg.port); </span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EXIT(int sig)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  logfile.Write(&quot;程序退出，sig=%d\\n\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void _help()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;\\n&quot;);</span><br><span class=\"line\">  printf(&quot;Using:/project/tools1/bin/tcpputfiles logfilename xmlbuffer\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;Sample:/project/tools1/bin/procctl 20 /project/tools1/bin/tcpputfiles /log/idc/tcpputfiles_surfdata.log \\&quot;&lt;ip&gt;39.106.159.62&lt;/ip&gt;&lt;port&gt;5005&lt;/port&gt;&lt;ptype&gt;1&lt;/ptype&gt;&lt;clientpath&gt;/tmp/tcp/surfdata1&lt;/clientpath&gt;&lt;andchild&gt;true&lt;/andchild&gt;&lt;matchname&gt;*.XML,*.CSV,*.JSON&lt;/matchname&gt;&lt;srvpath&gt;/tmp/tcp/surfdata2&lt;/srvpath&gt;&lt;timetvl&gt;10&lt;/timetvl&gt;&lt;timeout&gt;50&lt;/timeout&gt;&lt;pname&gt;tcpputfiles_surfdata&lt;/pname&gt;\\&quot;\\n&quot;);</span><br><span class=\"line\">  printf(&quot;       /project/tools1/bin/procctl 20 /project/tools1/bin/tcpputfiles /log/idc/tcpputfiles_surfdata.log \\&quot;&lt;ip&gt;39.106.159.62&lt;/ip&gt;&lt;port&gt;5005&lt;/port&gt;&lt;ptype&gt;2&lt;/ptype&gt;&lt;clientpath&gt;/tmp/tcp/surfdata1&lt;/clientpath&gt;&lt;clientpathbak&gt;/tmp/tcp/surfdata1bak&lt;/clientpathbak&gt;&lt;andchild&gt;true&lt;/andchild&gt;&lt;matchname&gt;*.XML,*.CSV,*.JSON&lt;/matchname&gt;&lt;srvpath&gt;/tmp/tcp/surfdata2&lt;/srvpath&gt;&lt;timetvl&gt;10&lt;/timetvl&gt;&lt;timeout&gt;50&lt;/timeout&gt;&lt;pname&gt;tcpputfiles_surfdata&lt;/pname&gt;\\&quot;\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;本程序是数据中心的公共功能模块，采用tcp协议把文件上传给服务端。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;logfilename   本程序运行的日志文件。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;xmlbuffer     本程序运行的参数，如下：\\n&quot;);</span><br><span class=\"line\">  printf(&quot;ip            服务端的IP地址。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;port          服务端的端口。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;ptype         文件上传成功后的处理方式：1-删除文件；2-移动到备份目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;clientpath    本地文件存放的根目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;clientpathbak 文件成功上传后，本地文件备份的根目录，当ptype==2时有效。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;andchild      是否上传clientpath目录下各级子目录的文件，true-是；false-否，缺省为false。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;matchname     待上传文件名的匹配规则，如\\&quot;*.TXT,*.XML\\&quot;\\n&quot;);</span><br><span class=\"line\">  printf(&quot;srvpath       服务端文件存放的根目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;timetvl       扫描本地目录文件的时间间隔，单位：秒，取值在1-30之间。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;timeout       本程序的超时时间，单位：秒，视文件大小和网络带宽而定，建议设置50以上。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;pname         进程名，尽可能采用易懂的、与其它进程不同的名称，方便故障排查。\\n\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(&amp;starg,0,sizeof(struct st_arg));</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;ip&quot;,starg.ip);</span><br><span class=\"line\">  if (strlen(starg.ip)==0) &#123; logfile.Write(&quot;ip is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;port&quot;,&amp;starg.port);</span><br><span class=\"line\">  if ( starg.port==0) &#123; logfile.Write(&quot;port is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;ptype&quot;,&amp;starg.ptype);</span><br><span class=\"line\">  if ((starg.ptype!=1)&amp;&amp;(starg.ptype!=2)) &#123; logfile.Write(&quot;ptype not in (1,2).\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;clientpath&quot;,starg.clientpath);</span><br><span class=\"line\">  if (strlen(starg.clientpath)==0) &#123; logfile.Write(&quot;clientpath is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;clientpathbak&quot;,starg.clientpathbak);</span><br><span class=\"line\">  if ((starg.ptype==2)&amp;&amp;(strlen(starg.clientpathbak)==0)) &#123; logfile.Write(&quot;clientpathbak is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;andchild&quot;,&amp;starg.andchild);</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;matchname&quot;,starg.matchname);</span><br><span class=\"line\">  if (strlen(starg.matchname)==0) &#123; logfile.Write(&quot;matchname is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;srvpath&quot;,starg.srvpath);</span><br><span class=\"line\">  if (strlen(starg.srvpath)==0) &#123; logfile.Write(&quot;srvpath is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;timetvl&quot;,&amp;starg.timetvl);</span><br><span class=\"line\">  if (starg.timetvl==0) &#123; logfile.Write(&quot;timetvl is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 扫描本地目录文件的时间间隔，单位：秒。</span><br><span class=\"line\">  // starg.timetvl没有必要超过30秒。</span><br><span class=\"line\">  if (starg.timetvl&gt;30) starg.timetvl=30;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 进程心跳的超时时间，一定要大于starg.timetvl，没有必要小于50秒。</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;timeout&quot;,&amp;starg.timeout);</span><br><span class=\"line\">  if (starg.timeout==0) &#123; logfile.Write(&quot;timeout is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\">  if (starg.timeout&lt;50) starg.timeout=50;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;pname&quot;,starg.pname,50);</span><br><span class=\"line\">  if (strlen(starg.pname)==0) &#123; logfile.Write(&quot;pname is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件上传的主函数，执行一次文件上传的任务。</span><br><span class=\"line\">bool _tcpputfiles()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  CDir Dir;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 调用OpenDir()打开starg.clientpath目录。</span><br><span class=\"line\">  if (Dir.OpenDir(starg.clientpath,starg.matchname,10000,starg.andchild)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;Dir.OpenDir(%s) 失败。\\n&quot;,starg.clientpath); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  int delayed=0;        // 未收到对端确认报文的文件数量。</span><br><span class=\"line\">  int buflen=0;         // 用于存放strrecvbuffer的长度。</span><br><span class=\"line\"></span><br><span class=\"line\">  bcontinue=false;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\">    memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 遍历目录中的每个文件，调用ReadDir()获取一个文件名。</span><br><span class=\"line\">    if (Dir.ReadDir()==false) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    bcontinue=true;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把文件名、修改时间、文件大小组成报文，发送给对端。</span><br><span class=\"line\">    SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;&lt;size&gt;%d&lt;/size&gt;&quot;,Dir.m_FullFileName,Dir.m_ModifyTime,Dir.m_FileSize);</span><br><span class=\"line\"></span><br><span class=\"line\">    // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">    if (TcpClient.Write(strsendbuffer)==false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.Write(&quot;TcpClient.Write() failed.\\n&quot;); return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把文件的内容发送给对端。</span><br><span class=\"line\">    logfile.Write(&quot;send %s(%d) ...&quot;,Dir.m_FullFileName,Dir.m_FileSize);</span><br><span class=\"line\">    if (SendFile(TcpClient.m_connfd,Dir.m_FullFileName,Dir.m_FileSize)==true)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.WriteEx(&quot;ok.\\n&quot;); delayed++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.WriteEx(&quot;failed.\\n&quot;); TcpClient.Close(); return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PActive.UptATime();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 接收对端的确认报文。</span><br><span class=\"line\">    while (delayed&gt;0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\">      if (TcpRead(TcpClient.m_connfd,strrecvbuffer,&amp;buflen,-1)==false) break;</span><br><span class=\"line\">      // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 删除或者转存本地的文件。</span><br><span class=\"line\">      delayed--;</span><br><span class=\"line\">      AckMessage(strrecvbuffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 继续接收对端的确认报文。</span><br><span class=\"line\">  while (delayed&gt;0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\">    if (TcpRead(TcpClient.m_connfd,strrecvbuffer,&amp;buflen,10)==false) break;</span><br><span class=\"line\">    // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 删除或者转存本地的文件。</span><br><span class=\"line\">    delayed--;</span><br><span class=\"line\">    AckMessage(strrecvbuffer);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 把文件的内容发送给对端。</span><br><span class=\"line\">bool SendFile(const int sockfd,const char *filename,const int filesize)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int  onread=0;        // 每次调用fread时打算读取的字节数。 </span><br><span class=\"line\">  int  bytes=0;         // 调用一次fread从文件中读取的字节数。</span><br><span class=\"line\">  char buffer[1000];    // 存放读取数据的buffer。</span><br><span class=\"line\">  int  totalbytes=0;    // 从文件中已读取的字节总数。</span><br><span class=\"line\">  FILE *fp=NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 以&quot;rb&quot;的模式打开文件。</span><br><span class=\"line\">  if ( (fp=fopen(filename,&quot;rb&quot;))==NULL )  return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(buffer,0,sizeof(buffer));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算本次应该读取的字节数，如果剩余的数据超过1000字节，就打算读1000字节。</span><br><span class=\"line\">    if (filesize-totalbytes&gt;1000) onread=1000;</span><br><span class=\"line\">    else onread=filesize-totalbytes;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从文件中读取数据。</span><br><span class=\"line\">    bytes=fread(buffer,1,onread,fp);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把读取到的数据发送给对端。</span><br><span class=\"line\">    if (bytes&gt;0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      if (Writen(sockfd,buffer,bytes)==false) &#123; fclose(fp); return false; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算文件已读取的字节总数，如果文件已读完，跳出循环。</span><br><span class=\"line\">    totalbytes=totalbytes+bytes;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (totalbytes==filesize) break;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  fclose(fp);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除或者转存本地的文件。</span><br><span class=\"line\">bool AckMessage(const char *strrecvbuffer)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char filename[301];</span><br><span class=\"line\">  char result[11];</span><br><span class=\"line\"></span><br><span class=\"line\">  memset(filename,0,sizeof(filename));</span><br><span class=\"line\">  memset(result,0,sizeof(result));</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strrecvbuffer,&quot;filename&quot;,filename,300);</span><br><span class=\"line\">  GetXMLBuffer(strrecvbuffer,&quot;result&quot;,result,10);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 如果服务端接收文件不成功，直接返回。</span><br><span class=\"line\">  if (strcmp(result,&quot;ok&quot;)!=0) return true;</span><br><span class=\"line\"></span><br><span class=\"line\">  // ptype==1，删除文件。</span><br><span class=\"line\">  if (starg.ptype==1)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    if (REMOVE(filename)==false) &#123; logfile.Write(&quot;REMOVE(%s) failed.\\n&quot;,filename); return false; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // ptype==2，移动到备份目录。</span><br><span class=\"line\">  if (starg.ptype==2)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 生成转存后的备份目录文件名。</span><br><span class=\"line\">    char bakfilename[301];</span><br><span class=\"line\">    STRCPY(bakfilename,sizeof(bakfilename),filename);</span><br><span class=\"line\">    UpdateStr(bakfilename,starg.clientpath,starg.clientpathbak,false);</span><br><span class=\"line\">    if (RENAME(filename,bakfilename)==false) </span><br><span class=\"line\">    &#123; logfile.Write(&quot;RENAME(%s,%s) failed.\\n&quot;,filename,bakfilename); return false; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"tcp客户端下载\"><a href=\"#tcp客户端下载\" class=\"headerlink\" title=\"tcp客户端下载\"></a>tcp客户端下载</h5><p>tcpgetfiles.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * 程序名：tcpgetfiles.cpp，采用tcp协议，实现文件下载的客户端。</span><br><span class=\"line\">*/</span><br><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序运行的参数结构体。</span><br><span class=\"line\">struct st_arg</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int  clienttype;          // 客户端类型，1-上传文件；2-下载文件。</span><br><span class=\"line\">  char ip[31];              // 服务端的IP地址。</span><br><span class=\"line\">  int  port;                // 服务端的端口。</span><br><span class=\"line\">  int  ptype;               // 文件下载成功后服务端文件的处理方式：1-删除文件；2-移动到备份目录。</span><br><span class=\"line\">  char srvpath[301];        // 服务端文件存放的根目录。</span><br><span class=\"line\">  char srvpathbak[301];     // 文件成功下载后，服务端文件备份的根目录，当ptype==2时有效。</span><br><span class=\"line\">  bool andchild;            // 是否下载srvpath目录下各级子目录的文件，true-是；false-否。</span><br><span class=\"line\">  char matchname[301];      // 待下载文件名的匹配规则，如&quot;*.TXT,*.XML&quot;。</span><br><span class=\"line\">  char clientpath[301];     // 客户端文件存放的根目录。</span><br><span class=\"line\">  int  timetvl;             // 扫描服务端目录文件的时间间隔，单位：秒。</span><br><span class=\"line\">  int  timeout;             // 进程心跳的超时时间。</span><br><span class=\"line\">  char pname[51];           // 进程名，建议用&quot;tcpgetfiles_后缀&quot;的方式。</span><br><span class=\"line\">&#125; starg;</span><br><span class=\"line\"></span><br><span class=\"line\">CLogFile logfile;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序退出和信号2、15的处理函数。</span><br><span class=\"line\">void EXIT(int sig);</span><br><span class=\"line\"></span><br><span class=\"line\">void _help();</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构中。</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">CTcpClient TcpClient;</span><br><span class=\"line\"></span><br><span class=\"line\">bool Login(const char *argv);    // 登录业务。</span><br><span class=\"line\"></span><br><span class=\"line\">char strrecvbuffer[1024];   // 发送报文的buffer。</span><br><span class=\"line\">char strsendbuffer[1024];   // 接收报文的buffer。</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件下载的主函数。</span><br><span class=\"line\">void _tcpgetfiles();</span><br><span class=\"line\"></span><br><span class=\"line\">// 接收文件的内容。</span><br><span class=\"line\">bool RecvFile(const int sockfd,const char *filename,const char *mtime,int filesize);</span><br><span class=\"line\"></span><br><span class=\"line\">CPActive PActive;  // 进程心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (argc!=3) &#123; _help(); return -1; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭全部的信号和输入输出。</span><br><span class=\"line\">  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。</span><br><span class=\"line\">  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。</span><br><span class=\"line\">  CloseIOAndSignal(); signal(SIGINT,EXIT); signal(SIGTERM,EXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 打开日志文件。</span><br><span class=\"line\">  if (logfile.Open(argv[1],&quot;a+&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;打开日志文件失败（%s）。\\n&quot;,argv[1]); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 解析xml，得到程序运行的参数。</span><br><span class=\"line\">  if (_xmltoarg(argv[2])==false) return -1;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.AddPInfo(starg.timeout,starg.pname);  // 把进程的心跳信息写入共享内存。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 向服务端发起连接请求。</span><br><span class=\"line\">  if (TcpClient.ConnectToServer(starg.ip,starg.port)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;TcpClient.ConnectToServer(%s,%d) failed.\\n&quot;,starg.ip,starg.port); EXIT(-1);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录业务。</span><br><span class=\"line\">  if (Login(argv[2])==false) &#123; logfile.Write(&quot;Login() failed.\\n&quot;); EXIT(-1); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 调用文件下载的主函数。</span><br><span class=\"line\">  _tcpgetfiles();</span><br><span class=\"line\"></span><br><span class=\"line\">  EXIT(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 登录业务。 </span><br><span class=\"line\">bool Login(const char *argv)    </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\">  memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\"> </span><br><span class=\"line\">  SPRINTF(strsendbuffer,sizeof(strsendbuffer),&quot;%s&lt;clienttype&gt;2&lt;/clienttype&gt;&quot;,argv);</span><br><span class=\"line\">  logfile.Write(&quot;发送：%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">  if (TcpClient.Write(strsendbuffer)==false) return false; // 向服务端发送请求报文。</span><br><span class=\"line\"></span><br><span class=\"line\">  if (TcpClient.Read(strrecvbuffer,20)==false) return false; // 接收服务端的回应报文。</span><br><span class=\"line\">  logfile.Write(&quot;接收：%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">  logfile.Write(&quot;登录(%s:%d)成功。\\n&quot;,starg.ip,starg.port); </span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EXIT(int sig)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  logfile.Write(&quot;程序退出，sig=%d\\n\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void _help()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;\\n&quot;);</span><br><span class=\"line\">  printf(&quot;Using:/project/tools1/bin/tcpgetfiles logfilename xmlbuffer\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;Sample:/project/tools1/bin/procctl 20 /project/tools1/bin/tcpgetfiles /log/idc/tcpgetfiles_surfdata.log \\&quot;&lt;ip&gt;192.168.174.132&lt;/ip&gt;&lt;port&gt;5005&lt;/port&gt;&lt;ptype&gt;1&lt;/ptype&gt;&lt;srvpath&gt;/tmp/tcp/surfdata2&lt;/srvpath&gt;&lt;andchild&gt;true&lt;/andchild&gt;&lt;matchname&gt;*.XML,*.CSV,*.JSON&lt;/matchname&gt;&lt;clientpath&gt;/tmp/tcp/surfdata3&lt;/clientpath&gt;&lt;timetvl&gt;10&lt;/timetvl&gt;&lt;timeout&gt;50&lt;/timeout&gt;&lt;pname&gt;tcpgetfiles_surfdata&lt;/pname&gt;\\&quot;\\n&quot;);</span><br><span class=\"line\">  printf(&quot;       /project/tools1/bin/procctl 20 /project/tools1/bin/tcpgetfiles /log/idc/tcpgetfiles_surfdata.log \\&quot;&lt;ip&gt;192.168.174.132&lt;/ip&gt;&lt;port&gt;5005&lt;/port&gt;&lt;ptype&gt;2&lt;/ptype&gt;&lt;srvpath&gt;/tmp/tcp/surfdata2&lt;/srvpath&gt;&lt;srvpathbak&gt;/tmp/tcp/surfdata2bak&lt;/srvpathbak&gt;&lt;andchild&gt;true&lt;/andchild&gt;&lt;matchname&gt;*.XML,*.CSV,*.JSON&lt;/matchname&gt;&lt;clientpath&gt;/tmp/tcp/surfdata3&lt;/clientpath&gt;&lt;timetvl&gt;10&lt;/timetvl&gt;&lt;timeout&gt;50&lt;/timeout&gt;&lt;pname&gt;tcpgetfiles_surfdata&lt;/pname&gt;\\&quot;\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;本程序是数据中心的公共功能模块，采用tcp协议从服务端下载文件。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;logfilename   本程序运行的日志文件。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;xmlbuffer     本程序运行的参数，如下：\\n&quot;);</span><br><span class=\"line\">  printf(&quot;ip            服务端的IP地址。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;port          服务端的端口。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;ptype         文件下载成功后服务端文件的处理方式：1-删除文件；2-移动到备份目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;srvpath       服务端文件存放的根目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;srvpathbak    文件成功下载后，服务端文件备份的根目录，当ptype==2时有效。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;andchild      是否下载srvpath目录下各级子目录的文件，true-是；false-否，缺省为false。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;matchname     待下载文件名的匹配规则，如\\&quot;*.TXT,*.XML\\&quot;\\n&quot;);</span><br><span class=\"line\">  printf(&quot;clientpath    客户端文件存放的根目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;timetvl       扫描服务目录文件的时间间隔，单位：秒，取值在1-30之间。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;timeout       本程序的超时时间，单位：秒，视文件大小和网络带宽而定，建议设置50以上。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;pname         进程名，尽可能采用易懂的、与其它进程不同的名称，方便故障排查。\\n\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(&amp;starg,0,sizeof(struct st_arg));</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;ip&quot;,starg.ip);</span><br><span class=\"line\">  if (strlen(starg.ip)==0) &#123; logfile.Write(&quot;ip is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;port&quot;,&amp;starg.port);</span><br><span class=\"line\">  if ( starg.port==0) &#123; logfile.Write(&quot;port is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;ptype&quot;,&amp;starg.ptype);</span><br><span class=\"line\">  if ((starg.ptype!=1)&amp;&amp;(starg.ptype!=2)) &#123; logfile.Write(&quot;ptype not in (1,2).\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;srvpath&quot;,starg.srvpath);</span><br><span class=\"line\">  if (strlen(starg.srvpath)==0) &#123; logfile.Write(&quot;srvpath is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;srvpathbak&quot;,starg.srvpathbak);</span><br><span class=\"line\">  if ((starg.ptype==2)&amp;&amp;(strlen(starg.srvpathbak)==0)) &#123; logfile.Write(&quot;srvpathbak is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;andchild&quot;,&amp;starg.andchild);</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;matchname&quot;,starg.matchname);</span><br><span class=\"line\">  if (strlen(starg.matchname)==0) &#123; logfile.Write(&quot;matchname is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;clientpath&quot;,starg.clientpath);</span><br><span class=\"line\">  if (strlen(starg.clientpath)==0) &#123; logfile.Write(&quot;clientpath is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;timetvl&quot;,&amp;starg.timetvl);</span><br><span class=\"line\">  if (starg.timetvl==0) &#123; logfile.Write(&quot;timetvl is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 扫描服务端目录文件的时间间隔，单位：秒。</span><br><span class=\"line\">  // starg.timetvl没有必要超过30秒。</span><br><span class=\"line\">  if (starg.timetvl&gt;30) starg.timetvl=30;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 进程心跳的超时时间，一定要大于starg.timetvl，没有必要小于50秒。</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;timeout&quot;,&amp;starg.timeout);</span><br><span class=\"line\">  if (starg.timeout==0) &#123; logfile.Write(&quot;timeout is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\">  if (starg.timeout&lt;50) starg.timeout=50;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;pname&quot;,starg.pname,50);</span><br><span class=\"line\">  if (strlen(starg.pname)==0) &#123; logfile.Write(&quot;pname is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件下载的主函数。</span><br><span class=\"line\">void _tcpgetfiles()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  PActive.AddPInfo(starg.timeout,starg.pname);</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\">    memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\"></span><br><span class=\"line\">    PActive.UptATime();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 接收服务端的报文。</span><br><span class=\"line\">    // 第二个参数的取值必须大于starg.timetvl，小于starg.timeout。</span><br><span class=\"line\">    if (TcpClient.Read(strrecvbuffer,starg.timetvl+10)==false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.Write(&quot;TcpClient.Read() failed.\\n&quot;); return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 处理心跳报文。</span><br><span class=\"line\">    if (strcmp(strrecvbuffer,&quot;&lt;activetest&gt;ok&lt;/activetest&gt;&quot;)==0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      strcpy(strsendbuffer,&quot;ok&quot;);</span><br><span class=\"line\">      // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">      if (TcpClient.Write(strsendbuffer)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;TcpClient.Write() failed.\\n&quot;); return;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 处理下载文件的请求报文。</span><br><span class=\"line\">    if (strncmp(strrecvbuffer,&quot;&lt;filename&gt;&quot;,10)==0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 解析下载文件请求报文的xml。</span><br><span class=\"line\">      char serverfilename[301];  memset(serverfilename,0,sizeof(serverfilename));</span><br><span class=\"line\">      char mtime[21];            memset(mtime,0,sizeof(mtime));</span><br><span class=\"line\">      int  filesize=0;</span><br><span class=\"line\">      GetXMLBuffer(strrecvbuffer,&quot;filename&quot;,serverfilename,300);</span><br><span class=\"line\">      GetXMLBuffer(strrecvbuffer,&quot;mtime&quot;,mtime,19);</span><br><span class=\"line\">      GetXMLBuffer(strrecvbuffer,&quot;size&quot;,&amp;filesize);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 客户端和服务端文件的目录是不一样的，以下代码生成客户端的文件名。</span><br><span class=\"line\">      // 把文件名中的srvpath替换成clientpath，要小心第三个参数</span><br><span class=\"line\">      char clientfilename[301];  memset(clientfilename,0,sizeof(clientfilename));</span><br><span class=\"line\">      strcpy(clientfilename,serverfilename);</span><br><span class=\"line\">      UpdateStr(clientfilename,starg.srvpath,starg.clientpath,false);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 接收文件的内容。</span><br><span class=\"line\">      logfile.Write(&quot;recv %s(%d) ...&quot;,clientfilename,filesize);</span><br><span class=\"line\">      if (RecvFile(TcpClient.m_connfd,clientfilename,mtime,filesize)==true)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.WriteEx(&quot;ok.\\n&quot;);</span><br><span class=\"line\">        SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;result&gt;ok&lt;/result&gt;&quot;,serverfilename);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      else</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.WriteEx(&quot;failed.\\n&quot;);</span><br><span class=\"line\">        SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;result&gt;failed&lt;/result&gt;&quot;,serverfilename);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 把接收结果返回给对端。</span><br><span class=\"line\">      // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">      if (TcpClient.Write(strsendbuffer)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;TcpClient.Write() failed.\\n&quot;); return;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 接收文件的内容。</span><br><span class=\"line\">bool RecvFile(const int sockfd,const char *filename,const char *mtime,int filesize)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 生成临时文件名。</span><br><span class=\"line\">  char strfilenametmp[301];</span><br><span class=\"line\">  SNPRINTF(strfilenametmp,sizeof(strfilenametmp),300,&quot;%s.tmp&quot;,filename);</span><br><span class=\"line\"></span><br><span class=\"line\">  int  totalbytes=0;        // 已接收文件的总字节数。</span><br><span class=\"line\">  int  onread=0;            // 本次打算接收的字节数。</span><br><span class=\"line\">  char buffer[1000];        // 接收文件内容的缓冲区。</span><br><span class=\"line\">  FILE *fp=NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 创建临时文件。</span><br><span class=\"line\">  if ( (fp=FOPEN(strfilenametmp,&quot;wb&quot;))==NULL ) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(buffer,0,sizeof(buffer));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算本次应该接收的字节数。</span><br><span class=\"line\">    if (filesize-totalbytes&gt;1000) onread=1000;</span><br><span class=\"line\">    else onread=filesize-totalbytes;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 接收文件内容。</span><br><span class=\"line\">    if (Readn(sockfd,buffer,onread)==false) &#123; fclose(fp); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把接收到的内容写入文件。</span><br><span class=\"line\">    fwrite(buffer,1,onread,fp);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算已接收文件的总字节数，如果文件接收完，跳出循环。</span><br><span class=\"line\">    totalbytes=totalbytes+onread;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (totalbytes==filesize) break;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭临时文件。</span><br><span class=\"line\">  fclose(fp);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 重置文件的时间。</span><br><span class=\"line\">  UTime(strfilenametmp,mtime);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把临时文件RENAME为正式的文件。</span><br><span class=\"line\">  if (RENAME(strfilenametmp,filename)==false) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"tcp服务端\"><a href=\"#tcp服务端\" class=\"headerlink\" title=\"tcp服务端\"></a>tcp服务端</h5><p>fileserver.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * 程序名：fileserver.cpp，文件传输的服务端。</span><br><span class=\"line\">*/</span><br><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序运行的参数结构体。</span><br><span class=\"line\">struct st_arg</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int  clienttype;          // 客户端类型，1-上传文件；2-下载文件。</span><br><span class=\"line\">  char ip[31];              // 服务端的IP地址。</span><br><span class=\"line\">  int  port;                // 服务端的端口。</span><br><span class=\"line\">  int  ptype;               // 文件成功传输后的处理方式：1-删除文件；2-移动到备份目录。</span><br><span class=\"line\">  char clientpath[301];     // 客户端文件存放的根目录。</span><br><span class=\"line\">  bool andchild;            // 是否传输各级子目录的文件，true-是；false-否。</span><br><span class=\"line\">  char matchname[301];      // 待传输文件名的匹配规则，如&quot;*.TXT,*.XML&quot;。</span><br><span class=\"line\">  char srvpath[301];        // 服务端文件存放的根目录。</span><br><span class=\"line\">  char srvpathbak[301];     // 文件成功下载后，服务端文件备份的根目录，当ptype==2时有效。</span><br><span class=\"line\">  int  timetvl;             // 扫描目录文件的时间间隔，单位：秒。</span><br><span class=\"line\">  int  timeout;             // 进程心跳的超时时间。</span><br><span class=\"line\">  char pname[51];           // 进程名，建议用&quot;tcpgetfiles_后缀&quot;的方式。</span><br><span class=\"line\">&#125; starg;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构中。</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">CLogFile logfile;      // 服务程序的运行日志。</span><br><span class=\"line\">CTcpServer TcpServer;  // 创建服务端对象。</span><br><span class=\"line\"></span><br><span class=\"line\">void FathEXIT(int sig);  // 父进程退出函数。</span><br><span class=\"line\">void ChldEXIT(int sig);  // 子进程退出函数。</span><br><span class=\"line\"></span><br><span class=\"line\">bool ActiveTest();    // 心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">char strrecvbuffer[1024];   // 发送报文的buffer。</span><br><span class=\"line\">char strsendbuffer[1024];   // 接收报文的buffer。</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件下载的主函数，执行一次文件下载的任务。</span><br><span class=\"line\">bool _tcpputfiles();</span><br><span class=\"line\">bool bcontinue=true;   // 如果调用_tcpputfiles发送了文件，bcontinue为true，初始化为true。</span><br><span class=\"line\"></span><br><span class=\"line\">// 把文件的内容发送给对端。</span><br><span class=\"line\">bool SendFile(const int sockfd,const char *filename,const int filesize);</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除或者转存本地的文件。</span><br><span class=\"line\">bool AckMessage(const char *strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">// 登录业务处理函数。</span><br><span class=\"line\">bool ClientLogin();</span><br><span class=\"line\"></span><br><span class=\"line\">// 上传文件的主函数。</span><br><span class=\"line\">void RecvFilesMain();</span><br><span class=\"line\"></span><br><span class=\"line\">// 下载文件的主函数。</span><br><span class=\"line\">void SendFilesMain();</span><br><span class=\"line\"></span><br><span class=\"line\">// 接收文件的内容。</span><br><span class=\"line\">bool RecvFile(const int sockfd,const char *filename,const char *mtime,int filesize);</span><br><span class=\"line\"></span><br><span class=\"line\">CPActive PActive;  // 进程心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (argc!=3)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;Using:./fileserver port logfile\\n&quot;);</span><br><span class=\"line\">    printf(&quot;Example:./fileserver 5005 /log/idc/fileserver.log\\n&quot;); </span><br><span class=\"line\">    printf(&quot;         /project/tools1/bin/procctl 10 /project/tools1/bin/fileserver 5005 /log/idc/fileserver.log\\n\\n\\n&quot;); </span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭全部的信号和输入输出。</span><br><span class=\"line\">  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程</span><br><span class=\"line\">  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止</span><br><span class=\"line\">  CloseIOAndSignal(); signal(SIGINT,FathEXIT); signal(SIGTERM,FathEXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">  if (logfile.Open(argv[2],&quot;a+&quot;)==false) &#123; printf(&quot;logfile.Open(%s) failed.\\n&quot;,argv[2]); return -1; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 服务端初始化。</span><br><span class=\"line\">  if (TcpServer.InitServer(atoi(argv[1]))==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;TcpServer.InitServer(%s) failed.\\n&quot;,argv[1]); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 等待客户端的连接请求。</span><br><span class=\"line\">    if (TcpServer.Accept()==false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.Write(&quot;TcpServer.Accept() failed.\\n&quot;); FathEXIT(-1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    logfile.Write(&quot;客户端（%s）已连接。\\n&quot;,TcpServer.GetIP());</span><br><span class=\"line\"></span><br><span class=\"line\">    if (fork()&gt;0) &#123; TcpServer.CloseClient(); continue; &#125;  // 父进程继续回到Accept()。</span><br><span class=\"line\">   </span><br><span class=\"line\">    // 子进程重新设置退出信号。</span><br><span class=\"line\">    signal(SIGINT,ChldEXIT); signal(SIGTERM,ChldEXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">    TcpServer.CloseListen();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 子进程与客户端进行通讯，处理业务。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 处理登录客户端的登录报文。</span><br><span class=\"line\">    if (ClientLogin()==false) ChldEXIT(-1);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果clienttype==1，调用上传文件的主函数。</span><br><span class=\"line\">    if (starg.clienttype==1) RecvFilesMain();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果clienttype==2，调用下载文件的主函数。</span><br><span class=\"line\">    if (starg.clienttype==2) SendFilesMain();</span><br><span class=\"line\"></span><br><span class=\"line\">    ChldEXIT(0);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 父进程退出函数。</span><br><span class=\"line\">void FathEXIT(int sig)  </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 以下代码是为了防止信号处理函数在执行的过程中被信号中断。</span><br><span class=\"line\">  signal(SIGINT,SIG_IGN); signal(SIGTERM,SIG_IGN);</span><br><span class=\"line\"></span><br><span class=\"line\">  logfile.Write(&quot;父进程退出，sig=%d。\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  TcpServer.CloseListen();    // 关闭监听的socket。</span><br><span class=\"line\"></span><br><span class=\"line\">  kill(0,15);     // 通知全部的子进程退出。</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 子进程退出函数。</span><br><span class=\"line\">void ChldEXIT(int sig)  </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 以下代码是为了防止信号处理函数在执行的过程中被信号中断。</span><br><span class=\"line\">  signal(SIGINT,SIG_IGN); signal(SIGTERM,SIG_IGN);</span><br><span class=\"line\"></span><br><span class=\"line\">  logfile.Write(&quot;子进程退出，sig=%d。\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  TcpServer.CloseClient();    // 关闭客户端的socket。</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 登录。</span><br><span class=\"line\">bool ClientLogin()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\">  memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\"></span><br><span class=\"line\">  if (TcpServer.Read(strrecvbuffer,20)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;TcpServer.Read() failed.\\n&quot;); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 解析客户端登录报文。</span><br><span class=\"line\">  _xmltoarg(strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">  if ( (starg.clienttype!=1) &amp;&amp; (starg.clienttype!=2) )</span><br><span class=\"line\">    strcpy(strsendbuffer,&quot;failed&quot;);</span><br><span class=\"line\">  else</span><br><span class=\"line\">    strcpy(strsendbuffer,&quot;ok&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  if (TcpServer.Write(strsendbuffer)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;TcpServer.Write() failed.\\n&quot;); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  logfile.Write(&quot;%s login %s.\\n&quot;,TcpServer.GetIP(),strsendbuffer);</span><br><span class=\"line\">  </span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构中</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(&amp;starg,0,sizeof(struct st_arg));</span><br><span class=\"line\"></span><br><span class=\"line\">  // 不需要对参数做合法性判断，客户端已经判断过了。</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;clienttype&quot;,&amp;starg.clienttype);</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;ptype&quot;,&amp;starg.ptype);</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;clientpath&quot;,starg.clientpath);</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;andchild&quot;,&amp;starg.andchild);</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;matchname&quot;,starg.matchname);</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;srvpath&quot;,starg.srvpath);</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;srvpathbak&quot;,starg.srvpathbak);</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;timetvl&quot;,&amp;starg.timetvl);</span><br><span class=\"line\">  if (starg.timetvl&gt;30) starg.timetvl=30;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;timeout&quot;,&amp;starg.timeout);</span><br><span class=\"line\">  if (starg.timeout&lt;50) starg.timeout=50;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;pname&quot;,starg.pname,50);</span><br><span class=\"line\">  strcat(starg.pname,&quot;_srv&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 上传文件的主函数。</span><br><span class=\"line\">void RecvFilesMain()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  PActive.AddPInfo(starg.timeout,starg.pname);</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\">    memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\"></span><br><span class=\"line\">    PActive.UptATime();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 接收客户端的报文。</span><br><span class=\"line\">    // 第二个参数的取值必须大于starg.timetvl，小于starg.timeout。</span><br><span class=\"line\">    if (TcpServer.Read(strrecvbuffer,starg.timetvl+10)==false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.Write(&quot;TcpServer.Read() failed.\\n&quot;); return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 处理心跳报文。</span><br><span class=\"line\">    if (strcmp(strrecvbuffer,&quot;&lt;activetest&gt;ok&lt;/activetest&gt;&quot;)==0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      strcpy(strsendbuffer,&quot;ok&quot;);</span><br><span class=\"line\">      // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">      if (TcpServer.Write(strsendbuffer)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;TcpServer.Write() failed.\\n&quot;); return;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 处理上传文件的请求报文。</span><br><span class=\"line\">    if (strncmp(strrecvbuffer,&quot;&lt;filename&gt;&quot;,10)==0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 解析上传文件请求报文的xml。</span><br><span class=\"line\">      char clientfilename[301];  memset(clientfilename,0,sizeof(clientfilename));</span><br><span class=\"line\">      char mtime[21];            memset(mtime,0,sizeof(mtime));</span><br><span class=\"line\">      int  filesize=0;</span><br><span class=\"line\">      GetXMLBuffer(strrecvbuffer,&quot;filename&quot;,clientfilename,300);</span><br><span class=\"line\">      GetXMLBuffer(strrecvbuffer,&quot;mtime&quot;,mtime,19);</span><br><span class=\"line\">      GetXMLBuffer(strrecvbuffer,&quot;size&quot;,&amp;filesize);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 客户端和服务端文件的目录是不一样的，以下代码生成服务端的文件名。</span><br><span class=\"line\">      // 把文件名中的clientpath替换成srvpath，要小心第三个参数</span><br><span class=\"line\">      char serverfilename[301];  memset(serverfilename,0,sizeof(serverfilename));</span><br><span class=\"line\">      strcpy(serverfilename,clientfilename);</span><br><span class=\"line\">      UpdateStr(serverfilename,starg.clientpath,starg.srvpath,false);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 接收文件的内容。</span><br><span class=\"line\">      logfile.Write(&quot;recv %s(%d) ...&quot;,serverfilename,filesize);</span><br><span class=\"line\">      if (RecvFile(TcpServer.m_connfd,serverfilename,mtime,filesize)==true)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.WriteEx(&quot;ok.\\n&quot;);</span><br><span class=\"line\">        SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;result&gt;ok&lt;/result&gt;&quot;,clientfilename);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      else</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.WriteEx(&quot;failed.\\n&quot;);</span><br><span class=\"line\">        SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;result&gt;failed&lt;/result&gt;&quot;,clientfilename);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 把接收结果返回给对端。</span><br><span class=\"line\">      // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">      if (TcpServer.Write(strsendbuffer)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;TcpServer.Write() failed.\\n&quot;); return;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 接收文件的内容。</span><br><span class=\"line\">bool RecvFile(const int sockfd,const char *filename,const char *mtime,int filesize)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 生成临时文件名。</span><br><span class=\"line\">  char strfilenametmp[301];</span><br><span class=\"line\">  SNPRINTF(strfilenametmp,sizeof(strfilenametmp),300,&quot;%s.tmp&quot;,filename);</span><br><span class=\"line\"></span><br><span class=\"line\">  int  totalbytes=0;        // 已接收文件的总字节数。</span><br><span class=\"line\">  int  onread=0;            // 本次打算接收的字节数。</span><br><span class=\"line\">  char buffer[1000];        // 接收文件内容的缓冲区。</span><br><span class=\"line\">  FILE *fp=NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 创建临时文件。</span><br><span class=\"line\">  if ( (fp=FOPEN(strfilenametmp,&quot;wb&quot;))==NULL ) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(buffer,0,sizeof(buffer));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算本次应该接收的字节数。</span><br><span class=\"line\">    if (filesize-totalbytes&gt;1000) onread=1000;</span><br><span class=\"line\">    else onread=filesize-totalbytes;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 接收文件内容。</span><br><span class=\"line\">    if (Readn(sockfd,buffer,onread)==false) &#123; fclose(fp); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把接收到的内容写入文件。</span><br><span class=\"line\">    fwrite(buffer,1,onread,fp);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算已接收文件的总字节数，如果文件接收完，跳出循环。</span><br><span class=\"line\">    totalbytes=totalbytes+onread;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (totalbytes==filesize) break;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭临时文件。</span><br><span class=\"line\">  fclose(fp);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 重置文件的时间。</span><br><span class=\"line\">  UTime(strfilenametmp,mtime);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把临时文件RENAME为正式的文件。</span><br><span class=\"line\">  if (RENAME(strfilenametmp,filename)==false) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 下载文件的主函数。</span><br><span class=\"line\">void SendFilesMain()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  PActive.AddPInfo(starg.timeout,starg.pname);</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 调用文件下载的主函数，执行一次文件下载的任务。</span><br><span class=\"line\">    if (_tcpputfiles()==false) &#123; logfile.Write(&quot;_tcpputfiles() failed.\\n&quot;); return; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (bcontinue==false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      sleep(starg.timetvl);</span><br><span class=\"line\"></span><br><span class=\"line\">      if (ActiveTest()==false) break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PActive.UptATime();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 心跳。</span><br><span class=\"line\">bool ActiveTest()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\">  memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\"></span><br><span class=\"line\">  SPRINTF(strsendbuffer,sizeof(strsendbuffer),&quot;&lt;activetest&gt;ok&lt;/activetest&gt;&quot;);</span><br><span class=\"line\">  // logfile.Write(&quot;发送：%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">  if (TcpServer.Write(strsendbuffer)==false) return false; // 向服务端发送请求报文。</span><br><span class=\"line\"></span><br><span class=\"line\">  if (TcpServer.Read(strrecvbuffer,20)==false) return false; // 接收服务端的回应报文。</span><br><span class=\"line\">  // logfile.Write(&quot;接收：%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件下载的主函数，执行一次文件下载的任务。</span><br><span class=\"line\">bool _tcpputfiles()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  CDir Dir;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 调用OpenDir()打开starg.srvpath目录。</span><br><span class=\"line\">  if (Dir.OpenDir(starg.srvpath,starg.matchname,10000,starg.andchild)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;Dir.OpenDir(%s) 失败。\\n&quot;,starg.srvpath); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  int delayed=0;        // 未收到对端确认报文的文件数量。</span><br><span class=\"line\">  int buflen=0;         // 用于存放strrecvbuffer的长度。</span><br><span class=\"line\"></span><br><span class=\"line\">  bcontinue=false;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\">    memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 遍历目录中的每个文件，调用ReadDir()获取一个文件名。</span><br><span class=\"line\">    if (Dir.ReadDir()==false) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    bcontinue=true;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把文件名、修改时间、文件大小组成报文，发送给对端。</span><br><span class=\"line\">    SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;&lt;size&gt;%d&lt;/size&gt;&quot;,Dir.m_FullFileName,Dir.m_ModifyTime,Dir.m_FileSize);</span><br><span class=\"line\"></span><br><span class=\"line\">    // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">    if (TcpServer.Write(strsendbuffer)==false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.Write(&quot;TcpServer.Write() failed.\\n&quot;); return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把文件的内容发送给对端。</span><br><span class=\"line\">    logfile.Write(&quot;send %s(%d) ...&quot;,Dir.m_FullFileName,Dir.m_FileSize);</span><br><span class=\"line\">    if (SendFile(TcpServer.m_connfd,Dir.m_FullFileName,Dir.m_FileSize)==true)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.WriteEx(&quot;ok.\\n&quot;); delayed++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.WriteEx(&quot;failed.\\n&quot;); TcpServer.CloseClient(); return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PActive.UptATime();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 接收对端的确认报文。</span><br><span class=\"line\">    while (delayed&gt;0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\">      if (TcpRead(TcpServer.m_connfd,strrecvbuffer,&amp;buflen,-1)==false) break;</span><br><span class=\"line\">      // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 删除或者转存本地的文件。</span><br><span class=\"line\">      delayed--;</span><br><span class=\"line\">      AckMessage(strrecvbuffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 继续接收对端的确认报文。</span><br><span class=\"line\">  while (delayed&gt;0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\">    if (TcpRead(TcpServer.m_connfd,strrecvbuffer,&amp;buflen,10)==false) break;</span><br><span class=\"line\">    // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 删除或者转存本地的文件。</span><br><span class=\"line\">    delayed--;</span><br><span class=\"line\">    AckMessage(strrecvbuffer);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把文件的内容发送给对端。</span><br><span class=\"line\">bool SendFile(const int sockfd,const char *filename,const int filesize)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int  onread=0;        // 每次调用fread时打算读取的字节数。</span><br><span class=\"line\">  int  bytes=0;         // 调用一次fread从文件中读取的字节数。</span><br><span class=\"line\">  char buffer[1000];    // 存放读取数据的buffer。</span><br><span class=\"line\">  int  totalbytes=0;    // 从文件中已读取的字节总数。</span><br><span class=\"line\">  FILE *fp=NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 以&quot;rb&quot;的模式打开文件。</span><br><span class=\"line\">  if ( (fp=fopen(filename,&quot;rb&quot;))==NULL )  return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(buffer,0,sizeof(buffer));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算本次应该读取的字节数，如果剩余的数据超过1000字节，就打算读1000字节。</span><br><span class=\"line\">    if (filesize-totalbytes&gt;1000) onread=1000;</span><br><span class=\"line\">    else onread=filesize-totalbytes;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从文件中读取数据。</span><br><span class=\"line\">    bytes=fread(buffer,1,onread,fp);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把读取到的数据发送给对端。</span><br><span class=\"line\">    if (bytes&gt;0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      if (Writen(sockfd,buffer,bytes)==false) &#123; fclose(fp); return false; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算文件已读取的字节总数，如果文件已读完，跳出循环。</span><br><span class=\"line\">    totalbytes=totalbytes+bytes;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (totalbytes==filesize) break;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  fclose(fp);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除或者转存本地的文件。</span><br><span class=\"line\">bool AckMessage(const char *strrecvbuffer)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char filename[301];</span><br><span class=\"line\">  char result[11];</span><br><span class=\"line\"></span><br><span class=\"line\">  memset(filename,0,sizeof(filename));</span><br><span class=\"line\">  memset(result,0,sizeof(result));</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strrecvbuffer,&quot;filename&quot;,filename,300);</span><br><span class=\"line\">  GetXMLBuffer(strrecvbuffer,&quot;result&quot;,result,10);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 如果服务端接收文件不成功，直接返回。</span><br><span class=\"line\">  if (strcmp(result,&quot;ok&quot;)!=0) return true;</span><br><span class=\"line\"></span><br><span class=\"line\">  // ptype==1，删除文件。</span><br><span class=\"line\">  if (starg.ptype==1)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    if (REMOVE(filename)==false) &#123; logfile.Write(&quot;REMOVE(%s) failed.\\n&quot;,filename); return false; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // ptype==2，移动到备份目录。</span><br><span class=\"line\">  if (starg.ptype==2)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 生成转存后的备份目录文件名。</span><br><span class=\"line\">    char bakfilename[301];</span><br><span class=\"line\">    STRCPY(bakfilename,sizeof(bakfilename),filename);</span><br><span class=\"line\">    UpdateStr(bakfilename,starg.srvpath,starg.srvpathbak,false);</span><br><span class=\"line\">    if (RENAME(filename,bakfilename)==false)</span><br><span class=\"line\">    &#123; logfile.Write(&quot;RENAME(%s,%s) failed.\\n&quot;,filename,bakfilename); return false; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"tcp编译\"><a href=\"#tcp编译\" class=\"headerlink\" title=\"tcp编译\"></a>tcp编译</h5><p>makefile</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 开发框架头文件路径。</span><br><span class=\"line\">PUBINCL = -I/project/public</span><br><span class=\"line\"></span><br><span class=\"line\"># 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。</span><br><span class=\"line\">PUBCPP = /project/public/_public.cpp</span><br><span class=\"line\"></span><br><span class=\"line\"># 编译参数。</span><br><span class=\"line\">CFLAGS = -g</span><br><span class=\"line\"></span><br><span class=\"line\">all:tcpputfiles fileserver tcpgetfiles </span><br><span class=\"line\"></span><br><span class=\"line\">tcpputfiles:tcpputfiles.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o tcpputfiles tcpputfiles.cpp $(PUBINCL) $(PUBCPP) -lm -lc</span><br><span class=\"line\">\tcp tcpputfiles ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">fileserver:fileserver.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o fileserver fileserver.cpp $(PUBINCL) $(PUBCPP) -lm -lc</span><br><span class=\"line\">\tcp fileserver ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">tcpgetfiles:tcpgetfiles.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o tcpgetfiles tcpgetfiles.cpp $(PUBINCL) $(PUBCPP) -lm -lc</span><br><span class=\"line\">\tcp tcpgetfiles ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -f tcpputfiles fileserver tcpgetfiles </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"mysql数据库开发\"><a href=\"#mysql数据库开发\" class=\"headerlink\" title=\"mysql数据库开发\"></a>mysql数据库开发</h4><h5 id=\"查看修改数据库字符集\"><a href=\"#查看修改数据库字符集\" class=\"headerlink\" title=\"查看修改数据库字符集\"></a>查看修改数据库字符集</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql -u root -p</span><br><span class=\"line\"></span><br><span class=\"line\">SHOW VARIABLES LIKE &#x27;character%&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">quit</span><br><span class=\"line\"></span><br><span class=\"line\">vi /etc/my.cnf</span><br><span class=\"line\"></span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\">character-set-server=utf8</span><br><span class=\"line\"> </span><br><span class=\"line\">[client]</span><br><span class=\"line\">default-character-set=utf8</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"A-查看修改数据库的字符集方式\"><a href=\"#A-查看修改数据库的字符集方式\" class=\"headerlink\" title=\"A. 查看修改数据库的字符集方式\"></a>A. 查看修改数据库的字符集方式</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- database_name 为数据库名称</span><br><span class=\"line\">SHOW CREATE DATABASE database_name;</span><br><span class=\"line\"></span><br><span class=\"line\">-- database_name 为数据库名称</span><br><span class=\"line\">-- utf8为目标字符编码</span><br><span class=\"line\">ALTER DATABSE database_name DEFAULT CHARACTER SET utf8;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"B-查看修改表的字符集方式\"><a href=\"#B-查看修改表的字符集方式\" class=\"headerlink\" title=\"B. 查看修改表的字符集方式\"></a>B. 查看修改表的字符集方式</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- table_name为表的名称</span><br><span class=\"line\">SHOW CREATE TABLE table_name;</span><br><span class=\"line\"></span><br><span class=\"line\">-- table_name为表的名称</span><br><span class=\"line\">-- utf8为目标字符编码</span><br><span class=\"line\">ALTER TABLE table_name DEFAULT CHARACTER SET utf8;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"C-查看字段的字符集方式\"><a href=\"#C-查看字段的字符集方式\" class=\"headerlink\" title=\"C. 查看字段的字符集方式\"></a>C. 查看字段的字符集方式</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- column_name为字段名称</span><br><span class=\"line\">SHOW FULL COLUMNS FROM column_name;</span><br><span class=\"line\"></span><br><span class=\"line\">-- table_name为表的名称</span><br><span class=\"line\">-- column_name为字段名称</span><br><span class=\"line\">-- varchar(20)为字段的类型</span><br><span class=\"line\">-- utf8为目标字符集</span><br><span class=\"line\">ALTER TABLE table_name CHANGE column_name column_name VARCHAR(20) CHARACTER SET utf8;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"D-同时修改表和表中所有字符类型的字段字符集方式\"><a href=\"#D-同时修改表和表中所有字符类型的字段字符集方式\" class=\"headerlink\" title=\"D. 同时修改表和表中所有字符类型的字段字符集方式\"></a>D. 同时修改表和表中所有字符类型的字段字符集方式</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 例子：alter table user2 convert to character set utf8 collate utf8_general_ci;</span><br><span class=\"line\">ALTER TABLE tbl_name CONVERT TO CHARACTER SET character_name [COLLATE ...]</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h5><p>createtable.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  程序名：createtable.cpp，此程序演示开发框架操作MySQL数据库（创建表）。</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  connection conn;   // 数据库连接类。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。</span><br><span class=\"line\">  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span><br><span class=\"line\">  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 准备创建表的SQL语句。</span><br><span class=\"line\">  // 超女表girls，超女编号id，超女姓名name，体重weight，报名时间btime，超女说明memo，超女图片pic。</span><br><span class=\"line\">  stmt.prepare(&quot;create table girls(id      bigint(10),\\</span><br><span class=\"line\">                   name    varchar(30),\\</span><br><span class=\"line\">                   weight  decimal(8,2),\\</span><br><span class=\"line\">                   btime   datetime,\\</span><br><span class=\"line\">                   memo    longtext,\\</span><br><span class=\"line\">                   pic     longblob,\\</span><br><span class=\"line\">                   primary key (id))&quot;);</span><br><span class=\"line\">  /*</span><br><span class=\"line\">  1、int prepare(const char *fmt,...)，SQL语句可以多行书写。</span><br><span class=\"line\">  2、SQL语句最后的分号可有可无，建议不要写（兼容性考虑）。</span><br><span class=\"line\">  3、SQL语句中不能有说明文字。</span><br><span class=\"line\">  4、可以不用判断stmt.prepare()的返回值，stmt.execute()时再判断。</span><br><span class=\"line\">  */</span><br><span class=\"line\"></span><br><span class=\"line\">  // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span><br><span class=\"line\">  // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span><br><span class=\"line\">  if (stmt.execute()!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;create table girls ok.\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">-- 超女基本信息表。</span><br><span class=\"line\">create table girls(id      bigint(10),    -- 超女编号。</span><br><span class=\"line\">                   name    varchar(30),   -- 超女姓名。</span><br><span class=\"line\">                   weight  decimal(8,2),  -- 超女体重。</span><br><span class=\"line\">                   btime   datetime,      -- 报名时间。</span><br><span class=\"line\">                   memo    longtext,      -- 备注。</span><br><span class=\"line\">                   pic     longblob,      -- 照片。</span><br><span class=\"line\">                   primary key (id));</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h5><p>inserttable.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  程序名：inserttable.cpp，此程序演示开发框架操作MySQL数据库（向表中插入5条记录）。</span><br><span class=\"line\">*/</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  connection conn;   // 数据库连接类。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。</span><br><span class=\"line\">  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span><br><span class=\"line\">  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 定义用于超女信息的结构，与表中的字段对应。</span><br><span class=\"line\">  struct st_girls</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    long   id;        // 超女编号</span><br><span class=\"line\">    char   name[31];  // 超女姓名</span><br><span class=\"line\">    double weight;    // 超女体重</span><br><span class=\"line\">    char   btime[20]; // 报名时间</span><br><span class=\"line\">  &#125; stgirls;</span><br><span class=\"line\"></span><br><span class=\"line\">  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 准备插入表的SQL语句。</span><br><span class=\"line\">  stmt.prepare(&quot;\\</span><br><span class=\"line\">    insert into girls(id,name,weight,btime) values(:1+1,:2,:3+45.35,str_to_date(:4,&#x27;%%Y-%%m-%%d %%H:%%i:%%s&#x27;))&quot;);</span><br><span class=\"line\">    //insert into girls(id,name,weight,btime) values(?+1,?,?+45.35,to_date(?,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;))&quot;);</span><br><span class=\"line\">  /*</span><br><span class=\"line\">    注意事项：</span><br><span class=\"line\">    1、参数的序号从1开始，连续、递增，参数也可以用问号表示，但是，问号的兼容性不好，不建议；</span><br><span class=\"line\">    2、SQL语句中的右值才能作为参数，表名、字段名、关键字、函数名等都不能作为参数；</span><br><span class=\"line\">    3、参数可以参与运算或用于函数的参数；</span><br><span class=\"line\">    4、如果SQL语句的主体没有改变，只需要prepare()一次就可以了；</span><br><span class=\"line\">    5、SQL语句中的每个参数，必须调用bindin()绑定变量的地址；</span><br><span class=\"line\">    6、如果SQL语句的主体已改变，prepare()后，需重新用bindin()绑定变量；</span><br><span class=\"line\">    7、prepare()方法有返回值，一般不检查，如果SQL语句有问题，调用execute()方法时能发现；</span><br><span class=\"line\">    8、bindin()方法的返回值固定为0，不用判断返回值；</span><br><span class=\"line\">    9、prepare()和bindin()之后，每调用一次execute()，就执行一次SQL语句，SQL语句的数据来自被绑定变量的值。</span><br><span class=\"line\">  */</span><br><span class=\"line\">  stmt.bindin(1,&amp;stgirls.id);</span><br><span class=\"line\">  stmt.bindin(2, stgirls.name,30);</span><br><span class=\"line\">  stmt.bindin(3,&amp;stgirls.weight);</span><br><span class=\"line\">  stmt.bindin(4, stgirls.btime,19);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 模拟超女数据，向表中插入5条测试数据。</span><br><span class=\"line\">  for (int ii=0;ii&lt;5;ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stgirls,0,sizeof(struct st_girls));         // 结构体变量初始化。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为结构体变量的成员赋值。</span><br><span class=\"line\">    stgirls.id=ii;                                     // 超女编号。</span><br><span class=\"line\">    sprintf(stgirls.name,&quot;西施%05dgirl&quot;,ii+1);         // 超女姓名。</span><br><span class=\"line\">    stgirls.weight=ii;                                 // 超女体重。</span><br><span class=\"line\">    sprintf(stgirls.btime,&quot;2021-08-25 10:33:%02d&quot;,ii); // 报名时间。 </span><br><span class=\"line\"></span><br><span class=\"line\">    // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span><br><span class=\"line\">    // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span><br><span class=\"line\">    if (stmt.execute()!=0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;成功插入了%ld条记录。\\n&quot;,stmt.m_cda.rpc); // stmt.m_cda.rpc是本次执行SQL影响的记录数。</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;insert table girls ok.\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  conn.commit();   // 提交数据库事务。</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"修改数据\"><a href=\"#修改数据\" class=\"headerlink\" title=\"修改数据\"></a>修改数据</h5><p>updatetable.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  程序名：updatetable.cpp，此程序演示开发框架操作MySQL数据库（修改表中的记录）。</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  connection conn;   // 数据库连接类。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。</span><br><span class=\"line\">  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span><br><span class=\"line\">  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 定义用于超女信息的结构，与表中的字段对应。</span><br><span class=\"line\">  struct st_girls</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    long   id;        // 超女编号</span><br><span class=\"line\">    char   name[31];  // 超女姓名</span><br><span class=\"line\">    double weight;    // 超女体重</span><br><span class=\"line\">    char   btime[20]; // 报名时间</span><br><span class=\"line\">  &#125; stgirls;</span><br><span class=\"line\"></span><br><span class=\"line\">  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 准备修改表的SQL语句。</span><br><span class=\"line\">  stmt.prepare(&quot;\\</span><br><span class=\"line\">    update girls set name=:1,weight=:2,btime=str_to_date(:3,&#x27;%%Y-%%m-%%d %%H:%%i:%%s&#x27;) where id=:4&quot;);</span><br><span class=\"line\">  /*</span><br><span class=\"line\">    注意事项：</span><br><span class=\"line\">    1、参数的序号从1开始，连续、递增，参数也可以用问号表示，但是，问号的兼容性不好，不建议；</span><br><span class=\"line\">    2、SQL语句中的右值才能作为参数，表名、字段名、关键字、函数名等都不能作为参数；</span><br><span class=\"line\">    3、参数可以参与运算或用于函数的参数；</span><br><span class=\"line\">    4、如果SQL语句的主体没有改变，只需要prepare()一次就可以了；</span><br><span class=\"line\">    5、SQL语句中的每个参数，必须调用bindin()绑定变量的地址；</span><br><span class=\"line\">    6、如果SQL语句的主体已改变，prepare()后，需重新用bindin()绑定变量；</span><br><span class=\"line\">    7、prepare()方法有返回值，一般不检查，如果SQL语句有问题，调用execute()方法时能发现；</span><br><span class=\"line\">    8、bindin()方法的返回值固定为0，不用判断返回值；</span><br><span class=\"line\">    9、prepare()和bindin()之后，每调用一次execute()，就执行一次SQL语句，SQL语句的数据来自被绑定变量的值。</span><br><span class=\"line\">  */</span><br><span class=\"line\">  stmt.bindin(1, stgirls.name,30);</span><br><span class=\"line\">  stmt.bindin(2,&amp;stgirls.weight);</span><br><span class=\"line\">  stmt.bindin(3, stgirls.btime,19);</span><br><span class=\"line\">  stmt.bindin(4,&amp;stgirls.id);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 模拟超女数据，修改超女信息表中的全部记录。</span><br><span class=\"line\">  for (int ii=0;ii&lt;5;ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stgirls,0,sizeof(struct st_girls));         // 结构体变量初始化。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为结构体变量的成员赋值。</span><br><span class=\"line\">    stgirls.id=ii+1;                                   // 超女编号。</span><br><span class=\"line\">    sprintf(stgirls.name,&quot;貂蝉%05dgirl&quot;,ii+1);         // 超女姓名。</span><br><span class=\"line\">    stgirls.weight=ii+48.39;                           // 超女体重。</span><br><span class=\"line\">    sprintf(stgirls.btime,&quot;2021-10-02 11:25:%02d&quot;,ii); // 报名时间。 </span><br><span class=\"line\"></span><br><span class=\"line\">    // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span><br><span class=\"line\">    // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span><br><span class=\"line\">    if (stmt.execute()!=0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;成功修改了%ld条记录。\\n&quot;,stmt.m_cda.rpc); // stmt.m_cda.rpc是本次执行SQL影响的记录数。</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;update table girls ok.\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  conn.commit();   // 提交数据库事务。</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h5><p>selecttable.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  程序名：selecttable.cpp，此程序演示开发框架操作MySQL数据库（查询表中的记录）。</span><br><span class=\"line\">*/</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  connection conn;   // 数据库连接类。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。</span><br><span class=\"line\">  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span><br><span class=\"line\">  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 定义用于超女信息的结构，与表中的字段对应。</span><br><span class=\"line\">  struct st_girls</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    long   id;        // 超女编号</span><br><span class=\"line\">    char   name[31];  // 超女姓名</span><br><span class=\"line\">    double weight;    // 超女体重</span><br><span class=\"line\">    char   btime[20]; // 报名时间</span><br><span class=\"line\">  &#125; stgirls;</span><br><span class=\"line\"></span><br><span class=\"line\">  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">  int iminid,imaxid;  // 查询条件最小和最大的id。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 准备查询表的SQL语句。</span><br><span class=\"line\">  stmt.prepare(&quot;\\</span><br><span class=\"line\">    select id,name,weight,date_format(btime,&#x27;%%Y-%%m-%%d %%H:%%i:%%s&#x27;) from girls where id&gt;=:1 and id&lt;=:2&quot;);</span><br><span class=\"line\">  /*</span><br><span class=\"line\">    注意事项：</span><br><span class=\"line\">    1、如果SQL语句的主体没有改变，只需要prepare()一次就可以了；</span><br><span class=\"line\">    2、结果集中的字段，调用bindout()绑定变量的地址；</span><br><span class=\"line\">    3、bindout()方法的返回值固定为0，不用判断返回值；</span><br><span class=\"line\">    4、如果SQL语句的主体已改变，prepare()后，需重新用bindout()绑定变量；</span><br><span class=\"line\">    5、调用execute()方法执行SQL语句，然后再循环调用next()方法获取结果集中的记录；</span><br><span class=\"line\">    6、每调用一次next()方法，从结果集中获取一条记录，字段内容保存在已绑定的变量中。</span><br><span class=\"line\">  */</span><br><span class=\"line\">  // 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span><br><span class=\"line\">  stmt.bindin(1,&amp;iminid);</span><br><span class=\"line\">  stmt.bindin(2,&amp;imaxid);</span><br><span class=\"line\">  // 为SQL语句绑定输出变量的地址，bindout方法不需要判断返回值。</span><br><span class=\"line\">  stmt.bindout(1,&amp;stgirls.id);</span><br><span class=\"line\">  stmt.bindout(2, stgirls.name,30);</span><br><span class=\"line\">  stmt.bindout(3,&amp;stgirls.weight);</span><br><span class=\"line\">  stmt.bindout(4, stgirls.btime,19);</span><br><span class=\"line\"></span><br><span class=\"line\">  iminid=1;    // 指定待查询记录的最小id的值。</span><br><span class=\"line\">  imaxid=3;    // 指定待查询记录的最大id的值。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span><br><span class=\"line\">  // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span><br><span class=\"line\">  if (stmt.execute() != 0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。</span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stgirls,0,sizeof(struct st_girls));         // 结构体变量初始化。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从结果集中获取一条记录，一定要判断返回值，0-成功，1403-无记录，其它-失败。</span><br><span class=\"line\">    // 在实际开发中，除了0和1403，其它的情况极少出现。</span><br><span class=\"line\">    if (stmt.next()!=0) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把获取到的记录的值打印出来。</span><br><span class=\"line\">    printf(&quot;id=%ld,name=%s,weight=%.02f,btime=%s\\n&quot;,stgirls.id,stgirls.name,stgirls.weight,stgirls.btime);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span><br><span class=\"line\">  printf(&quot;本次查询了girls表%ld条记录。\\n&quot;,stmt.m_cda.rpc);</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h5><p>deletetable.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  程序名：deletetable.cpp，此程序演示开发框架操作MySQL数据库（删除表中的记录）。</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  connection conn;   // 数据库连接类。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。</span><br><span class=\"line\">  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span><br><span class=\"line\">  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">  int iminid,imaxid;  // 删除条件最小和最大的id。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 准备删除表的SQL语句。</span><br><span class=\"line\">  stmt.prepare(&quot;delete from girls where id&gt;=:1 and id&lt;=:2&quot;);</span><br><span class=\"line\">  // 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span><br><span class=\"line\">  stmt.bindin(1,&amp;iminid);</span><br><span class=\"line\">  stmt.bindin(2,&amp;imaxid);</span><br><span class=\"line\"></span><br><span class=\"line\">  iminid=1;    // 指定待删除记录的最小id的值。</span><br><span class=\"line\">  imaxid=3;    // 指定待删除记录的最大id的值。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span><br><span class=\"line\">  // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span><br><span class=\"line\">  if (stmt.execute() != 0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span><br><span class=\"line\">  printf(&quot;本次删除了girls表%ld条记录。\\n&quot;,stmt.m_cda.rpc);</span><br><span class=\"line\"></span><br><span class=\"line\">  conn.commit();   // 提交数据库事务。</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"二进制大对象存放\"><a href=\"#二进制大对象存放\" class=\"headerlink\" title=\"二进制大对象存放\"></a>二进制大对象存放</h5><p>filetoblob.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  程序名：filetoblob.cpp，此程序演示开发框架操作MySQL数据库（把图片文件存入BLOB字段）。</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  connection conn;   // 数据库连接类。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。</span><br><span class=\"line\">  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span><br><span class=\"line\">  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 定义用于超女信息的结构，与表中的字段对应。</span><br><span class=\"line\">  struct st_girls</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    long   id;             // 超女编号</span><br><span class=\"line\">    char   pic[100000];    // 超女图片的内容。</span><br><span class=\"line\">    unsigned long picsize; // 图片内容占用的字节数。</span><br><span class=\"line\">  &#125; stgirls;</span><br><span class=\"line\"></span><br><span class=\"line\">  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 准备修改表的SQL语句。</span><br><span class=\"line\">  stmt.prepare(&quot;update girls set pic=:1 where id=:2&quot;);</span><br><span class=\"line\">  stmt.bindinlob(1, stgirls.pic,&amp;stgirls.picsize);</span><br><span class=\"line\">  stmt.bindin(2,&amp;stgirls.id);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 修改超女信息表中id为1、2的记录。</span><br><span class=\"line\">  for (int ii=1;ii&lt;3;ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stgirls,0,sizeof(struct st_girls));         // 结构体变量初始化。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为结构体变量的成员赋值。</span><br><span class=\"line\">    stgirls.id=ii;                                   // 超女编号。</span><br><span class=\"line\">    // 把图片的内容加载到stgirls.pic中。</span><br><span class=\"line\">    if (ii==1) stgirls.picsize=filetobuf(&quot;1.jpg&quot;,stgirls.pic);</span><br><span class=\"line\">    if (ii==2) stgirls.picsize=filetobuf(&quot;2.jpg&quot;,stgirls.pic);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span><br><span class=\"line\">    // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span><br><span class=\"line\">    if (stmt.execute()!=0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;成功修改了%ld条记录。\\n&quot;,stmt.m_cda.rpc); // stmt.m_cda.rpc是本次执行SQL影响的记录数。</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;update table girls ok.\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  conn.commit();   // 提交数据库事务。</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"二进制大对象抽取\"><a href=\"#二进制大对象抽取\" class=\"headerlink\" title=\"二进制大对象抽取\"></a>二进制大对象抽取</h5><p>blobtofile.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  程序名：blobtofile.cpp，此程序演示开发框架操作MySQL数据库（提取BLOB字段内容到图片文件中）。</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  connection conn;   // 数据库连接类。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。</span><br><span class=\"line\">  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span><br><span class=\"line\">  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 定义用于超女信息的结构，与表中的字段对应。</span><br><span class=\"line\">  struct st_girls</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    long   id;             // 超女编号</span><br><span class=\"line\">    char   pic[100000];    // 超女图片的内容。</span><br><span class=\"line\">    unsigned long picsize; // 图片内容占用的字节数。</span><br><span class=\"line\">  &#125; stgirls;</span><br><span class=\"line\"></span><br><span class=\"line\">  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 准备查询表的SQL语句。</span><br><span class=\"line\">  stmt.prepare(&quot;select id,pic from girls where id in (1,2)&quot;);</span><br><span class=\"line\">  stmt.bindout(1,&amp;stgirls.id);</span><br><span class=\"line\">  stmt.bindoutlob(2, stgirls.pic,100000,&amp;stgirls.picsize);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span><br><span class=\"line\">  // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span><br><span class=\"line\">  if (stmt.execute()!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。</span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stgirls,0,sizeof(stgirls)); // 先把结构体变量初始化。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从结果集中获取一条记录，一定要判断返回值，0-成功，1403-无记录，其它-失败。</span><br><span class=\"line\">    // 在实际开发中，除了0和1403，其它的情况极少出现。</span><br><span class=\"line\">    if (stmt.next()!=0) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 生成文件名。</span><br><span class=\"line\">    char filename[101]; memset(filename,0,sizeof(filename));</span><br><span class=\"line\">    sprintf(filename,&quot;%d_out.jpg&quot;,stgirls.id);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 把内容写入文件。</span><br><span class=\"line\">    buftofile(filename,stgirls.pic,stgirls.picsize);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span><br><span class=\"line\">  printf(&quot;本次查询了girls表%ld条记录。\\n&quot;,stmt.m_cda.rpc);</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"编译文件-5\"><a href=\"#编译文件-5\" class=\"headerlink\" title=\"编译文件\"></a>编译文件</h5><p>makefile</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># mysql头文件存放的目录。locate mysql.h</span><br><span class=\"line\">MYSQLINCL = -I/usr/include/mysql</span><br><span class=\"line\"></span><br><span class=\"line\"># mysql库文件存放的目录。locate libmysqlclient.a</span><br><span class=\"line\">MYSQLLIB = -L/usr/lib64/mysql</span><br><span class=\"line\"></span><br><span class=\"line\">#_mysql.h _mysql.cpp在当前文件夹</span><br><span class=\"line\"></span><br><span class=\"line\"># 需要链接的mysql库。</span><br><span class=\"line\">MYSQLLIBS = -lmysqlclient</span><br><span class=\"line\"></span><br><span class=\"line\">CFLAGS=-g -Wno-write-strings</span><br><span class=\"line\"></span><br><span class=\"line\">all:createtable  inserttable updatetable selecttable deletetable filetoblob blobtofile book1 book2</span><br><span class=\"line\"></span><br><span class=\"line\">createtable:createtable.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o createtable createtable.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">inserttable:inserttable.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o inserttable inserttable.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">updatetable:updatetable.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o updatetable updatetable.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">selecttable:selecttable.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o selecttable selecttable.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">deletetable:deletetable.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o deletetable deletetable.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">filetoblob:filetoblob.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o filetoblob filetoblob.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">blobtofile:blobtofile.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o blobtofile blobtofile.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">book1:book1.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o book1 book1.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">book2:book2.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o book2 book2.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -rf createtable  inserttable updatetable selecttable deletetable filetoblob blobtofile book1 book2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"oracle数据库开发\"><a href=\"#oracle数据库开发\" class=\"headerlink\" title=\"oracle数据库开发\"></a>oracle数据库开发</h4><h4 id=\"数据抽取系统\"><a href=\"#数据抽取系统\" class=\"headerlink\" title=\"数据抽取系统\"></a>数据抽取系统</h4><h4 id=\"数据入库系统\"><a href=\"#数据入库系统\" class=\"headerlink\" title=\"数据入库系统\"></a>数据入库系统</h4><h4 id=\"数据同步系统\"><a href=\"#数据同步系统\" class=\"headerlink\" title=\"数据同步系统\"></a>数据同步系统</h4><h4 id=\"数据服务总线\"><a href=\"#数据服务总线\" class=\"headerlink\" title=\"数据服务总线\"></a>数据服务总线</h4><h4 id=\"io复用-反向代理模块\"><a href=\"#io复用-反向代理模块\" class=\"headerlink\" title=\"io复用 反向代理模块\"></a>io复用 反向代理模块</h4>","text":"Linux知识centos漏洞yum clean all && yum makecacheyum update polkit -y shell编程shell脚本...","permalink":"/post/linux","photos":[],"count_time":{"symbolsCount":"130k","symbolsTime":"1:58"},"categories":[{"name":"操作系统","slug":"操作系统","count":3,"path":"api/categories/操作系统.json"}],"tags":[{"name":"Linux","slug":"Linux","count":1,"path":"api/tags/Linux.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Linux\"><span class=\"toc-text\">Linux</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#shell%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">shell编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#shell%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">shell脚本</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BAecho\"><span class=\"toc-text\">输出echo</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">系统变量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">自定义变量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">设置环境变量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">多行注释</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#linux%E8%A7%A3%E5%8E%8B%E7%BC%A9\"><span class=\"toc-text\">linux解压缩</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#gzip-gunzip-%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">gzip&#x2F;gunzip 指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#zip-unzip-%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">zip&#x2F;unzip 指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#tar-%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">tar 指令</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93\"><span class=\"toc-text\">静态库和动态库</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#linux%E5%B8%AE%E5%8A%A9%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">linux帮助指令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#man-%E8%8E%B7%E5%BE%97%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">man 获得帮助信息</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#help-%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">help 指令</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E9%93%BE%E6%8E%A5-ln-%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">软链接 ln 指令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">搜索文件和文件中的内容</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#find\"><span class=\"toc-text\">find</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#locate\"><span class=\"toc-text\">locate</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#which\"><span class=\"toc-text\">which</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#grep-%E5%92%8C-%E7%AE%A1%E9%81%93%E7%AC%A6%E5%8F%B7\"><span class=\"toc-text\">grep 和 管道符号 |</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%BE%E7%A4%BA%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">显示文本文件的内容</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cat\"><span class=\"toc-text\">cat</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#more\"><span class=\"toc-text\">more</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#tail\"><span class=\"toc-text\">tail</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#head\"><span class=\"toc-text\">head</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#less\"><span class=\"toc-text\">less</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#wc\"><span class=\"toc-text\">wc</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#linux%E4%BF%AE%E6%94%B9ssh%E7%AB%AF%E5%8F%A3\"><span class=\"toc-text\">linux修改ssh端口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#centos%E4%BF%AE%E6%94%B9ssh%E7%AB%AF%E5%8F%A3\"><span class=\"toc-text\">centos修改ssh端口</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#debian%E4%BF%AE%E6%94%B9ssh%E7%AB%AF%E5%8F%A3\"><span class=\"toc-text\">debian修改ssh端口</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ubuntu%E4%BF%AE%E6%94%B9ssh%E7%AB%AF%E5%8F%A3\"><span class=\"toc-text\">ubuntu修改ssh端口</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RPM%E3%80%81YUM%E3%80%81wget\"><span class=\"toc-text\">RPM、YUM、wget</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#rpm-%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">rpm 包的管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#rpm-%E5%8C%85%E7%9A%84%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">rpm 包的简单查询指令</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#rpm-%E5%8C%85%E5%90%8D%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">rpm 包名基本格式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#rpm-%E5%8C%85%E7%9A%84%E5%85%B6%E5%AE%83%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4%EF%BC%9A\"><span class=\"toc-text\">rpm 包的其它查询指令：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8D%B8%E8%BD%BDrpm-%E5%8C%85%EF%BC%9A\"><span class=\"toc-text\">卸载rpm 包：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85rpm-%E5%8C%85\"><span class=\"toc-text\">安装rpm 包</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#yum\"><span class=\"toc-text\">yum</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#yum-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">yum 的基本指令</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E7%9A%84yum-%E5%8C%85\"><span class=\"toc-text\">安装指定的yum 包</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#yum-%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%EF%BC%9A\"><span class=\"toc-text\">yum 应用实例：</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#wget\"><span class=\"toc-text\">wget</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ubuntu%E7%B3%BB%E7%BB%9Fssh%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">ubuntu系统ssh服务</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ubuntu%E7%BB%88%E7%AB%AF%E4%B8%8BMySQL%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87\"><span class=\"toc-text\">ubuntu终端下MySQL输入中文</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ubuntu%E7%9A%84%E9%BB%98%E8%AE%A4root%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">ubuntu的默认root密码设置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%BE%E5%9B%9ELinux-root%E5%AF%86%E7%A0%81\"><span class=\"toc-text\">找回Linux root密码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Linux%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB\"><span class=\"toc-text\">Linux运行级别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">基本介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#centos7-%E5%90%8E%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">centos7 后运行级别说明</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">Linux目录结构</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">安装</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#centos%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8Ftp\"><span class=\"toc-text\">centos安装使用Ftp</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85ftp\"><span class=\"toc-text\">安装ftp</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%AE%89%E8%A3%85ftp%E6%9C%8D%E5%8A%A1%E5%99%A8\"><span class=\"toc-text\">1、安装ftp服务器</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%AE%89%E8%A3%85ftp%E5%AE%A2%E6%88%B7%E7%AB%AF\"><span class=\"toc-text\">2、安装ftp客户端</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AEftp%E6%9C%8D%E5%8A%A1%E5%99%A8\"><span class=\"toc-text\">配置ftp服务器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%85%B3%E9%97%ADSELINUX\"><span class=\"toc-text\">1、关闭SELINUX</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2%E3%80%81%E9%85%8D%E7%BD%AEftp%E6%95%B0%E6%8D%AE%E7%AB%AF%E5%8F%A3%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">2、配置ftp数据端口参数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%BC%80%E9%80%9A%E9%98%B2%E7%81%AB%E5%A2%99\"><span class=\"toc-text\">3、开通防火墙</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%90%AF%E5%8A%A8vsftpd%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">4、启动vsftpd服务</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5%E3%80%81%E4%BA%91%E5%B9%B3%E5%8F%B0%E8%AE%BF%E9%97%AE%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">5、云平台访问策略配置</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ftp%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">ftp开发</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">动态链接库问题</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#centos%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8nginx\"><span class=\"toc-text\">centos安装使用nginx</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">配置文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2\"><span class=\"toc-text\">网站部署</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"><span class=\"toc-text\">反向代理、负载均衡</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#HTTPS\"><span class=\"toc-text\">HTTPS</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#centos%E5%AE%89%E8%A3%85git\"><span class=\"toc-text\">centos安装git</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#centos%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8nvm\"><span class=\"toc-text\">centos安装使用nvm</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#centos%E5%AE%89%E8%A3%85node-js\"><span class=\"toc-text\">centos安装node.js</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#centos7%E5%8D%87%E7%BA%A7GCC\"><span class=\"toc-text\">centos7升级GCC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#centos%E5%AE%89%E8%A3%85g\"><span class=\"toc-text\">centos安装g++</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#centos%E5%AE%89%E8%A3%85tomcat\"><span class=\"toc-text\">centos安装tomcat</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ubuntu%E5%AE%89%E8%A3%85mysql\"><span class=\"toc-text\">ubuntu安装mysql</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#centos%E5%AE%89%E8%A3%85mysql5-7\"><span class=\"toc-text\">centos安装mysql5.7</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#mysql%E6%89%BE%E5%9B%9Eroot%E5%AF%86%E7%A0%81\"><span class=\"toc-text\">mysql找回root密码</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E6%8E%A5mysql\"><span class=\"toc-text\">连接mysql</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E6%9F%A5%E7%9C%8B3306%E7%AB%AF%E5%8F%A3%E6%98%AF%E5%90%A6%E5%BC%80%E6%94%BE\"><span class=\"toc-text\">一、查看3306端口是否开放</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E4%BF%AE%E6%94%B9%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90\"><span class=\"toc-text\">二、修改访问权限</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#CentOS-%E2%80%98mysql-mysql-h%E2%80%98-No-such-file-or-directory\"><span class=\"toc-text\">CentOS ‘mysql&#x2F;mysql.h‘: No such file or directory</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#centos%E5%AE%89%E8%A3%85-JDK\"><span class=\"toc-text\">centos安装 JDK</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#centos%E5%AE%89%E8%A3%85Hexo\"><span class=\"toc-text\">centos安装Hexo</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ubuntu%E5%AE%89%E8%A3%85redis\"><span class=\"toc-text\">ubuntu安装redis</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#centos%E5%AE%89%E8%A3%85redis\"><span class=\"toc-text\">centos安装redis</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ubuntu%E5%AE%89%E8%A3%85webbench\"><span class=\"toc-text\">ubuntu安装webbench</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ubuntu16-04-%E5%AE%89%E8%A3%85boost1-65\"><span class=\"toc-text\">ubuntu16.04 安装boost1.65</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">1. 下载源码</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E7%BC%96%E8%AF%91-boost\"><span class=\"toc-text\">2. 编译 boost</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ubuntu%E7%B3%BB%E7%BB%9F%E2%80%9C%E8%BD%AF%E4%BB%B6%E4%B8%AD%E5%BF%83%E2%80%9D%E9%97%AA%E9%80%80%E6%88%96%E8%80%85%E6%89%93%E4%B8%8D%E5%BC%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">ubuntu系统“软件中心”闪退或者打不开解决方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#killall-command-not-found\"><span class=\"toc-text\">killall: command not found</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%EF%BC%9A\"><span class=\"toc-text\">解决：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CentOS-%E2%80%98mysql-mysql-h%E2%80%98-No-such-file-or-directory-1\"><span class=\"toc-text\">CentOS ‘mysql&#x2F;mysql.h‘: No such file or directory</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%EF%BC%9A-1\"><span class=\"toc-text\">解决：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">命令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#linux%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98\"><span class=\"toc-text\">linux共享内存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98\"><span class=\"toc-text\">查看当前共享内存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98\"><span class=\"toc-text\">删除指定共享内存</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">进程操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">查看进程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">开机启动进程</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">时间操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E6%9F%A5%E7%9C%8B%E6%97%B6%E9%97%B4%E3%80%82\"><span class=\"toc-text\">1）查看时间。</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E8%AE%BE%E7%BD%AE%E6%97%B6%E5%8C%BA%E4%B8%BA%E4%B8%AD%E5%9B%BD%E4%B8%8A%E6%B5%B7%E6%97%B6%E9%97%B4%EF%BC%88%E6%B3%A8%E6%84%8F%E4%B8%8D%E6%98%AF%E5%8C%97%E4%BA%AC%E6%97%B6%E9%97%B4%EF%BC%89%E3%80%82\"><span class=\"toc-text\">2）设置时区为中国上海时间（注意不是北京时间）。</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E8%AE%BE%E7%BD%AE%E6%97%B6%E9%97%B4%E3%80%82\"><span class=\"toc-text\">3）设置时间。</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%EF%BC%89cal-%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">4）cal 指令</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%90%AF%E5%92%8C%E5%85%B3%E6%9C%BA\"><span class=\"toc-text\">重启和关机</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B8%85%E5%B1%8F\"><span class=\"toc-text\">清屏</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84ip%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">查看服务器的ip地址</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">查看当前工作目录</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%94%B9%E5%8F%98%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">改变当前工作目录</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%97%E5%87%BA%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">列出目录和文件信息</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">创建目录文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">删除目录和文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">移动目录和文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E5%88%B6%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">复制目录和文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A4%E6%96%AD%E7%BD%91%E7%BB%9C%E6%98%AF%E5%90%A6%E8%BF%9E%E9%80%9A\"><span class=\"toc-text\">判断网络是否连通</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">用户管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">查询用户信息</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">用户和组相关文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A2%9E%E5%8A%A0-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E7%BB%84\"><span class=\"toc-text\">增加&#x2F;删除用户组</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A2%9E%E5%8A%A0-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7\"><span class=\"toc-text\">增加&#x2F;删除用户</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E7%9A%84%E7%BB%84\"><span class=\"toc-text\">修改用户的组</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E7%9A%84%E5%AF%86%E7%A0%81\"><span class=\"toc-text\">修改用户的密码</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7\"><span class=\"toc-text\">切换用户</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%BB%E4%BA%BA%E5%92%8C%E7%BB%84\"><span class=\"toc-text\">修改目录和文件的主人和组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">查看系统磁盘空间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#echo-%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">echo 指令</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">开发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#public%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">public框架:</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BF%83%E8%B7%B3%E7%A8%8B%E5%BA%8F-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%B3%E7%B1%BB\"><span class=\"toc-text\">心跳程序-框架中的心跳类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#public-h\"><span class=\"toc-text\">_public.h</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#public-cpp\"><span class=\"toc-text\">_public.cpp</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">调度程序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">编译文件</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">守护进程程序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6-1\"><span class=\"toc-text\">编译文件</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">压缩文件程序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6-2\"><span class=\"toc-text\">编译文件</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B8%85%E7%90%86%E6%96%87%E4%BB%B6%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">清理文件程序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6-3\"><span class=\"toc-text\">编译文件</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%8B%9F%E7%94%9F%E4%BA%A7%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">模拟生产测试数据文件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6-4\"><span class=\"toc-text\">编译文件</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ftp%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD\"><span class=\"toc-text\">ftp上传下载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85ftp-1\"><span class=\"toc-text\">安装ftp</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#ftp%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8B%E8%BD%BD\"><span class=\"toc-text\">ftp客户端下载</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#ftp%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E4%BC%A0\"><span class=\"toc-text\">ftp客户端上传</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#ftp%E7%BC%96%E8%AF%91\"><span class=\"toc-text\">ftp编译</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#TCP%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD\"><span class=\"toc-text\">TCP上传下载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#tcp%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E4%BC%A0\"><span class=\"toc-text\">tcp客户端上传</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#tcp%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8B%E8%BD%BD\"><span class=\"toc-text\">tcp客户端下载</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#tcp%E6%9C%8D%E5%8A%A1%E7%AB%AF\"><span class=\"toc-text\">tcp服务端</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#tcp%E7%BC%96%E8%AF%91\"><span class=\"toc-text\">tcp编译</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">mysql数据库开发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E7%AC%A6%E9%9B%86\"><span class=\"toc-text\">查看修改数据库字符集</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#A-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">A. 查看修改数据库的字符集方式</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#B-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">B. 查看修改表的字符集方式</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#C-%E6%9F%A5%E7%9C%8B%E5%AD%97%E6%AE%B5%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">C. 查看字段的字符集方式</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#D-%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E8%A1%A8%E5%92%8C%E8%A1%A8%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E6%AE%B5%E5%AD%97%E7%AC%A6%E9%9B%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">D. 同时修改表和表中所有字符类型的字段字符集方式</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E8%A1%A8\"><span class=\"toc-text\">创建表</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">插入数据</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">修改数据</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">查询数据</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">删除数据</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%94%BE\"><span class=\"toc-text\">二进制大对象存放</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%A4%A7%E5%AF%B9%E8%B1%A1%E6%8A%BD%E5%8F%96\"><span class=\"toc-text\">二进制大对象抽取</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6-5\"><span class=\"toc-text\">编译文件</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">oracle数据库开发</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E6%8A%BD%E5%8F%96%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">数据抽取系统</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">数据入库系统</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">数据同步系统</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BF\"><span class=\"toc-text\">数据服务总线</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#io%E5%A4%8D%E7%94%A8-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">io复用 反向代理模块</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"暗使开开","slug":"blog-author","avatar":"\\favicon.ico","link":"/","description":"<p>即使是虚拟的也会开心</p>唯有终夜长开眼，报以平生未展眉","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/344723412"},"qq":{"icon":"/svg/qq.svg","link":"https://qm.qq.com/q/MXqKNejl6g"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Mac","uid":"aa27a901d34fd36607694c5571971888","slug":"Mac","date":"2024-07-30T07:22:11.000Z","updated":"2024-07-30T07:22:57.898Z","comments":true,"path":"api/articles/Mac.json","keywords":null,"cover":null,"text":"Mac安装​ sudo spctl –master-disable Mac安装MySQL8vi ~/.bash_profileexport PATH=${PAT...","permalink":"/post/Mac","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"操作系统","slug":"操作系统","count":3,"path":"api/categories/操作系统.json"}],"tags":[{"name":"MacOS","slug":"MacOS","count":1,"path":"api/tags/MacOS.json"}],"author":{"name":"暗使开开","slug":"blog-author","avatar":"\\favicon.ico","link":"/","description":"<p>即使是虚拟的也会开心</p>唯有终夜长开眼，报以平生未展眉","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/344723412"},"qq":{"icon":"/svg/qq.svg","link":"https://qm.qq.com/q/MXqKNejl6g"}}}}},"next_post":{"title":"IDEA","uid":"0c28c8671cbf680a33a46ee0d16608fc","slug":"IDEA","date":"2024-07-30T07:17:06.000Z","updated":"2024-07-30T07:17:31.964Z","comments":true,"path":"api/articles/IDEA.json","keywords":null,"cover":null,"text":"IDEA代码编辑 ctrl+shift+V 粘贴复制历史 ctrl+shift+alt+V 不带格式的粘贴 ctrl +alt+L 代码格式化 alt+鼠标左键...","permalink":"/post/IDEA","photos":[],"count_time":{"symbolsCount":731,"symbolsTime":"1 mins."},"categories":[{"name":"开发工具","slug":"开发工具","count":3,"path":"api/categories/开发工具.json"}],"tags":[{"name":"IDEA","slug":"IDEA","count":1,"path":"api/tags/IDEA.json"}],"author":{"name":"暗使开开","slug":"blog-author","avatar":"\\favicon.ico","link":"/","description":"<p>即使是虚拟的也会开心</p>唯有终夜长开眼，报以平生未展眉","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/344723412"},"qq":{"icon":"/svg/qq.svg","link":"https://qm.qq.com/q/MXqKNejl6g"}}}}}}