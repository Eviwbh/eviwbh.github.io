{"title":"C++","uid":"2d728caa47af746573cb7fba96b85d4f","slug":"滑动窗口控制流量","date":"2024-07-29T16:00:00.000Z","updated":"2024-08-04T10:49:36.377Z","comments":true,"path":"api/articles/滑动窗口控制流量.json","keywords":null,"cover":null,"content":"<h1 id=\"滑动窗口控制流量\"><a href=\"#滑动窗口控制流量\" class=\"headerlink\" title=\"滑动窗口控制流量\"></a>滑动窗口控制流量</h1><h2 id=\"滑动窗口是什么，用c-写一个例子说明\"><a href=\"#滑动窗口是什么，用c-写一个例子说明\" class=\"headerlink\" title=\"滑动窗口是什么，用c++写一个例子说明\"></a>滑动窗口是什么，用c++写一个例子说明</h2><p>滑动窗口是一种常用的算法技术，它可以在数组或列表中查找子数组或子列表，以解决各种问题。滑动窗口通常从数组的一端开始，然后向另一端移动，同时保持窗口的大小不变，或者根据某些条件增大或缩小窗口的大小。</p>\n<p>以下是一个使用C++编写的滑动窗口的例子，该例子用于找出数组中和为给定值的连续子数组：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">slidingWindow</span><span class=\"params\">(std::vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; result;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> right = <span class=\"number\">0</span>; right &lt; nums.<span class=\"built_in\">size</span>(); right++) &#123;</span><br><span class=\"line\">        sum += nums[right];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (sum &gt; target) &#123;</span><br><span class=\"line\">            sum -= nums[left];</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum == target) &#123;</span><br><span class=\"line\">            result.<span class=\"built_in\">assign</span>(nums.<span class=\"built_in\">begin</span>() + left, nums.<span class=\"built_in\">begin</span>() + right + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; nums = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> target = <span class=\"number\">9</span>;</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; result = <span class=\"built_in\">slidingWindow</span>(nums, target);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Subarray with sum &quot;</span> &lt;&lt; target &lt;&lt; <span class=\"string\">&quot;: &quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> num : result) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; num &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这个程序首先定义了一个名为<code>slidingWindow</code>的函数，该函数接受一个整数向量和一个目标值作为输入。然后，它使用两个指针<code>left</code>和<code>right</code>来表示滑动窗口的边界，并使用变量<code>sum</code>来跟踪窗口中的数字之和。当<code>sum</code>大于目标值时，它会从<code>sum</code>中减去<code>left</code>指向的数字，并将<code>left</code>向右移动一位。当<code>sum</code>等于目标值时，它会将滑动窗口中的数字添加到结果向量中，并结束循环。最后，<code>main</code>函数中的代码创建了一个示例数组和目标值，并调用<code>slidingWindow</code>函数来找到和为目标值的子数组。然后，它打印出这个子数组的内容。这就是滑动窗口算法的一个基本应用。</p>\n<h2 id=\"如何使用话动窗口控制客户端与服务端之间的流量控制\"><a href=\"#如何使用话动窗口控制客户端与服务端之间的流量控制\" class=\"headerlink\" title=\"如何使用话动窗口控制客户端与服务端之间的流量控制\"></a>如何使用话动窗口控制客户端与服务端之间的流量控制</h2><p>滑动窗口是一种常用的流量控制技术，它可以有效地控制客户端和服务器之间的数据传输速率，以防止网络拥塞。在计算机网络中，滑动窗口协议是一种流量控制协议，TCP（传输控制协议）就是使用滑动窗口协议来进行流量控制的。</p>\n<p>以下是滑动窗口如何用于流量控制的基本步骤：</p>\n<ol>\n<li><strong>初始化窗口大小</strong>：在连接建立时，服务器会告诉客户端它的接收窗口大小，这个大小通常是根据服务器当前的网络状况和处理能力来设定的。</li>\n<li><strong>数据传输</strong>：客户端在发送数据时，会根据服务器告知的窗口大小来确定一次可以发送多少数据。例如，如果窗口大小为5，那么客户端一次最多可以发送5个数据包。</li>\n<li><strong>确认接收</strong>：当服务器接收到数据后，会发送一个确认消息给客户端，告诉客户端已经接收到了哪些数据，并告知新的窗口大小。</li>\n<li><strong>调整窗口大小</strong>：如果网络状况良好，服务器可以增大窗口大小，允许客户端发送更多的数据。如果网络状况变差，服务器可以减小窗口大小，减少客户端的数据发送速率。</li>\n<li><strong>处理丢包</strong>：如果客户端发送的某个数据包在服务器端没有被确认接收，客户端会认为这个数据包丢失，然后重新发送这个数据包。</li>\n</ol>\n<p>通过这种方式，滑动窗口协议可以动态地调整数据的传输速率，有效地控制了客户端和服务器之间的流量，防止了网络拥塞。希望这个解释能帮助你理解滑动窗口是如何用于流量控制的。</p>\n<h2 id=\"用c-写一个滑动窗口来控制流量的例子\"><a href=\"#用c-写一个滑动窗口来控制流量的例子\" class=\"headerlink\" title=\"用c++写一个滑动窗口来控制流量的例子\"></a>用c++写一个滑动窗口来控制流量的例子</h2><p>在实际的网络编程中，滑动窗口通常用于TCP协议的流量控制，这涉及到底层的网络编程和操作系统的API调用，可能比较复杂。但是，我可以给你一个简化的例子，来模拟滑动窗口的基本工作原理。</p>\n<p>这个例子中，我们将创建一个<code>SlidingWindow</code>类，用于模拟滑动窗口的行为。这个类有一个<code>windowSize</code>成员变量，表示窗口的大小，还有一个<code>sendData</code>成员函数，用于发送数据。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SlidingWindow</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">SlidingWindow</span>(<span class=\"type\">int</span> size) : <span class=\"built_in\">windowSize</span>(size) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">sendData</span><span class=\"params\">(<span class=\"type\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (window.<span class=\"built_in\">size</span>() &lt; windowSize) &#123;</span><br><span class=\"line\">            window.<span class=\"built_in\">push</span>(data);</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">&quot;Data &quot;</span> &lt;&lt; data &lt;&lt; <span class=\"string\">&quot; sent.\\n&quot;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">&quot;Window is full. Data &quot;</span> &lt;&lt; data &lt;&lt; <span class=\"string\">&quot; is waiting.\\n&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">acknowledge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!window.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">&quot;Data &quot;</span> &lt;&lt; window.<span class=\"built_in\">front</span>() &lt;&lt; <span class=\"string\">&quot; acknowledged.\\n&quot;</span>;</span><br><span class=\"line\">            window.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> windowSize;</span><br><span class=\"line\">    std::queue&lt;<span class=\"type\">int</span>&gt; window;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">SlidingWindow <span class=\"title\">sw</span><span class=\"params\">(<span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; ++i) &#123;</span><br><span class=\"line\">        sw.<span class=\"built_in\">sendData</span>(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sw.<span class=\"built_in\">acknowledge</span>();</span><br><span class=\"line\">    sw.<span class=\"built_in\">sendData</span>(<span class=\"number\">6</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在这个例子中，我们首先创建了一个滑动窗口，窗口大小为3。然后，我们尝试发送5个数据。由于窗口大小为3，所以前3个数据可以立即发送，但是第4个和第5个数据需要等待。然后，我们确认了一个数据，这会使窗口向前滑动一位，从而为新的数据腾出空间。最后，我们发送了第6个数据。</p>\n<p>这个例子虽然简单，但是展示了滑动窗口的基本工作原理：当窗口满时，新的数据需要等待；当有数据被确认时，窗口会向前滑动，为新的数据腾出空间。在实际的网络编程中，滑动窗口的工作原理也是类似的，只是会涉及到更多的细节和复杂性。希望这个例子能帮助你理解滑动窗口是如何工作的。</p>\n","text":"滑动窗口控制流量滑动窗口是什么，用c++写一个例子说明滑动窗口是一种常用的算法技术，它可以在数组或列表中查找子数组或子列表，以解决各种问题。滑动窗口通常从数组的...","permalink":"/post/滑动窗口控制流量","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"C++","slug":"C","count":5,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8E%A7%E5%88%B6%E6%B5%81%E9%87%8F\"><span class=\"toc-text\">滑动窗口控制流量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E7%94%A8c-%E5%86%99%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">滑动窗口是什么，用c++写一个例子说明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%AF%9D%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8E%A7%E5%88%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B9%8B%E9%97%B4%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">如何使用话动窗口控制客户端与服务端之间的流量控制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8c-%E5%86%99%E4%B8%80%E4%B8%AA%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9D%A5%E6%8E%A7%E5%88%B6%E6%B5%81%E9%87%8F%E7%9A%84%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">用c++写一个滑动窗口来控制流量的例子</span></a></li></ol></li></ol>","author":{"name":"暗使开开","slug":"blog-author","avatar":"\\favicon.ico","link":"/","description":"<p>即使是虚拟的也会开心</p>唯有终夜长开眼，报以平生未展眉","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/344723412"},"qq":{"icon":"/svg/qq.svg","link":"https://qm.qq.com/q/MXqKNejl6g"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"要唱就唱","uid":"42a37c99055000ceaa62b8305cac08db","slug":"唱歌","date":"2024-07-29T16:00:00.000Z","updated":"2024-08-04T10:48:34.359Z","comments":true,"path":"api/articles/唱歌.json","keywords":null,"cover":null,"text":"","permalink":"/post/唱歌","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[{"name":"爱好","slug":"爱好","count":1,"path":"api/categories/爱好.json"}],"tags":[],"author":{"name":"暗使开开","slug":"blog-author","avatar":"\\favicon.ico","link":"/","description":"<p>即使是虚拟的也会开心</p>唯有终夜长开眼，报以平生未展眉","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/344723412"},"qq":{"icon":"/svg/qq.svg","link":"https://qm.qq.com/q/MXqKNejl6g"}}}}},"next_post":{"title":"混合开发","uid":"e5520f8a714d72e3ef4686fea1f51fcb","slug":"混合开发","date":"2024-07-29T16:00:00.000Z","updated":"2024-08-05T04:33:14.883Z","comments":true,"path":"api/articles/混合开发.json","keywords":null,"cover":null,"text":"混合开发个人观点：混合开发推荐Flutter、Electron 和Qt Electron背景：Electron 由 GitHub 开发，因其使用 HTML、CS...","permalink":"/post/混合开发","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"个人见解","slug":"个人见解","count":1,"path":"api/categories/个人见解.json"}],"tags":[],"author":{"name":"暗使开开","slug":"blog-author","avatar":"\\favicon.ico","link":"/","description":"<p>即使是虚拟的也会开心</p>唯有终夜长开眼，报以平生未展眉","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/344723412"},"qq":{"icon":"/svg/qq.svg","link":"https://qm.qq.com/q/MXqKNejl6g"}}}}}}