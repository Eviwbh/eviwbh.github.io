{"title":"C++开发","uid":"b7dd937fd88b1c61f67f5db2e381adf2","slug":"cpp开发","date":"2022-07-29T16:00:00.000Z","updated":"2024-08-04T10:26:32.703Z","comments":true,"path":"api/articles/cpp开发.json","keywords":null,"cover":null,"content":"<h1 id=\"C-开发\"><a href=\"#C-开发\" class=\"headerlink\" title=\"C++开发\"></a>C++开发</h1><h2 id=\"public框架\"><a href=\"#public框架\" class=\"headerlink\" title=\"public框架:\"></a>public框架:</h2><h4 id=\"心跳程序-框架中的心跳类\"><a href=\"#心跳程序-框架中的心跳类\" class=\"headerlink\" title=\"心跳程序-框架中的心跳类\"></a>心跳程序-框架中的心跳类</h4><h5 id=\"public-h\"><a href=\"#public-h\" class=\"headerlink\" title=\"_public.h\"></a>_public.h</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 信号量。</span><br><span class=\"line\">class CSEM</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">  union semun  // 用于信号量操作的共同体。</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    int val;</span><br><span class=\"line\">    struct semid_ds *buf;</span><br><span class=\"line\">    unsigned short  *arry;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  int   m_semid;         // 信号量描述符。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 如果把sem_flg设置为SEM_UNDO，操作系统将跟踪进程对信号量的修改情况，</span><br><span class=\"line\">  // 在全部修改过信号量的进程（正常或异常）终止后，操作系统将把信号量恢</span><br><span class=\"line\">  // 复为初始值（就像撤消了全部进程对信号的操作）。</span><br><span class=\"line\">  // 如果信号量用于表示可用资源的数量（不变的），设置为SEM_UNDO更合适。</span><br><span class=\"line\">  // 如果信号量用于生产消费者模型，设置为0更合适。</span><br><span class=\"line\">  // 注意，网上查到的关于sem_flg的用法基本上是错的，一定要自己动手多测试。</span><br><span class=\"line\">  short m_sem_flg;</span><br><span class=\"line\">public:</span><br><span class=\"line\">  CSEM();</span><br><span class=\"line\">  // 如果信号量已存在，获取信号量；如果信号量不存在，则创建它并初始化为value。</span><br><span class=\"line\">  bool init(key_t key,unsigned short value=1,short sem_flg=SEM_UNDO); </span><br><span class=\"line\">  bool P(short sem_op=-1); // 信号量的P操作。</span><br><span class=\"line\">  bool V(short sem_op=1);  // 信号量的V操作。</span><br><span class=\"line\">  int  value();            // 获取信号量的值，成功返回信号量的值，失败返回-1。</span><br><span class=\"line\">  bool destroy();          // 销毁信号量。</span><br><span class=\"line\"> ~CSEM();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 进程心跳信息的结构体。</span><br><span class=\"line\">struct st_procinfo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int    pid;         // 进程id。</span><br><span class=\"line\">  char   pname[51];   // 进程名称，可以为空。</span><br><span class=\"line\">  int    timeout;     // 超时时间，单位：秒。</span><br><span class=\"line\">  time_t atime;       // 最后一次心跳的时间，用整数表示。</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">#define MAXNUMP     1000    // 最大的进程数量。</span><br><span class=\"line\">#define SHMKEYP   0x5095    // 共享内存的key。</span><br><span class=\"line\">#define SEMKEYP   0x5095    // 信号量的key。</span><br><span class=\"line\"></span><br><span class=\"line\">// 查看共享内存：  ipcs -m</span><br><span class=\"line\">// 删除共享内存：  ipcrm -m shmid</span><br><span class=\"line\">// 查看信号量：    ipcs -s</span><br><span class=\"line\">// 删除信号量：    ipcrm sem semid</span><br><span class=\"line\"></span><br><span class=\"line\">// 进程心跳操作类。</span><br><span class=\"line\">class CPActive</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">  CSEM m_sem;                 // 用于给共享内存加锁的信号量id。</span><br><span class=\"line\">  int  m_shmid;               // 共享内存的id。</span><br><span class=\"line\">  int  m_pos;                 // 当前进程在共享内存进程组中的位置。</span><br><span class=\"line\">  st_procinfo *m_shm;         // 指向共享内存的地址空间。</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">  CPActive();  // 初始化成员变量。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把当前进程的心跳信息加入共享内存进程组中。</span><br><span class=\"line\">  bool AddPInfo(const int timeout,const char *pname=0,CLogFile *logfile=0);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 更新共享内存进程组中当前进程的心跳时间。</span><br><span class=\"line\">  bool UptATime();</span><br><span class=\"line\"></span><br><span class=\"line\">  ~CPActive();  // 从共享内存中删除当前进程的心跳记录。</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"public-cpp\"><a href=\"#public-cpp\" class=\"headerlink\" title=\"_public.cpp\"></a>_public.cpp</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CSEM::CSEM()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  m_semid=-1;</span><br><span class=\"line\">  m_sem_flg=SEM_UNDO;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果信号量已存在，获取信号量；如果信号量不存在，则创建它并初始化为value。</span><br><span class=\"line\">bool CSEM::init(key_t key,unsigned short value,short sem_flg)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (m_semid!=-1) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  m_sem_flg=sem_flg;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 信号量的初始化不能直接用semget(key,1,0666|IPC_CREAT)，因为信号量创建后，初始值是0。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 信号量的初始化分三个步骤：</span><br><span class=\"line\">  // 1）获取信号量，如果成功，函数返回。</span><br><span class=\"line\">  // 2）如果失败，则创建信号量。</span><br><span class=\"line\">  // 3) 设置信号量的初始值。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取信号量。</span><br><span class=\"line\">  if ( (m_semid=semget(key,1,0666)) == -1)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 如果信号量不存在，创建它。</span><br><span class=\"line\">    if (errno==2)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 用IPC_EXCL标志确保只有一个进程创建并初始化信号量，其它进程只能获取。</span><br><span class=\"line\">      if ( (m_semid=semget(key,1,0666|IPC_CREAT|IPC_EXCL)) == -1)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        if (errno!=EEXIST)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          perror(&quot;init 1 semget()&quot;); return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if ( (m_semid=semget(key,1,0666)) == -1)</span><br><span class=\"line\">        &#123; perror(&quot;init 2 semget()&quot;); return false; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        return true;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 信号量创建成功后，还需要把它初始化成value。</span><br><span class=\"line\">      union semun sem_union;</span><br><span class=\"line\">      sem_union.val = value;   // 设置信号量的初始值。</span><br><span class=\"line\">      if (semctl(m_semid,0,SETVAL,sem_union) &lt;  0) &#123; perror(&quot;init semctl()&quot;); return false; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123; perror(&quot;init 3 semget()&quot;); return false; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool CSEM::P(short sem_op)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (m_semid==-1) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  struct sembuf sem_b;</span><br><span class=\"line\">  sem_b.sem_num = 0;      // 信号量编号，0代表第一个信号量。</span><br><span class=\"line\">  sem_b.sem_op = sem_op;  // P操作的sem_op必须小于0。</span><br><span class=\"line\">  sem_b.sem_flg = m_sem_flg;   </span><br><span class=\"line\">  if (semop(m_semid,&amp;sem_b,1) == -1) &#123; perror(&quot;p semop()&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool CSEM::V(short sem_op)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (m_semid==-1) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  struct sembuf sem_b;</span><br><span class=\"line\">  sem_b.sem_num = 0;      // 信号量编号，0代表第一个信号量。</span><br><span class=\"line\">  sem_b.sem_op = sem_op;  // V操作的sem_op必须大于0。</span><br><span class=\"line\">  sem_b.sem_flg = m_sem_flg;</span><br><span class=\"line\">  if (semop(m_semid,&amp;sem_b,1) == -1) &#123; perror(&quot;V semop()&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 获取信号量的值，成功返回信号量的值，失败返回-1。</span><br><span class=\"line\">int CSEM::value()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return semctl(m_semid,0,GETVAL);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool CSEM::destroy()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (m_semid==-1) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (semctl(m_semid,0,IPC_RMID) == -1) &#123; perror(&quot;destroy semctl()&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CSEM::~CSEM()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CPActive::CPActive()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  m_shmid=0;</span><br><span class=\"line\">  m_pos=-1;</span><br><span class=\"line\">  m_shm=0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把当前进程的心跳信息加入共享内存进程组中。</span><br><span class=\"line\">bool CPActive::AddPInfo(const int timeout,const char *pname,CLogFile *logfile)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (m_pos!=-1) return true;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (m_sem.init(SEMKEYP) == false)  // 初始化信号量。</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    if (logfile!=0) logfile-&gt;Write(&quot;创建/获取信号量(%x)失败。\\n&quot;,SEMKEYP); </span><br><span class=\"line\">    else printf(&quot;创建/获取信号量(%x)失败。\\n&quot;,SEMKEYP);</span><br><span class=\"line\"></span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 创建/获取共享内存，键值为SHMKEYP，大小为MAXNUMP个st_procinfo结构体的大小。</span><br><span class=\"line\">  if ( (m_shmid = shmget((key_t)SHMKEYP, MAXNUMP*sizeof(struct st_procinfo), 0666|IPC_CREAT)) == -1)</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    if (logfile!=0) logfile-&gt;Write(&quot;创建/获取共享内存(%x)失败。\\n&quot;,SHMKEYP); </span><br><span class=\"line\">    else printf(&quot;创建/获取共享内存(%x)失败。\\n&quot;,SHMKEYP);</span><br><span class=\"line\"></span><br><span class=\"line\">    return false; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将共享内存连接到当前进程的地址空间。</span><br><span class=\"line\">  m_shm=(struct st_procinfo *)shmat(m_shmid, 0, 0);</span><br><span class=\"line\">  </span><br><span class=\"line\">  struct st_procinfo stprocinfo;    // 当前进程心跳信息的结构体。</span><br><span class=\"line\">  memset(&amp;stprocinfo,0,sizeof(stprocinfo));</span><br><span class=\"line\"></span><br><span class=\"line\">  stprocinfo.pid=getpid();            // 当前进程号。</span><br><span class=\"line\">  stprocinfo.timeout=timeout;         // 超时时间。</span><br><span class=\"line\">  stprocinfo.atime=time(0);           // 当前时间。</span><br><span class=\"line\">  STRNCPY(stprocinfo.pname,sizeof(stprocinfo.pname),pname,50); // 进程名。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 进程id是循环使用的，如果曾经有一个进程异常退出，没有清理自己的心跳信息，</span><br><span class=\"line\">  // 它的进程信息将残留在共享内存中，不巧的是，当前进程重用了上述进程的id，</span><br><span class=\"line\">  // 这样就会在共享内存中存在两个进程id相同的记录，守护进程检查到残留进程的</span><br><span class=\"line\">  // 心跳时，会向进程id发送退出信号，这个信号将误杀当前进程。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 如果共享内存中存在当前进程编号，一定是其它进程残留的数据，当前进程就重用该位置。</span><br><span class=\"line\">  for (int ii=0;ii&lt;MAXNUMP;ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    if ( (m_shm+ii)-&gt;pid==stprocinfo.pid ) &#123; m_pos=ii; break; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  m_sem.P();  // 给共享内存上锁。</span><br><span class=\"line\"></span><br><span class=\"line\">  if (m_pos==-1)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 如果m_pos==-1，共享内存的进程组中不存在当前进程编号，找一个空位置。</span><br><span class=\"line\">    for (int ii=0;ii&lt;MAXNUMP;ii++)</span><br><span class=\"line\">      if ( (m_shm+ii)-&gt;pid==0 ) &#123; m_pos=ii; break; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (m_pos==-1) </span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    if (logfile!=0) logfile-&gt;Write(&quot;共享内存空间已用完。\\n&quot;);</span><br><span class=\"line\">    else printf(&quot;共享内存空间已用完。\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    m_sem.V();  // 解锁。</span><br><span class=\"line\"></span><br><span class=\"line\">    return false; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把当前进程的心跳信息存入共享内存的进程组中。</span><br><span class=\"line\">  memcpy(m_shm+m_pos,&amp;stprocinfo,sizeof(struct st_procinfo)); </span><br><span class=\"line\"></span><br><span class=\"line\">  m_sem.V();   // 解锁。</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 更新共享内存进程组中当前进程的心跳时间。</span><br><span class=\"line\">bool CPActive::UptATime()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (m_pos==-1) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  (m_shm+m_pos)-&gt;atime=time(0);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CPActive::~CPActive()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 把当前进程从共享内存的进程组中移去。</span><br><span class=\"line\">  if (m_pos!=-1) memset(m_shm+m_pos,0,sizeof(struct st_procinfo));</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把共享内存从当前进程中分离。</span><br><span class=\"line\">  if (m_shm!=0) shmdt(m_shm);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"调度程序\"><a href=\"#调度程序\" class=\"headerlink\" title=\"调度程序\"></a>调度程序</h4><p>procctl.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &lt;sys/types.h&gt;</span><br><span class=\"line\">#include &lt;sys/wait.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (argc&lt;3)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;Using:./procctl timetvl program argv ...\\n&quot;);</span><br><span class=\"line\">    printf(&quot;Example:/project/tools1/bin/procctl 5 /usr/bin/tar zcvf /tmp/tmp.tgz /usr/include\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;本程序是服务程序的调度程序，周期性启动服务程序或shell脚本。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;timetvl 运行周期，单位：秒。被调度的程序运行结束后，在timetvl秒后会被procctl重新启动。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;program 被调度的程序名，必须使用全路径。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;argvs   被调度的程序的参数。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;注意，本程序不会被kill杀死，但可以用kill -9强行杀死。\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭信号和IO，本程序不希望被打扰。</span><br><span class=\"line\">  for (int ii=0;ii&lt;64;ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    signal(ii,SIG_IGN); close(ii);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 生成子进程，父进程退出，让程序运行在后台，由系统1号进程托管。</span><br><span class=\"line\">  if (fork()!=0) exit(0);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 启用SIGCHLD信号，让父进程可以wait子进程退出的状态。</span><br><span class=\"line\">  signal(SIGCHLD,SIG_DFL);</span><br><span class=\"line\"></span><br><span class=\"line\">  char *pargv[argc];</span><br><span class=\"line\">  for (int ii=2;ii&lt;argc;ii++)</span><br><span class=\"line\">    pargv[ii-2]=argv[ii];</span><br><span class=\"line\"></span><br><span class=\"line\">  pargv[argc-2]=NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    if (fork()==0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      execv(argv[2],pargv);</span><br><span class=\"line\">      exit(0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      int status;</span><br><span class=\"line\">      wait(&amp;status);</span><br><span class=\"line\">      sleep(atoi(argv[1]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"编译文件\"><a href=\"#编译文件\" class=\"headerlink\" title=\"编译文件\"></a>编译文件</h5><p>makefile</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">all: procctl </span><br><span class=\"line\"></span><br><span class=\"line\">procctl:procctl.cpp</span><br><span class=\"line\">\tg++ -o procctl procctl.cpp</span><br><span class=\"line\">\tcp procctl ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -f procctl </span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"守护进程程序\"><a href=\"#守护进程程序\" class=\"headerlink\" title=\"守护进程程序\"></a>守护进程程序</h4><p>checkproc.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序运行的日志。</span><br><span class=\"line\">CLogFile logfile;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 程序的帮助。</span><br><span class=\"line\">  if (argc != 2)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;\\n&quot;);</span><br><span class=\"line\">    printf(&quot;Using:./checkproc logfilename\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;Example:/project/tools1/bin/procctl 10 /project/tools1/bin/checkproc /tmp/log/checkproc.log\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;本程序用于检查后台服务程序是否超时，如果已超时，就终止它。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;注意：\\n&quot;);</span><br><span class=\"line\">    printf(&quot;  1）本程序由procctl启动，运行周期建议为10秒。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;  2）为了避免被普通用户误杀，本程序应该用root用户启动。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;  3）如果要停止本程序，只能用killall -9 终止。\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 忽略全部的信号和IO，不希望程序被干扰。</span><br><span class=\"line\">  CloseIOAndSignal(true);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 打开日志文件。</span><br><span class=\"line\">  if (logfile.Open(argv[1],&quot;a+&quot;)==false)</span><br><span class=\"line\">  &#123; printf(&quot;logfile.Open(%s) failed.\\n&quot;,argv[1]); return -1; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  int shmid=0;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 创建/获取共享内存，键值为SHMKEYP，大小为MAXNUMP个st_procinfo结构体的大小。</span><br><span class=\"line\">  if ( (shmid = shmget((key_t)SHMKEYP, MAXNUMP*sizeof(struct st_procinfo), 0666|IPC_CREAT)) == -1)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;创建/获取共享内存(%x)失败。\\n&quot;,SHMKEYP); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将共享内存连接到当前进程的地址空间。</span><br><span class=\"line\">  struct st_procinfo *shm=(struct st_procinfo *)shmat(shmid, 0, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历共享内存中全部的记录。</span><br><span class=\"line\">  for (int ii=0;ii&lt;MAXNUMP;ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 如果记录的pid==0，表示空记录，continue;</span><br><span class=\"line\">    if (shm[ii].pid==0) continue;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果记录的pid!=0，表示是服务程序的心跳记录。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 程序稳定运行后，以下两行代码可以注释掉。</span><br><span class=\"line\">    //logfile.Write(&quot;ii=%d,pid=%d,pname=%s,timeout=%d,atime=%d\\n&quot;,\\</span><br><span class=\"line\">    //               ii,shm[ii].pid,shm[ii].pname,shm[ii].timeout,shm[ii].atime);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 向进程发送信号0，判断它是否还存在，如果不存在，从共享内存中删除该记录，continue;</span><br><span class=\"line\">    int iret=kill(shm[ii].pid,0);</span><br><span class=\"line\">    if (iret==-1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.Write(&quot;进程pid=%d(%s)已经不存在。\\n&quot;,(shm+ii)-&gt;pid,(shm+ii)-&gt;pname);</span><br><span class=\"line\">      memset(shm+ii,0,sizeof(struct st_procinfo)); // 从共享内存中删除该记录。</span><br><span class=\"line\">      continue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    time_t now=time(0);   // 取当前时间。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果进程未超时，continue;</span><br><span class=\"line\">    if (now-shm[ii].atime&lt;shm[ii].timeout) continue;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果已超时。</span><br><span class=\"line\">    logfile.Write(&quot;进程pid=%d(%s)已经超时。\\n&quot;,(shm+ii)-&gt;pid,(shm+ii)-&gt;pname);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 发送信号15，尝试正常终止进程。</span><br><span class=\"line\">    kill(shm[ii].pid,15);     </span><br><span class=\"line\"></span><br><span class=\"line\">    // 每隔1秒判断一次进程是否存在，累计5秒，一般来说，5秒的时间足够让进程退出。</span><br><span class=\"line\">    for (int jj=0;jj&lt;5;jj++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      sleep(1);</span><br><span class=\"line\">      iret=kill(shm[ii].pid,0);     // 向进程发送信号0，判断它是否还存在。</span><br><span class=\"line\">      if (iret==-1) break;     // 进程已退出。</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果进程仍存在，就发送信号9，强制终止它。</span><br><span class=\"line\">    if (iret==-1)</span><br><span class=\"line\">      logfile.Write(&quot;进程pid=%d(%s)已经正常终止。\\n&quot;,(shm+ii)-&gt;pid,(shm+ii)-&gt;pname);</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      kill(shm[ii].pid,9);  // 如果进程仍存在，就发送信号9，强制终止它。</span><br><span class=\"line\">      logfile.Write(&quot;进程pid=%d(%s)已经强制终止。\\n&quot;,(shm+ii)-&gt;pid,(shm+ii)-&gt;pname);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 从共享内存中删除已超时进程的心跳记录。</span><br><span class=\"line\">    memset(shm+ii,0,sizeof(struct st_procinfo)); // 从共享内存中删除该记录。</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把共享内存从当前进程中分离。</span><br><span class=\"line\">  shmdt(shm);</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"编译文件-1\"><a href=\"#编译文件-1\" class=\"headerlink\" title=\"编译文件\"></a>编译文件</h5><p>makefile</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 开发框架头文件路径。</span><br><span class=\"line\">PUBINCL = -I/project/public</span><br><span class=\"line\"></span><br><span class=\"line\"># 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。</span><br><span class=\"line\">PUBCPP = /project/public/_public.cpp</span><br><span class=\"line\"></span><br><span class=\"line\"># 编译参数。</span><br><span class=\"line\">CFLAGS = -g</span><br><span class=\"line\"></span><br><span class=\"line\">all: checkproc </span><br><span class=\"line\"></span><br><span class=\"line\">checkproc:checkproc.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o checkproc checkproc.cpp $(PUBINCL) $(PUBCPP) -lm -lc</span><br><span class=\"line\">\tcp checkproc ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -f checkproc</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"压缩文件程序\"><a href=\"#压缩文件程序\" class=\"headerlink\" title=\"压缩文件程序\"></a>压缩文件程序</h4><p>gzipfiles.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序退出和信号2、15的处理函数。</span><br><span class=\"line\">void EXIT(int sig);</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 程序的帮助。</span><br><span class=\"line\">  if (argc != 4)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;\\n&quot;);</span><br><span class=\"line\">    printf(&quot;Using:/project/tools1/bin/gzipfiles pathname matchstr timeout\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;Example:/project/tools1/bin/gzipfiles /log/idc \\&quot;*.log.20*\\&quot; 0.02\\n&quot;);</span><br><span class=\"line\">    printf(&quot;        /project/tools1/bin/gzipfiles /tmp/idc/surfdata \\&quot;*.xml,*.json\\&quot; 0.01\\n&quot;);</span><br><span class=\"line\">    printf(&quot;        /project/tools1/bin/procctl 300 /project/tools1/bin/gzipfiles /log/idc \\&quot;*.log.20*\\&quot; 0.02\\n&quot;);</span><br><span class=\"line\">    printf(&quot;        /project/tools1/bin/procctl 300 /project/tools1/bin/gzipfiles /tmp/idc/surfdata \\&quot;*.xml,*.json\\&quot; 0.01\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;这是一个工具程序，用于压缩历史的数据文件或日志文件。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;本程序把pathname目录及子目录中timeout天之前的匹配matchstr文件全部压缩，timeout可以是小数。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;本程序不写日志文件，也不会在控制台输出任何信息。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;本程序调用/usr/bin/gzip命令压缩文件。\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭全部的信号和输入输出。</span><br><span class=\"line\">  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。</span><br><span class=\"line\">  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。</span><br><span class=\"line\">  CloseIOAndSignal(true); signal(SIGINT,EXIT);  signal(SIGTERM,EXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取文件超时的时间点。</span><br><span class=\"line\">  char strTimeOut[21];</span><br><span class=\"line\">  LocalTime(strTimeOut,&quot;yyyy-mm-dd hh24:mi:ss&quot;,0-(int)(atof(argv[3])*24*60*60));</span><br><span class=\"line\"></span><br><span class=\"line\">  CDir Dir;</span><br><span class=\"line\">  // 打开目录，CDir.OpenDir()</span><br><span class=\"line\">  if (Dir.OpenDir(argv[1],argv[2],10000,true)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;Dir.OpenDir(%s) failed.\\n&quot;,argv[1]); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  char strCmd[1024]; // 存放gzip压缩文件的命令。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历目录中的文件名。</span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 得到一个文件的信息，CDir.ReadDir()</span><br><span class=\"line\">    if (Dir.ReadDir()==false) break;</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 与超时的时间点比较，如果更早，就需要压缩</span><br><span class=\"line\">    if ( (strcmp(Dir.m_ModifyTime,strTimeOut)&lt;0) &amp;&amp; (MatchStr(Dir.m_FileName,&quot;*.gz&quot;)==false) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 压缩文件，调用操作系统的gzip命令。</span><br><span class=\"line\">      SNPRINTF(strCmd,sizeof(strCmd),1000,&quot;/usr/bin/gzip -f %s 1&gt;/dev/null 2&gt;/dev/null&quot;,Dir.m_FullFileName);</span><br><span class=\"line\">      if (system(strCmd)==0) </span><br><span class=\"line\">        printf(&quot;gzip %s ok.\\n&quot;,Dir.m_FullFileName);</span><br><span class=\"line\">      else</span><br><span class=\"line\">        printf(&quot;gzip %s failed.\\n&quot;,Dir.m_FullFileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EXIT(int sig)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;程序退出，sig=%d\\n\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"编译文件-2\"><a href=\"#编译文件-2\" class=\"headerlink\" title=\"编译文件\"></a>编译文件</h5><p>makefile</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 开发框架头文件路径。</span><br><span class=\"line\">PUBINCL = -I/project/public</span><br><span class=\"line\"></span><br><span class=\"line\"># 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。</span><br><span class=\"line\">PUBCPP = /project/public/_public.cpp</span><br><span class=\"line\"></span><br><span class=\"line\"># 编译参数。</span><br><span class=\"line\">CFLAGS = -g</span><br><span class=\"line\"></span><br><span class=\"line\">all: gzipfiles</span><br><span class=\"line\"></span><br><span class=\"line\">gzipfiles:gzipfiles.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o gzipfiles gzipfiles.cpp $(PUBINCL) $(PUBCPP) -lm -lc</span><br><span class=\"line\">\tcp gzipfiles ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -f gzipfiles</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"清理文件程序\"><a href=\"#清理文件程序\" class=\"headerlink\" title=\"清理文件程序\"></a>清理文件程序</h4><p>deletefiles.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序退出和信号2、15的处理函数。</span><br><span class=\"line\">void EXIT(int sig);</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 程序的帮助。</span><br><span class=\"line\">  if (argc != 4)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;\\n&quot;);</span><br><span class=\"line\">    printf(&quot;Using:/project/tools1/bin/deletefiles pathname matchstr timeout\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;Example:/project/tools1/bin/deletefiles /log/idc \\&quot;*.log.20*\\&quot; 0.02\\n&quot;);</span><br><span class=\"line\">    printf(&quot;        /project/tools1/bin/deletefiles /tmp/idc/surfdata \\&quot;*.xml,*.json\\&quot; 0.01\\n&quot;);</span><br><span class=\"line\">    printf(&quot;        /project/tools1/bin/procctl 300 /project/tools1/bin/deletefiles /log/idc \\&quot;*.log.20*\\&quot; 0.02\\n&quot;);</span><br><span class=\"line\">    printf(&quot;        /project/tools1/bin/procctl 300 /project/tools1/bin/deletefiles /tmp/idc/surfdata \\&quot;*.xml,*.json\\&quot; 0.01\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;这是一个工具程序，用于删除历史的数据文件或日志文件。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;本程序把pathname目录及子目录中timeout天之前的匹配matchstr文件全部删除，timeout可以是小数。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;本程序不写日志文件，也不会在控制台输出任何信息。\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭全部的信号和输入输出。</span><br><span class=\"line\">  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。</span><br><span class=\"line\">  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。</span><br><span class=\"line\">  // CloseIOAndSignal(true); </span><br><span class=\"line\">  signal(SIGINT,EXIT);  signal(SIGTERM,EXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取文件超时的时间点。</span><br><span class=\"line\">  char strTimeOut[21];</span><br><span class=\"line\">  LocalTime(strTimeOut,&quot;yyyy-mm-dd hh24:mi:ss&quot;,0-(int)(atof(argv[3])*24*60*60));</span><br><span class=\"line\"></span><br><span class=\"line\">  CDir Dir;</span><br><span class=\"line\">  // 打开目录，CDir.OpenDir()</span><br><span class=\"line\">  if (Dir.OpenDir(argv[1],argv[2],10000,true)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;Dir.OpenDir(%s) failed.\\n&quot;,argv[1]); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历目录中的文件名。</span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 得到一个文件的信息，CDir.ReadDir()</span><br><span class=\"line\">    if (Dir.ReadDir()==false) break;</span><br><span class=\"line\">printf(&quot;=%s=\\n&quot;,Dir.m_FullFileName);  </span><br><span class=\"line\">    // 与超时的时间点比较，如果更早，就需要删除。</span><br><span class=\"line\">    if (strcmp(Dir.m_ModifyTime,strTimeOut)&lt;0) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      if (REMOVE(Dir.m_FullFileName)==0) </span><br><span class=\"line\">        printf(&quot;REMOVE %s ok.\\n&quot;,Dir.m_FullFileName);</span><br><span class=\"line\">      else</span><br><span class=\"line\">        printf(&quot;REMOVE %s failed.\\n&quot;,Dir.m_FullFileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EXIT(int sig)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;程序退出，sig=%d\\n\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"编译文件-3\"><a href=\"#编译文件-3\" class=\"headerlink\" title=\"编译文件\"></a>编译文件</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 开发框架头文件路径。</span><br><span class=\"line\">PUBINCL = -I/project/public</span><br><span class=\"line\"></span><br><span class=\"line\"># 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。</span><br><span class=\"line\">PUBCPP = /project/public/_public.cpp</span><br><span class=\"line\"></span><br><span class=\"line\"># 编译参数。</span><br><span class=\"line\">CFLAGS = -g</span><br><span class=\"line\"></span><br><span class=\"line\">all: deletefiles</span><br><span class=\"line\"></span><br><span class=\"line\">deletefiles:deletefiles.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o deletefiles deletefiles.cpp $(PUBINCL) $(PUBCPP) -lm -lc</span><br><span class=\"line\">\tcp deletefiles ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -f deletefiles</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"模拟生产测试数据文件\"><a href=\"#模拟生产测试数据文件\" class=\"headerlink\" title=\"模拟生产测试数据文件\"></a>模拟生产测试数据文件</h4><p>crtsurfdata.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  程序名：crtsurfdata.cpp  本程序用于生成全国气象站点观测的分钟数据。</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">CPActive PActive;   // 进程心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">// 全国气象站点参数结构体。</span><br><span class=\"line\">struct st_stcode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char provname[31]; // 省</span><br><span class=\"line\">  char obtid[11];    // 站号</span><br><span class=\"line\">  char obtname[31];  // 站名</span><br><span class=\"line\">  double lat;        // 纬度</span><br><span class=\"line\">  double lon;        // 经度</span><br><span class=\"line\">  double height;     // 海拔高度</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;struct st_stcode&gt; vstcode; // 存放全国气象站点参数的容器。</span><br><span class=\"line\"></span><br><span class=\"line\">// 把站点参数文件中加载到vstcode容器中。</span><br><span class=\"line\">bool LoadSTCode(const char *inifile);</span><br><span class=\"line\"></span><br><span class=\"line\">// 全国气象站点分钟观测数据结构</span><br><span class=\"line\">struct st_surfdata</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char obtid[11];      // 站点代码。</span><br><span class=\"line\">  char ddatetime[21];  // 数据时间：格式yyyymmddhh24miss</span><br><span class=\"line\">  int  t;              // 气温：单位，0.1摄氏度。</span><br><span class=\"line\">  int  p;              // 气压：0.1百帕。</span><br><span class=\"line\">  int  u;              // 相对湿度，0-100之间的值。</span><br><span class=\"line\">  int  wd;             // 风向，0-360之间的值。</span><br><span class=\"line\">  int  wf;             // 风速：单位0.1m/s</span><br><span class=\"line\">  int  r;              // 降雨量：0.1mm。</span><br><span class=\"line\">  int  vis;            // 能见度：0.1米。</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;struct st_surfdata&gt; vsurfdata;  // 存放全国气象站点分钟观测数据的容器</span><br><span class=\"line\"></span><br><span class=\"line\">char strddatetime[21]; // 观测数据的时间。</span><br><span class=\"line\"></span><br><span class=\"line\">// 模拟生成全国气象站点分钟观测数据，存放在vsurfdata容器中。</span><br><span class=\"line\">void CrtSurfData();</span><br><span class=\"line\"></span><br><span class=\"line\">CFile File;  // 文件操作对象。</span><br><span class=\"line\"></span><br><span class=\"line\">// 把容器vsurfdata中的全国气象站点分钟观测数据写入文件。</span><br><span class=\"line\">bool CrtSurfFile(const char *outpath,const char *datafmt);</span><br><span class=\"line\"></span><br><span class=\"line\">CLogFile logfile;    // 日志类。</span><br><span class=\"line\"></span><br><span class=\"line\">void EXIT(int sig);  // 程序退出和信号2、15的处理函数。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if ( (argc!=5) &amp;&amp; (argc!=6) )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 如果参数非法，给出帮助文档。</span><br><span class=\"line\">    printf(&quot;Using:./crtsurfdata inifile outpath logfile datafmt [datetime]\\n&quot;);</span><br><span class=\"line\">    printf(&quot;Example:/project/idc1/bin/crtsurfdata /project/idc1/ini/stcode.ini /tmp/idc/surfdata /log/idc/crtsurfdata.log xml,json,csv\\n&quot;);</span><br><span class=\"line\">    printf(&quot;        /project/idc1/bin/crtsurfdata /project/idc1/ini/stcode.ini /tmp/idc/surfdata /log/idc/crtsurfdata.log xml,json,csv 20210710123000\\n&quot;);</span><br><span class=\"line\">    printf(&quot;        /project/tools1/bin/procctl 60 /project/idc1/bin/crtsurfdata /project/idc1/ini/stcode.ini /tmp/idc/surfdata /log/idc/crtsurfdata.log xml,json,csv\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;inifile  全国气象站点参数文件名。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;outpath  全国气象站点数据文件存放的目录。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;logfile  本程序运行的日志文件名。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;datafmt  生成数据文件的格式，支持xml、json和csv三种格式，中间用逗号分隔。\\n&quot;);</span><br><span class=\"line\">    printf(&quot;datetime 这是一个可选参数，表示生成指定时间的数据和文件。\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭全部的信号和输入输出。</span><br><span class=\"line\">  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。</span><br><span class=\"line\">  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。</span><br><span class=\"line\">  CloseIOAndSignal(true); signal(SIGINT,EXIT);  signal(SIGTERM,EXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 打开程序的日志文件。</span><br><span class=\"line\">  if (logfile.Open(argv[3],&quot;a+&quot;,false)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;logfile.Open(%s) failed.\\n&quot;,argv[3]); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  logfile.Write(&quot;crtsurfdata 开始运行。\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.AddPInfo(20,&quot;crtsurfdata&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把站点参数文件中加载到vstcode容器中。 </span><br><span class=\"line\">  if (LoadSTCode(argv[1])==false) return -1;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取当前时间，当作观测时间。</span><br><span class=\"line\">  memset(strddatetime,0,sizeof(strddatetime));</span><br><span class=\"line\">  if (argc==5)</span><br><span class=\"line\">    LocalTime(strddatetime,&quot;yyyymmddhh24miss&quot;);</span><br><span class=\"line\">  else</span><br><span class=\"line\">    STRCPY(strddatetime,sizeof(strddatetime),argv[5]);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 模拟生成全国气象站点分钟观测数据，存放在vsurfdata容器中。</span><br><span class=\"line\">  CrtSurfData();</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把容器vsurfdata中的全国气象站点分钟观测数据写入文件。</span><br><span class=\"line\">  if (strstr(argv[4],&quot;xml&quot;)!=0) CrtSurfFile(argv[2],&quot;xml&quot;);</span><br><span class=\"line\">  if (strstr(argv[4],&quot;json&quot;)!=0) CrtSurfFile(argv[2],&quot;json&quot;);</span><br><span class=\"line\">  if (strstr(argv[4],&quot;csv&quot;)!=0) CrtSurfFile(argv[2],&quot;csv&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  logfile.Write(&quot;crtsurfdata 运行结束。\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把站点参数文件中加载到vstcode容器中。 </span><br><span class=\"line\">bool LoadSTCode(const char *inifile)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 打开站点参数文件。</span><br><span class=\"line\">  if (File.Open(inifile,&quot;r&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;File.Open(%s) failed.\\n&quot;,inifile); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  char strBuffer[301];</span><br><span class=\"line\"></span><br><span class=\"line\">  CCmdStr CmdStr;</span><br><span class=\"line\"></span><br><span class=\"line\">  struct st_stcode stcode;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 从站点参数文件中读取一行，如果已读取完，跳出循环。</span><br><span class=\"line\">    if (File.Fgets(strBuffer,300,true)==false) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把读取到的一行拆分。</span><br><span class=\"line\">    CmdStr.SplitToCmd(strBuffer,&quot;,&quot;,true);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (CmdStr.CmdCount()!=6) continue;     // 扔掉无效的行。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把站点参数的每个数据项保存到站点参数结构体中。</span><br><span class=\"line\">    memset(&amp;stcode,0,sizeof(struct st_stcode));</span><br><span class=\"line\">    CmdStr.GetValue(0, stcode.provname,30); // 省</span><br><span class=\"line\">    CmdStr.GetValue(1, stcode.obtid,10);    // 站号</span><br><span class=\"line\">    CmdStr.GetValue(2, stcode.obtname,30);  // 站名</span><br><span class=\"line\">    CmdStr.GetValue(3,&amp;stcode.lat);         // 纬度</span><br><span class=\"line\">    CmdStr.GetValue(4,&amp;stcode.lon);         // 经度</span><br><span class=\"line\">    CmdStr.GetValue(5,&amp;stcode.height);      // 海拔高度</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把站点参数结构体放入站点参数容器。</span><br><span class=\"line\">    vstcode.push_back(stcode);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*</span><br><span class=\"line\">  for (int ii=0;ii&lt;vstcode.size();ii++)</span><br><span class=\"line\">    logfile.Write(&quot;provname=%s,obtid=%s,obtname=%s,lat=%.2f,lon=%.2f,height=%.2f\\n&quot;,\\</span><br><span class=\"line\">                   vstcode[ii].provname,vstcode[ii].obtid,vstcode[ii].obtname,vstcode[ii].lat,\\</span><br><span class=\"line\">                   vstcode[ii].lon,vstcode[ii].height);</span><br><span class=\"line\">  */</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 模拟生成全国气象站点分钟观测数据，存放在vsurfdata容器中。</span><br><span class=\"line\">void CrtSurfData()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 播随机数种子。</span><br><span class=\"line\">  srand(time(0));</span><br><span class=\"line\"></span><br><span class=\"line\">  struct st_surfdata stsurfdata;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历气象站点参数的vstcode容器。</span><br><span class=\"line\">  for (int ii=0;ii&lt;vstcode.size();ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stsurfdata,0,sizeof(struct st_surfdata));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 用随机数填充分钟观测数据的结构体。</span><br><span class=\"line\">    strncpy(stsurfdata.obtid,vstcode[ii].obtid,10); // 站点代码。</span><br><span class=\"line\">    strncpy(stsurfdata.ddatetime,strddatetime,14);  // 数据时间：格式yyyymmddhh24miss</span><br><span class=\"line\">    stsurfdata.t=rand()%351;       // 气温：单位，0.1摄氏度</span><br><span class=\"line\">    stsurfdata.p=rand()%265+10000; // 气压：0.1百帕</span><br><span class=\"line\">    stsurfdata.u=rand()%100+1;     // 相对湿度，0-100之间的值。</span><br><span class=\"line\">    stsurfdata.wd=rand()%360;      // 风向，0-360之间的值。</span><br><span class=\"line\">    stsurfdata.wf=rand()%150;      // 风速：单位0.1m/s</span><br><span class=\"line\">    stsurfdata.r=rand()%16;        // 降雨量：0.1mm</span><br><span class=\"line\">    stsurfdata.vis=rand()%5001+100000;  // 能见度：0.1米</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把观测数据的结构体放入vsurfdata容器。</span><br><span class=\"line\">    vsurfdata.push_back(stsurfdata);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把容器vsurfdata中的全国气象站点分钟观测数据写入文件。</span><br><span class=\"line\">bool CrtSurfFile(const char *outpath,const char *datafmt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 拼接生成数据的文件名，例如：/tmp/idc/surfdata/SURF_ZH_20210629092200_2254.csv</span><br><span class=\"line\">  char strFileName[301];</span><br><span class=\"line\">  sprintf(strFileName,&quot;%s/SURF_ZH_%s_%d.%s&quot;,outpath,strddatetime,getpid(),datafmt);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 打开文件。</span><br><span class=\"line\">  if (File.OpenForRename(strFileName,&quot;w&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;File.OpenForRename(%s) failed.\\n&quot;,strFileName); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (strcmp(datafmt,&quot;csv&quot;)==0) File.Fprintf(&quot;站点代码,数据时间,气温,气压,相对湿度,风向,风速,降雨量,能见度\\n&quot;);</span><br><span class=\"line\">  if (strcmp(datafmt,&quot;xml&quot;)==0) File.Fprintf(&quot;&lt;data&gt;\\n&quot;);</span><br><span class=\"line\">  if (strcmp(datafmt,&quot;json&quot;)==0) File.Fprintf(&quot;&#123;\\&quot;data\\&quot;:[\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历存放观测数据的vsurfdata容器。</span><br><span class=\"line\">  for (int ii=0;ii&lt;vsurfdata.size();ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 写入一条记录。</span><br><span class=\"line\">    if (strcmp(datafmt,&quot;csv&quot;)==0)</span><br><span class=\"line\">      File.Fprintf(&quot;%s,%s,%.1f,%.1f,%d,%d,%.1f,%.1f,%.1f\\n&quot;,\\</span><br><span class=\"line\">         vsurfdata[ii].obtid,vsurfdata[ii].ddatetime,vsurfdata[ii].t/10.0,vsurfdata[ii].p/10.0,\\</span><br><span class=\"line\">         vsurfdata[ii].u,vsurfdata[ii].wd,vsurfdata[ii].wf/10.0,vsurfdata[ii].r/10.0,vsurfdata[ii].vis/10.0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (strcmp(datafmt,&quot;xml&quot;)==0)</span><br><span class=\"line\">      File.Fprintf(&quot;&lt;obtid&gt;%s&lt;/obtid&gt;&lt;ddatetime&gt;%s&lt;/ddatetime&gt;&lt;t&gt;%.1f&lt;/t&gt;&lt;p&gt;%.1f&lt;/p&gt;&quot;\\</span><br><span class=\"line\">                   &quot;&lt;u&gt;%d&lt;/u&gt;&lt;wd&gt;%d&lt;/wd&gt;&lt;wf&gt;%.1f&lt;/wf&gt;&lt;r&gt;%.1f&lt;/r&gt;&lt;vis&gt;%.1f&lt;/vis&gt;&lt;endl/&gt;\\n&quot;,\\</span><br><span class=\"line\">         vsurfdata[ii].obtid,vsurfdata[ii].ddatetime,vsurfdata[ii].t/10.0,vsurfdata[ii].p/10.0,\\</span><br><span class=\"line\">         vsurfdata[ii].u,vsurfdata[ii].wd,vsurfdata[ii].wf/10.0,vsurfdata[ii].r/10.0,vsurfdata[ii].vis/10.0);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (strcmp(datafmt,&quot;json&quot;)==0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      File.Fprintf(&quot;&#123;\\&quot;obtid\\&quot;:\\&quot;%s\\&quot;,\\&quot;ddatetime\\&quot;:\\&quot;%s\\&quot;,\\&quot;t\\&quot;:\\&quot;%.1f\\&quot;,\\&quot;p\\&quot;:\\&quot;%.1f\\&quot;,&quot;\\</span><br><span class=\"line\">                   &quot;\\&quot;u\\&quot;:\\&quot;%d\\&quot;,\\&quot;wd\\&quot;:\\&quot;%d\\&quot;,\\&quot;wf\\&quot;:\\&quot;%.1f\\&quot;,\\&quot;r\\&quot;:\\&quot;%.1f\\&quot;,\\&quot;vis\\&quot;:\\&quot;%.1f\\&quot;&#125;&quot;,\\</span><br><span class=\"line\">         vsurfdata[ii].obtid,vsurfdata[ii].ddatetime,vsurfdata[ii].t/10.0,vsurfdata[ii].p/10.0,\\</span><br><span class=\"line\">         vsurfdata[ii].u,vsurfdata[ii].wd,vsurfdata[ii].wf/10.0,vsurfdata[ii].r/10.0,vsurfdata[ii].vis/10.0);</span><br><span class=\"line\"></span><br><span class=\"line\">      if (ii&lt;vsurfdata.size()-1) File.Fprintf(&quot;,\\n&quot;);</span><br><span class=\"line\">      else   File.Fprintf(&quot;\\n&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (strcmp(datafmt,&quot;xml&quot;)==0) File.Fprintf(&quot;&lt;/data&gt;\\n&quot;);</span><br><span class=\"line\">  if (strcmp(datafmt,&quot;json&quot;)==0) File.Fprintf(&quot;]&#125;\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭文件。</span><br><span class=\"line\">  File.CloseAndRename();</span><br><span class=\"line\"></span><br><span class=\"line\">  UTime(strFileName,strddatetime);  // 修改文件的时间属性。</span><br><span class=\"line\"></span><br><span class=\"line\">  logfile.Write(&quot;生成数据文件%s成功，数据时间%s，记录数%d。\\n&quot;,strFileName,strddatetime,vsurfdata.size());</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序退出和信号2、15的处理函数。</span><br><span class=\"line\">void EXIT(int sig)  </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  logfile.Write(&quot;程序退出，sig=%d\\n\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"编译文件-4\"><a href=\"#编译文件-4\" class=\"headerlink\" title=\"编译文件\"></a>编译文件</h5><p>makfile</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 开发框架头文件路径。</span><br><span class=\"line\">PUBINCL = -I/project/public</span><br><span class=\"line\"></span><br><span class=\"line\"># 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。</span><br><span class=\"line\">PUBCPP = /project/public/_public.cpp</span><br><span class=\"line\"></span><br><span class=\"line\"># 编译参数。</span><br><span class=\"line\">CFLAGS = -g </span><br><span class=\"line\"></span><br><span class=\"line\">all:crtsurfdata </span><br><span class=\"line\"></span><br><span class=\"line\">crtsurfdata:crtsurfdata.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o crtsurfdata crtsurfdata.cpp $(PUBINCL) $(PUBCPP) -lm -lc</span><br><span class=\"line\">\tcp crtsurfdata ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -f crtsurfdata </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"ftp上传下载\"><a href=\"#ftp上传下载\" class=\"headerlink\" title=\"ftp上传下载\"></a>ftp上传下载</h4><h5 id=\"安装ftp\"><a href=\"#安装ftp\" class=\"headerlink\" title=\"安装ftp\"></a>安装ftp</h5><p>去看安装ftp说明</p>\n<h5 id=\"ftp客户端下载\"><a href=\"#ftp客户端下载\" class=\"headerlink\" title=\"ftp客户端下载\"></a>ftp客户端下载</h5><p>ftpgetfiles.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\">#include &quot;_ftp.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序运行参数的结构体。</span><br><span class=\"line\">struct st_arg</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char host[31];           // 远程服务端的IP和端口。</span><br><span class=\"line\">  int  mode;               // 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。</span><br><span class=\"line\">  char username[31];       // 远程服务端ftp的用户名。</span><br><span class=\"line\">  char password[31];       // 远程服务端ftp的密码。</span><br><span class=\"line\">  char remotepath[301];    // 远程服务端存放文件的目录。</span><br><span class=\"line\">  char localpath[301];     // 本地文件存放的目录。</span><br><span class=\"line\">  char matchname[101];     // 待下载文件匹配的规则。</span><br><span class=\"line\">  char listfilename[301];  // 下载前列出服务端文件名的文件。</span><br><span class=\"line\">  int  ptype;              // 下载后服务端文件的处理方式：1-什么也不做；2-删除；3-备份。</span><br><span class=\"line\">  char remotepathbak[301]; // 下载后服务端文件的备份目录。</span><br><span class=\"line\">  char okfilename[301];    // 已下载成功文件名清单。</span><br><span class=\"line\">  bool checkmtime;         // 是否需要检查服务端文件的时间，true-需要，false-不需要，缺省为false。</span><br><span class=\"line\">  int  timeout;            // 进程心跳的超时时间。</span><br><span class=\"line\">  char pname[51];          // 进程名，建议用&quot;ftpgetfiles_后缀&quot;的方式。</span><br><span class=\"line\">&#125; starg;</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件信息的结构体。</span><br><span class=\"line\">struct st_fileinfo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char filename[301];   // 文件名。</span><br><span class=\"line\">  char mtime[21];       // 文件时间。</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;struct st_fileinfo&gt; vlistfile1;    // 已下载成功文件名的容器，从okfilename中加载。</span><br><span class=\"line\">vector&lt;struct st_fileinfo&gt; vlistfile2;    // 下载前列出服务端文件名的容器，从nlist文件中加载。</span><br><span class=\"line\">vector&lt;struct st_fileinfo&gt; vlistfile3;    // 本次不需要下载的文件的容器。</span><br><span class=\"line\">vector&lt;struct st_fileinfo&gt; vlistfile4;    // 本次需要下载的文件的容器。</span><br><span class=\"line\"></span><br><span class=\"line\">// 加载okfilename文件中的内容到容器vlistfile1中。</span><br><span class=\"line\">bool LoadOKFile();</span><br><span class=\"line\"></span><br><span class=\"line\">// 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。</span><br><span class=\"line\">bool CompVector();</span><br><span class=\"line\"></span><br><span class=\"line\">// 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。</span><br><span class=\"line\">bool WriteToOKFile();</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果ptype==1，把下载成功的文件记录追加到okfilename文件中。</span><br><span class=\"line\">bool AppendToOKFile(struct st_fileinfo *stfileinfo);</span><br><span class=\"line\"></span><br><span class=\"line\">// 把ftp.nlist()方法获取到的list文件加载到容器vlistfile2中。</span><br><span class=\"line\">bool LoadListFile();</span><br><span class=\"line\"></span><br><span class=\"line\">CLogFile logfile;</span><br><span class=\"line\"></span><br><span class=\"line\">Cftp ftp;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序退出和信号2、15的处理函数。</span><br><span class=\"line\">void EXIT(int sig);</span><br><span class=\"line\"></span><br><span class=\"line\">void _help();</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构中。</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">// 下载文件功能的主函数。</span><br><span class=\"line\">bool _ftpgetfiles();</span><br><span class=\"line\"></span><br><span class=\"line\">CPActive PActive;  // 进程心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (argc!=3) &#123; _help(); return -1; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭全部的信号和输入输出。</span><br><span class=\"line\">  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。</span><br><span class=\"line\">  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。</span><br><span class=\"line\">  CloseIOAndSignal(); signal(SIGINT,EXIT); signal(SIGTERM,EXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 打开日志文件。</span><br><span class=\"line\">  if (logfile.Open(argv[1],&quot;a+&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;打开日志文件失败（%s）。\\n&quot;,argv[1]); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 解析xml，得到程序运行的参数。</span><br><span class=\"line\">  if (_xmltoarg(argv[2])==false) return -1;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.AddPInfo(starg.timeout,starg.pname);  // 把进程的心跳信息写入共享内存。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录ftp服务端。</span><br><span class=\"line\">  if (ftp.login(starg.host,starg.username,starg.password,starg.mode)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;ftp.login(%s,%s,%s) failed.\\n&quot;,starg.host,starg.username,starg.password); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // logfile.Write(&quot;ftp.login ok.\\n&quot;);  // 正式运行后，可以注释这行代码。</span><br><span class=\"line\"></span><br><span class=\"line\">  _ftpgetfiles();</span><br><span class=\"line\"></span><br><span class=\"line\">  ftp.logout();</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 下载文件功能的主函数。</span><br><span class=\"line\">bool _ftpgetfiles()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 进入ftp服务端存放文件的目录。</span><br><span class=\"line\">  if (ftp.chdir(starg.remotepath)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;ftp.chdir(%s) failed.\\n&quot;,starg.remotepath); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 调用ftp.nlist()方法列出服务端目录中的文件，结果存放到本地文件中。</span><br><span class=\"line\">  if (ftp.nlist(&quot;.&quot;,starg.listfilename)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;ftp.nlist(%s) failed.\\n&quot;,starg.remotepath); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.UptATime();   // 更新进程的心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把ftp.nlist()方法获取到的list文件加载到容器vlistfile2中。</span><br><span class=\"line\">  if (LoadListFile()==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;LoadListFile() failed.\\n&quot;);  return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.UptATime();   // 更新进程的心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">  if (starg.ptype==1)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 加载okfilename文件中的内容到容器vlistfile1中。</span><br><span class=\"line\">    LoadOKFile();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。</span><br><span class=\"line\">    CompVector();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。</span><br><span class=\"line\">    WriteToOKFile();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把vlistfile4中的内容复制到vlistfile2中。</span><br><span class=\"line\">    vlistfile2.clear(); vlistfile2.swap(vlistfile4);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.UptATime();   // 更新进程的心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">  char strremotefilename[301],strlocalfilename[301];</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历容器vlistfile2。</span><br><span class=\"line\">  for (int ii=0;ii&lt;vlistfile2.size();ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    SNPRINTF(strremotefilename,sizeof(strremotefilename),300,&quot;%s/%s&quot;,starg.remotepath,vlistfile2[ii].filename);</span><br><span class=\"line\">    SNPRINTF(strlocalfilename,sizeof(strlocalfilename),300,&quot;%s/%s&quot;,starg.localpath,vlistfile2[ii].filename);</span><br><span class=\"line\"></span><br><span class=\"line\">    logfile.Write(&quot;get %s ...&quot;,strremotefilename);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 调用ftp.get()方法从服务端下载文件。</span><br><span class=\"line\">    if (ftp.get(strremotefilename,strlocalfilename)==false) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.WriteEx(&quot;failed.\\n&quot;); return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    logfile.WriteEx(&quot;ok.\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    PActive.UptATime();   // 更新进程的心跳。</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 如果ptype==1，把下载成功的文件记录追加到okfilename文件中。</span><br><span class=\"line\">    if (starg.ptype==1) AppendToOKFile(&amp;vlistfile2[ii]);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 删除服务端的文件。</span><br><span class=\"line\">    if (starg.ptype==2) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      if (ftp.ftpdelete(strremotefilename)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;ftp.ftpdelete(%s) failed.\\n&quot;,strremotefilename); return false;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把服务端的文件转存到备份目录。</span><br><span class=\"line\">    if (starg.ptype==3) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      char strremotefilenamebak[301];</span><br><span class=\"line\">      SNPRINTF(strremotefilenamebak,sizeof(strremotefilenamebak),300,&quot;%s/%s&quot;,starg.remotepathbak,vlistfile2[ii].filename);</span><br><span class=\"line\">      if (ftp.ftprename(strremotefilename,strremotefilenamebak)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;ftp.ftprename(%s,%s) failed.\\n&quot;,strremotefilename,strremotefilenamebak); return false;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EXIT(int sig)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;程序退出，sig=%d\\n\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void _help()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;\\n&quot;);</span><br><span class=\"line\">  printf(&quot;Using:/project/tools1/bin/ftpgetfiles logfilename xmlbuffer\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;Sample:/project/tools1/bin/procctl 30 /project/tools1/bin/ftpgetfiles /log/idc/ftpgetfiles.log \\&quot;&lt;host&gt;127.0.0.1:21&lt;/host&gt;&lt;mode&gt;1&lt;/mode&gt;&lt;username&gt;lijialin&lt;/username&gt;&lt;password&gt;6VzFeKBnSoV.&lt;/password&gt;&lt;localpath&gt;/home/lijialin/ftpget&lt;/localpath&gt;&lt;remotepath&gt;/log/idc&lt;/remotepath&gt;&lt;matchname&gt;*&lt;/matchname&gt;&lt;listfilename&gt;/home/lijialin/ftpgetfiles.list&lt;/listfilename&gt;&lt;ptype&gt;1&lt;/ptype&gt;&lt;remotepathbak&gt;/tmp/idc/surfdatabak&lt;/remotepathbak&gt;&lt;okfilename&gt;/home/lijialin/ftpgetfiles.xml&lt;/okfilename&gt;&lt;checkmtime&gt;true&lt;/checkmtime&gt;&lt;timeout&gt;80&lt;/timeout&gt;&lt;pname&gt;ftplijialingetfiles&lt;/pname&gt;\\&quot;\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;本程序是通用的功能模块，用于把远程ftp服务端的文件下载到本地目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;logfilename是本程序运行的日志文件。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;xmlbuffer为文件下载的参数，如下：\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;host&gt;127.0.0.1:21&lt;/host&gt; 远程服务端的IP和端口。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;mode&gt;1&lt;/mode&gt; 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;username&gt;wucz&lt;/username&gt; 远程服务端ftp的用户名。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;password&gt;wuczpwd&lt;/password&gt; 远程服务端ftp的密码。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;remotepath&gt;/tmp/idc/surfdata&lt;/remotepath&gt; 远程服务端存放文件的目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;localpath&gt;/idcdata/surfdata&lt;/localpath&gt; 本地文件存放的目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;matchname&gt;SURF_ZH*.XML,SURF_ZH*.CSV&lt;/matchname&gt; 待下载文件匹配的规则。&quot;\\</span><br><span class=\"line\">         &quot;不匹配的文件不会被下载，本字段尽可能设置精确，不建议用*匹配全部的文件。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;listfilename&gt;/idcdata/ftplist/ftpgetfiles_surfdata.list&lt;/listfilename&gt; 下载前列出服务端文件名的文件。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;ptype&gt;1&lt;/ptype&gt; 文件下载成功后，远程服务端文件的处理方式：1-什么也不做；2-删除；3-备份，如果为3，还要指定备份的目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;remotepathbak&gt;/tmp/idc/surfdatabak&lt;/remotepathbak&gt; 文件下载成功后，服务端文件的备份目录，此参数只有当ptype=3时才有效。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;okfilename&gt;/idcdata/ftplist/ftpgetfiles_surfdata.xml&lt;/okfilename&gt; 已下载成功文件名清单，此参数只有当ptype=1时才有效。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;checkmtime&gt;true&lt;/checkmtime&gt; 是否需要检查服务端文件的时间，true-需要，false-不需要，此参数只有当ptype=1时才有效，缺省为false。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;timeout&gt;80&lt;/timeout&gt; 下载文件超时时间，单位：秒，视文件大小和网络带宽而定。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;pname&gt;ftpgetfiles_surfdata&lt;/pname&gt; 进程名，尽可能采用易懂的、与其它进程不同的名称，方便故障排查。\\n\\n\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构中。</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(&amp;starg,0,sizeof(struct st_arg));</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;host&quot;,starg.host,30);   // 远程服务端的IP和端口。</span><br><span class=\"line\">  if (strlen(starg.host)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;host is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;mode&quot;,&amp;starg.mode);   // 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。</span><br><span class=\"line\">  if (starg.mode!=2)  starg.mode=1;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;username&quot;,starg.username,30);   // 远程服务端ftp的用户名。</span><br><span class=\"line\">  if (strlen(starg.username)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;username is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;password&quot;,starg.password,30);   // 远程服务端ftp的密码。</span><br><span class=\"line\">  if (strlen(starg.password)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;password is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;remotepath&quot;,starg.remotepath,300);   // 远程服务端存放文件的目录。</span><br><span class=\"line\">  if (strlen(starg.remotepath)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;remotepath is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;localpath&quot;,starg.localpath,300);   // 本地文件存放的目录。</span><br><span class=\"line\">  if (strlen(starg.localpath)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;localpath is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;matchname&quot;,starg.matchname,100);   // 待下载文件匹配的规则。</span><br><span class=\"line\">  if (strlen(starg.matchname)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;matchname is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;listfilename&quot;,starg.listfilename,300);   // 下载前列出服务端文件名的文件。</span><br><span class=\"line\">  if (strlen(starg.listfilename)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;listfilename is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 下载后服务端文件的处理方式：1-什么也不做；2-删除；3-备份。</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;ptype&quot;,&amp;starg.ptype);   </span><br><span class=\"line\">  if ( (starg.ptype!=1) &amp;&amp; (starg.ptype!=2) &amp;&amp; (starg.ptype!=3) )</span><br><span class=\"line\">  &#123; logfile.Write(&quot;ptype is error.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;remotepathbak&quot;,starg.remotepathbak,300); // 下载后服务端文件的备份目录。</span><br><span class=\"line\">  if ( (starg.ptype==3) &amp;&amp; (strlen(starg.remotepathbak)==0) )</span><br><span class=\"line\">  &#123; logfile.Write(&quot;remotepathbak is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;okfilename&quot;,starg.okfilename,300); // 已下载成功文件名清单。</span><br><span class=\"line\">  if ( (starg.ptype==1) &amp;&amp; (strlen(starg.okfilename)==0) )</span><br><span class=\"line\">  &#123; logfile.Write(&quot;okfilename is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 是否需要检查服务端文件的时间，true-需要，false-不需要，此参数只有当ptype=1时才有效，缺省为false。</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;checkmtime&quot;,&amp;starg.checkmtime);</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;timeout&quot;,&amp;starg.timeout);   // 进程心跳的超时时间。</span><br><span class=\"line\">  if (starg.timeout==0) &#123; logfile.Write(&quot;timeout is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;pname&quot;,starg.pname,50);     // 进程名。</span><br><span class=\"line\">  if (strlen(starg.pname)==0) &#123; logfile.Write(&quot;pname is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把ftp.nlist()方法获取到的list文件加载到容器vlistfile2中。</span><br><span class=\"line\">bool LoadListFile()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  vlistfile2.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">  CFile  File;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (File.Open(starg.listfilename,&quot;r&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;File.Open(%s) 失败。\\n&quot;,starg.listfilename); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  struct st_fileinfo stfileinfo;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stfileinfo,0,sizeof(struct st_fileinfo));</span><br><span class=\"line\">   </span><br><span class=\"line\">    if (File.Fgets(stfileinfo.filename,300,true)==false) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (MatchStr(stfileinfo.filename,starg.matchname)==false) continue;</span><br><span class=\"line\"></span><br><span class=\"line\">    if ( (starg.ptype==1) &amp;&amp; (starg.checkmtime==true) )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 获取ftp服务端文件时间。</span><br><span class=\"line\">      if (ftp.mtime(stfileinfo.filename)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;ftp.mtime(%s) failed.\\n&quot;,stfileinfo.filename); return false;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">      strcpy(stfileinfo.mtime,ftp.m_mtime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    vlistfile2.push_back(stfileinfo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*</span><br><span class=\"line\">  for (int ii=0;ii&lt;vlistfile2.size();ii++)</span><br><span class=\"line\">    logfile.Write(&quot;filename=%s=\\n&quot;,vlistfile2[ii].filename);</span><br><span class=\"line\">  */</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 加载okfilename文件中的内容到容器vlistfile1中。</span><br><span class=\"line\">bool LoadOKFile()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  vlistfile1.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">  CFile File;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 注意：如果程序是第一次下载，okfilename是不存在的，并不是错误，所以也返回true。</span><br><span class=\"line\">  if ( (File.Open(starg.okfilename,&quot;r&quot;))==false )  return true;</span><br><span class=\"line\"></span><br><span class=\"line\">  char strbuffer[501];</span><br><span class=\"line\"></span><br><span class=\"line\">  struct st_fileinfo stfileinfo;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stfileinfo,0,sizeof(struct st_fileinfo));</span><br><span class=\"line\"></span><br><span class=\"line\">    if (File.Fgets(strbuffer,300,true)==false) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    GetXMLBuffer(strbuffer,&quot;filename&quot;,stfileinfo.filename);</span><br><span class=\"line\">    GetXMLBuffer(strbuffer,&quot;mtime&quot;,stfileinfo.mtime);</span><br><span class=\"line\"></span><br><span class=\"line\">    vlistfile1.push_back(stfileinfo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。</span><br><span class=\"line\">bool CompVector()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  vlistfile3.clear(); vlistfile4.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">  int ii,jj;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历vlistfile2。</span><br><span class=\"line\">  for (ii=0;ii&lt;vlistfile2.size();ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 在vlistfile1中查找vlistfile2[ii]的记录。</span><br><span class=\"line\">    for (jj=0;jj&lt;vlistfile1.size();jj++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 如果找到了，把记录放入vlistfile3。</span><br><span class=\"line\">      if ( (strcmp(vlistfile2[ii].filename,vlistfile1[jj].filename)==0) &amp;&amp;</span><br><span class=\"line\">           (strcmp(vlistfile2[ii].mtime,vlistfile1[jj].mtime)==0) )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        vlistfile3.push_back(vlistfile2[ii]); break;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果没有找到，把记录放入vlistfile4。</span><br><span class=\"line\">    if (jj==vlistfile1.size()) vlistfile4.push_back(vlistfile2[ii]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。</span><br><span class=\"line\">bool WriteToOKFile()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  CFile File;    </span><br><span class=\"line\"></span><br><span class=\"line\">  if (File.Open(starg.okfilename,&quot;w&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;File.Open(%s) failed.\\n&quot;,starg.okfilename); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (int ii=0;ii&lt;vlistfile3.size();ii++)</span><br><span class=\"line\">    File.Fprintf(&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;\\n&quot;,vlistfile3[ii].filename,vlistfile3[ii].mtime);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果ptype==1，把下载成功的文件记录追加到okfilename文件中。</span><br><span class=\"line\">bool AppendToOKFile(struct st_fileinfo *stfileinfo)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  CFile File;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (File.Open(starg.okfilename,&quot;a&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;File.Open(%s) failed.\\n&quot;,starg.okfilename); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  File.Fprintf(&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;\\n&quot;,stfileinfo-&gt;filename,stfileinfo-&gt;mtime);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"ftp客户端上传\"><a href=\"#ftp客户端上传\" class=\"headerlink\" title=\"ftp客户端上传\"></a>ftp客户端上传</h5><p>ftpputfiles.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\">#include &quot;_ftp.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序运行参数的结构体。</span><br><span class=\"line\">struct st_arg</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char host[31];           // 远程服务端的IP和端口。</span><br><span class=\"line\">  int  mode;               // 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。</span><br><span class=\"line\">  char username[31];       // 远程服务端ftp的用户名。</span><br><span class=\"line\">  char password[31];       // 远程服务端ftp的密码。</span><br><span class=\"line\">  char remotepath[301];    // 远程服务端存放文件的目录。</span><br><span class=\"line\">  char localpath[301];     // 本地文件存放的目录。</span><br><span class=\"line\">  char matchname[101];     // 待上传文件匹配的规则。</span><br><span class=\"line\">  int  ptype;              // 上传后客户端文件的处理方式：1-什么也不做；2-删除；3-备份。</span><br><span class=\"line\">  char localpathbak[301];  // 上传后客户端文件的备份目录。</span><br><span class=\"line\">  char okfilename[301];    // 已上传成功文件名清单。</span><br><span class=\"line\">  int  timeout;            // 进程心跳的超时时间。</span><br><span class=\"line\">  char pname[51];          // 进程名，建议用&quot;ftpputfiles_后缀&quot;的方式。</span><br><span class=\"line\">&#125; starg;</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件信息的结构体。</span><br><span class=\"line\">struct st_fileinfo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char filename[301];   // 文件名。</span><br><span class=\"line\">  char mtime[21];       // 文件时间。</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;struct st_fileinfo&gt; vlistfile1;    // 已上传成功文件名的容器，从okfilename中加载。</span><br><span class=\"line\">vector&lt;struct st_fileinfo&gt; vlistfile2;    // 上传前列出客户端文件名的容器，从nlist文件中加载。</span><br><span class=\"line\">vector&lt;struct st_fileinfo&gt; vlistfile3;    // 本次不需要上传的文件的容器。</span><br><span class=\"line\">vector&lt;struct st_fileinfo&gt; vlistfile4;    // 本次需要上传的文件的容器。</span><br><span class=\"line\"></span><br><span class=\"line\">// 加载okfilename文件中的内容到容器vlistfile1中。</span><br><span class=\"line\">bool LoadOKFile();</span><br><span class=\"line\"></span><br><span class=\"line\">// 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。</span><br><span class=\"line\">bool CompVector();</span><br><span class=\"line\"></span><br><span class=\"line\">// 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。</span><br><span class=\"line\">bool WriteToOKFile();</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果ptype==1，把上传成功的文件记录追加到okfilename文件中。</span><br><span class=\"line\">bool AppendToOKFile(struct st_fileinfo *stfileinfo);</span><br><span class=\"line\"></span><br><span class=\"line\">// 把localpath目录下的文件加载到vlistfile2容器中。</span><br><span class=\"line\">bool LoadLocalFile();</span><br><span class=\"line\"></span><br><span class=\"line\">CLogFile logfile;</span><br><span class=\"line\"></span><br><span class=\"line\">Cftp ftp;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序退出和信号2、15的处理函数。</span><br><span class=\"line\">void EXIT(int sig);</span><br><span class=\"line\"></span><br><span class=\"line\">void _help();</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构中。</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">// 上传文件功能的主函数。</span><br><span class=\"line\">bool _ftpputfiles();</span><br><span class=\"line\"></span><br><span class=\"line\">CPActive PActive;  // 进程心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (argc!=3) &#123; _help(); return -1; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭全部的信号和输入输出。</span><br><span class=\"line\">  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。</span><br><span class=\"line\">  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。</span><br><span class=\"line\">  CloseIOAndSignal(); signal(SIGINT,EXIT); signal(SIGTERM,EXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 打开日志文件。</span><br><span class=\"line\">  if (logfile.Open(argv[1],&quot;a+&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;打开日志文件失败（%s）。\\n&quot;,argv[1]); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 解析xml，得到程序运行的参数。</span><br><span class=\"line\">  if (_xmltoarg(argv[2])==false) return -1;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.AddPInfo(starg.timeout,starg.pname);  // 把进程的心跳信息写入共享内存。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录ftp服务端。</span><br><span class=\"line\">  if (ftp.login(starg.host,starg.username,starg.password,starg.mode)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;ftp.login(%s,%s,%s) failed.\\n&quot;,starg.host,starg.username,starg.password); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // logfile.Write(&quot;ftp.login ok.\\n&quot;);  // 正式运行后，可以注释这行代码。</span><br><span class=\"line\"></span><br><span class=\"line\">  _ftpputfiles();</span><br><span class=\"line\"></span><br><span class=\"line\">  ftp.logout();</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 上传文件功能的主函数。</span><br><span class=\"line\">bool _ftpputfiles()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 把localpath目录下的文件加载到vlistfile2容器中。</span><br><span class=\"line\">  if (LoadLocalFile()==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;LoadLocalFile() failed.\\n&quot;);  return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.UptATime();   // 更新进程的心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">  if (starg.ptype==1)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 加载okfilename文件中的内容到容器vlistfile1中。</span><br><span class=\"line\">    LoadOKFile();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。</span><br><span class=\"line\">    CompVector();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。</span><br><span class=\"line\">    WriteToOKFile();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把vlistfile4中的内容复制到vlistfile2中。</span><br><span class=\"line\">    vlistfile2.clear(); vlistfile2.swap(vlistfile4);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.UptATime();   // 更新进程的心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">  char strremotefilename[301],strlocalfilename[301];</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历容器vlistfile2。</span><br><span class=\"line\">  for (int ii=0;ii&lt;vlistfile2.size();ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    SNPRINTF(strremotefilename,sizeof(strremotefilename),300,&quot;%s/%s&quot;,starg.remotepath,vlistfile2[ii].filename);</span><br><span class=\"line\">    SNPRINTF(strlocalfilename,sizeof(strlocalfilename),300,&quot;%s/%s&quot;,starg.localpath,vlistfile2[ii].filename);</span><br><span class=\"line\"></span><br><span class=\"line\">    logfile.Write(&quot;put %s ...&quot;,strlocalfilename);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 调用ftp.put()方法把文件上传到服务端，第三个参数填true的目的是确保文件上传成功，对方不可抵赖。</span><br><span class=\"line\">    if (ftp.put(strlocalfilename,strremotefilename,true)==false) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.WriteEx(&quot;failed.\\n&quot;); return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    logfile.WriteEx(&quot;ok.\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    PActive.UptATime();   // 更新进程的心跳。</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 如果ptype==1，把上传成功的文件记录追加到okfilename文件中。</span><br><span class=\"line\">    if (starg.ptype==1) AppendToOKFile(&amp;vlistfile2[ii]);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 删除文件。</span><br><span class=\"line\">    if (starg.ptype==2)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      if (REMOVE(strlocalfilename)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;REMOVE(%s) failed.\\n&quot;,strlocalfilename); return false;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 转存到备份目录。</span><br><span class=\"line\">    if (starg.ptype==3)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      char strlocalfilenamebak[301];</span><br><span class=\"line\">      SNPRINTF(strlocalfilenamebak,sizeof(strlocalfilenamebak),300,&quot;%s/%s&quot;,starg.localpathbak,vlistfile2[ii].filename);</span><br><span class=\"line\">      if (RENAME(strlocalfilename,strlocalfilenamebak)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;RENAME(%s,%s) failed.\\n&quot;,strlocalfilename,strlocalfilenamebak); return false;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EXIT(int sig)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;程序退出，sig=%d\\n\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void _help()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;\\n&quot;);</span><br><span class=\"line\">  printf(&quot;Using:/project/tools1/bin/ftpputfiles logfilename xmlbuffer\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;Sample:/project/tools1/bin/procctl 30 /project/tools1/bin/ftpputfiles /log/idc/ftpputfiles.log \\&quot;&lt;host&gt;127.0.0.1:21&lt;/host&gt;&lt;mode&gt;1&lt;/mode&gt;&lt;username&gt;lijialin&lt;/username&gt;&lt;password&gt;6VzFeKBnSoV.&lt;/password&gt;&lt;localpath&gt;/home/lijialin/ftptext&lt;/localpath&gt;&lt;remotepath&gt;/tmp/ftptext&lt;/remotepath&gt;&lt;matchname&gt;*&lt;/matchname&gt;&lt;ptype&gt;1&lt;/ptype&gt;&lt;localpathbak&gt;/tmp/idc/surfdatabak&lt;/localpathbak&gt;&lt;okfilename&gt;/home/lijialin/textlist.xml&lt;/okfilename&gt;&lt;timeout&gt;80&lt;/timeout&gt;&lt;pname&gt;ftplijialinputfiletext&lt;/pname&gt;\\&quot;\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;本程序是通用的功能模块，用于把本地目录中的文件上传到远程的ftp服务器。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;logfilename是本程序运行的日志文件。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;xmlbuffer为文件上传的参数，如下：\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;host&gt;127.0.0.1:21&lt;/host&gt; 远程服务端的IP和端口。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;mode&gt;1&lt;/mode&gt; 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;username&gt;wucz&lt;/username&gt; 远程服务端ftp的用户名。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;password&gt;wuczpwd&lt;/password&gt; 远程服务端ftp的密码。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;remotepath&gt;/tmp/ftpputest&lt;/remotepath&gt; 远程服务端存放文件的目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;localpath&gt;/tmp/idc/surfdata&lt;/localpath&gt; 本地文件存放的目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;matchname&gt;SURF_ZH*.JSON&lt;/matchname&gt; 待上传文件匹配的规则。&quot;\\</span><br><span class=\"line\">         &quot;不匹配的文件不会被上传，本字段尽可能设置精确，不建议用*匹配全部的文件。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;ptype&gt;1&lt;/ptype&gt; 文件上传成功后，本地文件的处理方式：1-什么也不做；2-删除；3-备份，如果为3，还要指定备份的目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;localpathbak&gt;/tmp/idc/surfdatabak&lt;/localpathbak&gt; 文件上传成功后，本地文件的备份目录，此参数只有当ptype=3时才有效。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;okfilename&gt;/idcdata/ftplist/ftpputfiles_surfdata.xml&lt;/okfilename&gt; 已上传成功文件名清单，此参数只有当ptype=1时才有效。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;timeout&gt;80&lt;/timeout&gt; 上传文件超时时间，单位：秒，视文件大小和网络带宽而定。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;&lt;pname&gt;ftpputfiles_surfdata&lt;/pname&gt; 进程名，尽可能采用易懂的、与其它进程不同的名称，方便故障排查。\\n\\n\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构中。</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(&amp;starg,0,sizeof(struct st_arg));</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;host&quot;,starg.host,30);   // 远程服务端的IP和端口。</span><br><span class=\"line\">  if (strlen(starg.host)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;host is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;mode&quot;,&amp;starg.mode);   // 传输模式，1-被动模式，2-主动模式，缺省采用被动模式。</span><br><span class=\"line\">  if (starg.mode!=2)  starg.mode=1;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;username&quot;,starg.username,30);   // 远程服务端ftp的用户名。</span><br><span class=\"line\">  if (strlen(starg.username)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;username is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;password&quot;,starg.password,30);   // 远程服务端ftp的密码。</span><br><span class=\"line\">  if (strlen(starg.password)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;password is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;remotepath&quot;,starg.remotepath,300);   // 远程服务端存放文件的目录。</span><br><span class=\"line\">  if (strlen(starg.remotepath)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;remotepath is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;localpath&quot;,starg.localpath,300);   // 本地文件存放的目录。</span><br><span class=\"line\">  if (strlen(starg.localpath)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;localpath is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;matchname&quot;,starg.matchname,100);   // 待上传文件匹配的规则。</span><br><span class=\"line\">  if (strlen(starg.matchname)==0)</span><br><span class=\"line\">  &#123; logfile.Write(&quot;matchname is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 上传后客户端文件的处理方式：1-什么也不做；2-删除；3-备份。</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;ptype&quot;,&amp;starg.ptype);   </span><br><span class=\"line\">  if ( (starg.ptype!=1) &amp;&amp; (starg.ptype!=2) &amp;&amp; (starg.ptype!=3) )</span><br><span class=\"line\">  &#123; logfile.Write(&quot;ptype is error.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;localpathbak&quot;,starg.localpathbak,300); // 上传后客户端文件的备份目录。</span><br><span class=\"line\">  if ( (starg.ptype==3) &amp;&amp; (strlen(starg.localpathbak)==0) )</span><br><span class=\"line\">  &#123; logfile.Write(&quot;localpathbak is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;okfilename&quot;,starg.okfilename,300); // 已上传成功文件名清单。</span><br><span class=\"line\">  if ( (starg.ptype==1) &amp;&amp; (strlen(starg.okfilename)==0) )</span><br><span class=\"line\">  &#123; logfile.Write(&quot;okfilename is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;timeout&quot;,&amp;starg.timeout);   // 进程心跳的超时时间。</span><br><span class=\"line\">  if (starg.timeout==0) &#123; logfile.Write(&quot;timeout is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;pname&quot;,starg.pname,50);     // 进程名。</span><br><span class=\"line\">  if (strlen(starg.pname)==0) &#123; logfile.Write(&quot;pname is null.\\n&quot;);  return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把localpath目录下的文件加载到vlistfile2容器中。</span><br><span class=\"line\">bool LoadLocalFile()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  vlistfile2.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">  CDir Dir;</span><br><span class=\"line\"></span><br><span class=\"line\">  Dir.SetDateFMT(&quot;yyyymmddhh24miss&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 不包括子目录。</span><br><span class=\"line\">  // 注意，如果本地目录下的总文件数超过10000，增量上传文件功能将有问题。</span><br><span class=\"line\">  // 建议用deletefiles程序及时清理本地目录中的历史文件。</span><br><span class=\"line\">  if (Dir.OpenDir(starg.localpath,starg.matchname)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;Dir.OpenDir(%s) 失败。\\n&quot;,starg.localpath); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  struct st_fileinfo stfileinfo;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stfileinfo,0,sizeof(struct st_fileinfo));</span><br><span class=\"line\">   </span><br><span class=\"line\">    if (Dir.ReadDir()==false) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    strcpy(stfileinfo.filename,Dir.m_FileName);   // 文件名，不包括目录名。</span><br><span class=\"line\">    strcpy(stfileinfo.mtime,Dir.m_ModifyTime);    // 文件时间。</span><br><span class=\"line\"></span><br><span class=\"line\">    vlistfile2.push_back(stfileinfo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 加载okfilename文件中的内容到容器vlistfile1中。</span><br><span class=\"line\">bool LoadOKFile()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  vlistfile1.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">  CFile File;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 注意：如果程序是第一次上传，okfilename是不存在的，并不是错误，所以也返回true。</span><br><span class=\"line\">  if ( (File.Open(starg.okfilename,&quot;r&quot;))==false )  return true;</span><br><span class=\"line\"></span><br><span class=\"line\">  char strbuffer[501];</span><br><span class=\"line\"></span><br><span class=\"line\">  struct st_fileinfo stfileinfo;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stfileinfo,0,sizeof(struct st_fileinfo));</span><br><span class=\"line\"></span><br><span class=\"line\">    if (File.Fgets(strbuffer,300,true)==false) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    GetXMLBuffer(strbuffer,&quot;filename&quot;,stfileinfo.filename);</span><br><span class=\"line\">    GetXMLBuffer(strbuffer,&quot;mtime&quot;,stfileinfo.mtime);</span><br><span class=\"line\"></span><br><span class=\"line\">    vlistfile1.push_back(stfileinfo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 比较vlistfile2和vlistfile1，得到vlistfile3和vlistfile4。</span><br><span class=\"line\">bool CompVector()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  vlistfile3.clear(); vlistfile4.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">  int ii,jj;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 遍历vlistfile2。</span><br><span class=\"line\">  for (ii=0;ii&lt;vlistfile2.size();ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 在vlistfile1中查找vlistfile2[ii]的记录。</span><br><span class=\"line\">    for (jj=0;jj&lt;vlistfile1.size();jj++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 如果找到了，把记录放入vlistfile3。</span><br><span class=\"line\">      if ( (strcmp(vlistfile2[ii].filename,vlistfile1[jj].filename)==0) &amp;&amp;</span><br><span class=\"line\">           (strcmp(vlistfile2[ii].mtime,vlistfile1[jj].mtime)==0) )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        vlistfile3.push_back(vlistfile2[ii]); break;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果没有找到，把记录放入vlistfile4。</span><br><span class=\"line\">    if (jj==vlistfile1.size()) vlistfile4.push_back(vlistfile2[ii]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把容器vlistfile3中的内容写入okfilename文件，覆盖之前的旧okfilename文件。</span><br><span class=\"line\">bool WriteToOKFile()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  CFile File;    </span><br><span class=\"line\"></span><br><span class=\"line\">  if (File.Open(starg.okfilename,&quot;w&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;File.Open(%s) failed.\\n&quot;,starg.okfilename); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (int ii=0;ii&lt;vlistfile3.size();ii++)</span><br><span class=\"line\">    File.Fprintf(&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;\\n&quot;,vlistfile3[ii].filename,vlistfile3[ii].mtime);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果ptype==1，把上传成功的文件记录追加到okfilename文件中。</span><br><span class=\"line\">bool AppendToOKFile(struct st_fileinfo *stfileinfo)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  CFile File;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (File.Open(starg.okfilename,&quot;a&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;File.Open(%s) failed.\\n&quot;,starg.okfilename); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  File.Fprintf(&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;\\n&quot;,stfileinfo-&gt;filename,stfileinfo-&gt;mtime);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"ftp编译\"><a href=\"#ftp编译\" class=\"headerlink\" title=\"ftp编译\"></a>ftp编译</h5><p>makefile</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 开发框架头文件路径。</span><br><span class=\"line\">PUBINCL = -I/project/public</span><br><span class=\"line\"></span><br><span class=\"line\"># 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。</span><br><span class=\"line\">PUBCPP = /project/public/_public.cpp</span><br><span class=\"line\"></span><br><span class=\"line\"># 编译参数。</span><br><span class=\"line\">CFLAGS = -g</span><br><span class=\"line\"></span><br><span class=\"line\">all: ftpgetfiles ftpputfiles</span><br><span class=\"line\"></span><br><span class=\"line\">ftpgetfiles:ftpgetfiles.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o ftpgetfiles ftpgetfiles.cpp $(PUBINCL) $(PUBCPP) /project/public/libftp.a /project/public/_ftp.cpp -lm -lc</span><br><span class=\"line\">\tcp ftpgetfiles ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">ftpputfiles:ftpputfiles.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o ftpputfiles ftpputfiles.cpp $(PUBINCL) $(PUBCPP) /project/public/libftp.a /project/public/_ftp.cpp -lm -lc</span><br><span class=\"line\">\tcp ftpputfiles ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -f ftpgetfiles ftpputfiles</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"TCP上传下载\"><a href=\"#TCP上传下载\" class=\"headerlink\" title=\"TCP上传下载\"></a>TCP上传下载</h4><h5 id=\"tcp客户端上传\"><a href=\"#tcp客户端上传\" class=\"headerlink\" title=\"tcp客户端上传\"></a>tcp客户端上传</h5><p>tcpputfiles.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * 程序名：tcpputfiles.cpp，采用tcp协议，实现文件上传的客户端。</span><br><span class=\"line\">*/</span><br><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序运行的参数结构体。</span><br><span class=\"line\">struct st_arg</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int  clienttype;          // 客户端类型，1-上传文件；2-下载文件。</span><br><span class=\"line\">  char ip[31];              // 服务端的IP地址。</span><br><span class=\"line\">  int  port;                // 服务端的端口。</span><br><span class=\"line\">  int  ptype;               // 文件上传成功后本地文件的处理方式：1-删除文件；2-移动到备份目录。</span><br><span class=\"line\">  char clientpath[301];     // 本地文件存放的根目录。</span><br><span class=\"line\">  char clientpathbak[301];  // 文件成功上传后，本地文件备份的根目录，当ptype==2时有效。</span><br><span class=\"line\">  bool andchild;            // 是否上传clientpath目录下各级子目录的文件，true-是；false-否。</span><br><span class=\"line\">  char matchname[301];      // 待上传文件名的匹配规则，如&quot;*.TXT,*.XML&quot;。</span><br><span class=\"line\">  char srvpath[301];        // 服务端文件存放的根目录。</span><br><span class=\"line\">  int  timetvl;             // 扫描本地目录文件的时间间隔，单位：秒。</span><br><span class=\"line\">  int  timeout;             // 进程心跳的超时时间。</span><br><span class=\"line\">  char pname[51];           // 进程名，建议用&quot;tcpputfiles_后缀&quot;的方式。</span><br><span class=\"line\">&#125; starg;</span><br><span class=\"line\"></span><br><span class=\"line\">CLogFile logfile;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序退出和信号2、15的处理函数。</span><br><span class=\"line\">void EXIT(int sig);</span><br><span class=\"line\"></span><br><span class=\"line\">void _help();</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构中。</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">CTcpClient TcpClient;</span><br><span class=\"line\"></span><br><span class=\"line\">bool Login(const char *argv);    // 登录业务。</span><br><span class=\"line\"></span><br><span class=\"line\">bool ActiveTest();    // 心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">char strrecvbuffer[1024];   // 发送报文的buffer。</span><br><span class=\"line\">char strsendbuffer[1024];   // 接收报文的buffer。</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件上传的主函数，执行一次文件上传的任务。</span><br><span class=\"line\">bool _tcpputfiles();</span><br><span class=\"line\">bool bcontinue=true;   // 如果调用_tcpputfiles发送了文件，bcontinue为true，初始化为true。</span><br><span class=\"line\"></span><br><span class=\"line\">// 把文件的内容发送给对端。</span><br><span class=\"line\">bool SendFile(const int sockfd,const char *filename,const int filesize);</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除或者转存本地的文件。</span><br><span class=\"line\">bool AckMessage(const char *strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">CPActive PActive;  // 进程心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (argc!=3) &#123; _help(); return -1; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭全部的信号和输入输出。</span><br><span class=\"line\">  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。</span><br><span class=\"line\">  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。</span><br><span class=\"line\">  CloseIOAndSignal(); signal(SIGINT,EXIT); signal(SIGTERM,EXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 打开日志文件。</span><br><span class=\"line\">  if (logfile.Open(argv[1],&quot;a+&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;打开日志文件失败（%s）。\\n&quot;,argv[1]); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 解析xml，得到程序运行的参数。</span><br><span class=\"line\">  if (_xmltoarg(argv[2])==false) return -1;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.AddPInfo(starg.timeout,starg.pname);  // 把进程的心跳信息写入共享内存。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 向服务端发起连接请求。</span><br><span class=\"line\">  if (TcpClient.ConnectToServer(starg.ip,starg.port)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;TcpClient.ConnectToServer(%s,%d) failed.\\n&quot;,starg.ip,starg.port); EXIT(-1);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录业务。</span><br><span class=\"line\">  if (Login(argv[2])==false) &#123; logfile.Write(&quot;Login() failed.\\n&quot;); EXIT(-1); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 调用文件上传的主函数，执行一次文件上传的任务。</span><br><span class=\"line\">    if (_tcpputfiles()==false) &#123; logfile.Write(&quot;_tcpputfiles() failed.\\n&quot;); EXIT(-1); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (bcontinue==false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      sleep(starg.timetvl);</span><br><span class=\"line\"></span><br><span class=\"line\">      if (ActiveTest()==false) break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PActive.UptATime();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">  EXIT(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 心跳。 </span><br><span class=\"line\">bool ActiveTest()    </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\">  memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\"> </span><br><span class=\"line\">  SPRINTF(strsendbuffer,sizeof(strsendbuffer),&quot;&lt;activetest&gt;ok&lt;/activetest&gt;&quot;);</span><br><span class=\"line\">  // logfile.Write(&quot;发送：%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">  if (TcpClient.Write(strsendbuffer)==false) return false; // 向服务端发送请求报文。</span><br><span class=\"line\"></span><br><span class=\"line\">  if (TcpClient.Read(strrecvbuffer,20)==false) return false; // 接收服务端的回应报文。</span><br><span class=\"line\">  // logfile.Write(&quot;接收：%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 登录业务。 </span><br><span class=\"line\">bool Login(const char *argv)    </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\">  memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\"> </span><br><span class=\"line\">  SPRINTF(strsendbuffer,sizeof(strsendbuffer),&quot;%s&lt;clienttype&gt;1&lt;/clienttype&gt;&quot;,argv);</span><br><span class=\"line\">  logfile.Write(&quot;发送：%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">  if (TcpClient.Write(strsendbuffer)==false) return false; // 向服务端发送请求报文。</span><br><span class=\"line\"></span><br><span class=\"line\">  if (TcpClient.Read(strrecvbuffer,20)==false) return false; // 接收服务端的回应报文。</span><br><span class=\"line\">  logfile.Write(&quot;接收：%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">  logfile.Write(&quot;登录(%s:%d)成功。\\n&quot;,starg.ip,starg.port); </span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EXIT(int sig)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  logfile.Write(&quot;程序退出，sig=%d\\n\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void _help()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;\\n&quot;);</span><br><span class=\"line\">  printf(&quot;Using:/project/tools1/bin/tcpputfiles logfilename xmlbuffer\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;Sample:/project/tools1/bin/procctl 20 /project/tools1/bin/tcpputfiles /log/idc/tcpputfiles_surfdata.log \\&quot;&lt;ip&gt;39.106.159.62&lt;/ip&gt;&lt;port&gt;5005&lt;/port&gt;&lt;ptype&gt;1&lt;/ptype&gt;&lt;clientpath&gt;/tmp/tcp/surfdata1&lt;/clientpath&gt;&lt;andchild&gt;true&lt;/andchild&gt;&lt;matchname&gt;*.XML,*.CSV,*.JSON&lt;/matchname&gt;&lt;srvpath&gt;/tmp/tcp/surfdata2&lt;/srvpath&gt;&lt;timetvl&gt;10&lt;/timetvl&gt;&lt;timeout&gt;50&lt;/timeout&gt;&lt;pname&gt;tcpputfiles_surfdata&lt;/pname&gt;\\&quot;\\n&quot;);</span><br><span class=\"line\">  printf(&quot;       /project/tools1/bin/procctl 20 /project/tools1/bin/tcpputfiles /log/idc/tcpputfiles_surfdata.log \\&quot;&lt;ip&gt;39.106.159.62&lt;/ip&gt;&lt;port&gt;5005&lt;/port&gt;&lt;ptype&gt;2&lt;/ptype&gt;&lt;clientpath&gt;/tmp/tcp/surfdata1&lt;/clientpath&gt;&lt;clientpathbak&gt;/tmp/tcp/surfdata1bak&lt;/clientpathbak&gt;&lt;andchild&gt;true&lt;/andchild&gt;&lt;matchname&gt;*.XML,*.CSV,*.JSON&lt;/matchname&gt;&lt;srvpath&gt;/tmp/tcp/surfdata2&lt;/srvpath&gt;&lt;timetvl&gt;10&lt;/timetvl&gt;&lt;timeout&gt;50&lt;/timeout&gt;&lt;pname&gt;tcpputfiles_surfdata&lt;/pname&gt;\\&quot;\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;本程序是数据中心的公共功能模块，采用tcp协议把文件上传给服务端。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;logfilename   本程序运行的日志文件。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;xmlbuffer     本程序运行的参数，如下：\\n&quot;);</span><br><span class=\"line\">  printf(&quot;ip            服务端的IP地址。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;port          服务端的端口。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;ptype         文件上传成功后的处理方式：1-删除文件；2-移动到备份目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;clientpath    本地文件存放的根目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;clientpathbak 文件成功上传后，本地文件备份的根目录，当ptype==2时有效。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;andchild      是否上传clientpath目录下各级子目录的文件，true-是；false-否，缺省为false。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;matchname     待上传文件名的匹配规则，如\\&quot;*.TXT,*.XML\\&quot;\\n&quot;);</span><br><span class=\"line\">  printf(&quot;srvpath       服务端文件存放的根目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;timetvl       扫描本地目录文件的时间间隔，单位：秒，取值在1-30之间。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;timeout       本程序的超时时间，单位：秒，视文件大小和网络带宽而定，建议设置50以上。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;pname         进程名，尽可能采用易懂的、与其它进程不同的名称，方便故障排查。\\n\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(&amp;starg,0,sizeof(struct st_arg));</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;ip&quot;,starg.ip);</span><br><span class=\"line\">  if (strlen(starg.ip)==0) &#123; logfile.Write(&quot;ip is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;port&quot;,&amp;starg.port);</span><br><span class=\"line\">  if ( starg.port==0) &#123; logfile.Write(&quot;port is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;ptype&quot;,&amp;starg.ptype);</span><br><span class=\"line\">  if ((starg.ptype!=1)&amp;&amp;(starg.ptype!=2)) &#123; logfile.Write(&quot;ptype not in (1,2).\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;clientpath&quot;,starg.clientpath);</span><br><span class=\"line\">  if (strlen(starg.clientpath)==0) &#123; logfile.Write(&quot;clientpath is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;clientpathbak&quot;,starg.clientpathbak);</span><br><span class=\"line\">  if ((starg.ptype==2)&amp;&amp;(strlen(starg.clientpathbak)==0)) &#123; logfile.Write(&quot;clientpathbak is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;andchild&quot;,&amp;starg.andchild);</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;matchname&quot;,starg.matchname);</span><br><span class=\"line\">  if (strlen(starg.matchname)==0) &#123; logfile.Write(&quot;matchname is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;srvpath&quot;,starg.srvpath);</span><br><span class=\"line\">  if (strlen(starg.srvpath)==0) &#123; logfile.Write(&quot;srvpath is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;timetvl&quot;,&amp;starg.timetvl);</span><br><span class=\"line\">  if (starg.timetvl==0) &#123; logfile.Write(&quot;timetvl is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 扫描本地目录文件的时间间隔，单位：秒。</span><br><span class=\"line\">  // starg.timetvl没有必要超过30秒。</span><br><span class=\"line\">  if (starg.timetvl&gt;30) starg.timetvl=30;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 进程心跳的超时时间，一定要大于starg.timetvl，没有必要小于50秒。</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;timeout&quot;,&amp;starg.timeout);</span><br><span class=\"line\">  if (starg.timeout==0) &#123; logfile.Write(&quot;timeout is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\">  if (starg.timeout&lt;50) starg.timeout=50;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;pname&quot;,starg.pname,50);</span><br><span class=\"line\">  if (strlen(starg.pname)==0) &#123; logfile.Write(&quot;pname is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件上传的主函数，执行一次文件上传的任务。</span><br><span class=\"line\">bool _tcpputfiles()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  CDir Dir;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 调用OpenDir()打开starg.clientpath目录。</span><br><span class=\"line\">  if (Dir.OpenDir(starg.clientpath,starg.matchname,10000,starg.andchild)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;Dir.OpenDir(%s) 失败。\\n&quot;,starg.clientpath); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  int delayed=0;        // 未收到对端确认报文的文件数量。</span><br><span class=\"line\">  int buflen=0;         // 用于存放strrecvbuffer的长度。</span><br><span class=\"line\"></span><br><span class=\"line\">  bcontinue=false;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\">    memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 遍历目录中的每个文件，调用ReadDir()获取一个文件名。</span><br><span class=\"line\">    if (Dir.ReadDir()==false) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    bcontinue=true;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把文件名、修改时间、文件大小组成报文，发送给对端。</span><br><span class=\"line\">    SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;&lt;size&gt;%d&lt;/size&gt;&quot;,Dir.m_FullFileName,Dir.m_ModifyTime,Dir.m_FileSize);</span><br><span class=\"line\"></span><br><span class=\"line\">    // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">    if (TcpClient.Write(strsendbuffer)==false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.Write(&quot;TcpClient.Write() failed.\\n&quot;); return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把文件的内容发送给对端。</span><br><span class=\"line\">    logfile.Write(&quot;send %s(%d) ...&quot;,Dir.m_FullFileName,Dir.m_FileSize);</span><br><span class=\"line\">    if (SendFile(TcpClient.m_connfd,Dir.m_FullFileName,Dir.m_FileSize)==true)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.WriteEx(&quot;ok.\\n&quot;); delayed++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.WriteEx(&quot;failed.\\n&quot;); TcpClient.Close(); return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PActive.UptATime();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 接收对端的确认报文。</span><br><span class=\"line\">    while (delayed&gt;0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\">      if (TcpRead(TcpClient.m_connfd,strrecvbuffer,&amp;buflen,-1)==false) break;</span><br><span class=\"line\">      // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 删除或者转存本地的文件。</span><br><span class=\"line\">      delayed--;</span><br><span class=\"line\">      AckMessage(strrecvbuffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 继续接收对端的确认报文。</span><br><span class=\"line\">  while (delayed&gt;0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\">    if (TcpRead(TcpClient.m_connfd,strrecvbuffer,&amp;buflen,10)==false) break;</span><br><span class=\"line\">    // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 删除或者转存本地的文件。</span><br><span class=\"line\">    delayed--;</span><br><span class=\"line\">    AckMessage(strrecvbuffer);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 把文件的内容发送给对端。</span><br><span class=\"line\">bool SendFile(const int sockfd,const char *filename,const int filesize)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int  onread=0;        // 每次调用fread时打算读取的字节数。 </span><br><span class=\"line\">  int  bytes=0;         // 调用一次fread从文件中读取的字节数。</span><br><span class=\"line\">  char buffer[1000];    // 存放读取数据的buffer。</span><br><span class=\"line\">  int  totalbytes=0;    // 从文件中已读取的字节总数。</span><br><span class=\"line\">  FILE *fp=NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 以&quot;rb&quot;的模式打开文件。</span><br><span class=\"line\">  if ( (fp=fopen(filename,&quot;rb&quot;))==NULL )  return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(buffer,0,sizeof(buffer));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算本次应该读取的字节数，如果剩余的数据超过1000字节，就打算读1000字节。</span><br><span class=\"line\">    if (filesize-totalbytes&gt;1000) onread=1000;</span><br><span class=\"line\">    else onread=filesize-totalbytes;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从文件中读取数据。</span><br><span class=\"line\">    bytes=fread(buffer,1,onread,fp);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把读取到的数据发送给对端。</span><br><span class=\"line\">    if (bytes&gt;0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      if (Writen(sockfd,buffer,bytes)==false) &#123; fclose(fp); return false; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算文件已读取的字节总数，如果文件已读完，跳出循环。</span><br><span class=\"line\">    totalbytes=totalbytes+bytes;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (totalbytes==filesize) break;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  fclose(fp);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除或者转存本地的文件。</span><br><span class=\"line\">bool AckMessage(const char *strrecvbuffer)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char filename[301];</span><br><span class=\"line\">  char result[11];</span><br><span class=\"line\"></span><br><span class=\"line\">  memset(filename,0,sizeof(filename));</span><br><span class=\"line\">  memset(result,0,sizeof(result));</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strrecvbuffer,&quot;filename&quot;,filename,300);</span><br><span class=\"line\">  GetXMLBuffer(strrecvbuffer,&quot;result&quot;,result,10);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 如果服务端接收文件不成功，直接返回。</span><br><span class=\"line\">  if (strcmp(result,&quot;ok&quot;)!=0) return true;</span><br><span class=\"line\"></span><br><span class=\"line\">  // ptype==1，删除文件。</span><br><span class=\"line\">  if (starg.ptype==1)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    if (REMOVE(filename)==false) &#123; logfile.Write(&quot;REMOVE(%s) failed.\\n&quot;,filename); return false; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  // ptype==2，移动到备份目录。</span><br><span class=\"line\">  if (starg.ptype==2)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 生成转存后的备份目录文件名。</span><br><span class=\"line\">    char bakfilename[301];</span><br><span class=\"line\">    STRCPY(bakfilename,sizeof(bakfilename),filename);</span><br><span class=\"line\">    UpdateStr(bakfilename,starg.clientpath,starg.clientpathbak,false);</span><br><span class=\"line\">    if (RENAME(filename,bakfilename)==false) </span><br><span class=\"line\">    &#123; logfile.Write(&quot;RENAME(%s,%s) failed.\\n&quot;,filename,bakfilename); return false; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"tcp客户端下载\"><a href=\"#tcp客户端下载\" class=\"headerlink\" title=\"tcp客户端下载\"></a>tcp客户端下载</h5><p>tcpgetfiles.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * 程序名：tcpgetfiles.cpp，采用tcp协议，实现文件下载的客户端。</span><br><span class=\"line\">*/</span><br><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序运行的参数结构体。</span><br><span class=\"line\">struct st_arg</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int  clienttype;          // 客户端类型，1-上传文件；2-下载文件。</span><br><span class=\"line\">  char ip[31];              // 服务端的IP地址。</span><br><span class=\"line\">  int  port;                // 服务端的端口。</span><br><span class=\"line\">  int  ptype;               // 文件下载成功后服务端文件的处理方式：1-删除文件；2-移动到备份目录。</span><br><span class=\"line\">  char srvpath[301];        // 服务端文件存放的根目录。</span><br><span class=\"line\">  char srvpathbak[301];     // 文件成功下载后，服务端文件备份的根目录，当ptype==2时有效。</span><br><span class=\"line\">  bool andchild;            // 是否下载srvpath目录下各级子目录的文件，true-是；false-否。</span><br><span class=\"line\">  char matchname[301];      // 待下载文件名的匹配规则，如&quot;*.TXT,*.XML&quot;。</span><br><span class=\"line\">  char clientpath[301];     // 客户端文件存放的根目录。</span><br><span class=\"line\">  int  timetvl;             // 扫描服务端目录文件的时间间隔，单位：秒。</span><br><span class=\"line\">  int  timeout;             // 进程心跳的超时时间。</span><br><span class=\"line\">  char pname[51];           // 进程名，建议用&quot;tcpgetfiles_后缀&quot;的方式。</span><br><span class=\"line\">&#125; starg;</span><br><span class=\"line\"></span><br><span class=\"line\">CLogFile logfile;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序退出和信号2、15的处理函数。</span><br><span class=\"line\">void EXIT(int sig);</span><br><span class=\"line\"></span><br><span class=\"line\">void _help();</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构中。</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">CTcpClient TcpClient;</span><br><span class=\"line\"></span><br><span class=\"line\">bool Login(const char *argv);    // 登录业务。</span><br><span class=\"line\"></span><br><span class=\"line\">char strrecvbuffer[1024];   // 发送报文的buffer。</span><br><span class=\"line\">char strsendbuffer[1024];   // 接收报文的buffer。</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件下载的主函数。</span><br><span class=\"line\">void _tcpgetfiles();</span><br><span class=\"line\"></span><br><span class=\"line\">// 接收文件的内容。</span><br><span class=\"line\">bool RecvFile(const int sockfd,const char *filename,const char *mtime,int filesize);</span><br><span class=\"line\"></span><br><span class=\"line\">CPActive PActive;  // 进程心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (argc!=3) &#123; _help(); return -1; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭全部的信号和输入输出。</span><br><span class=\"line\">  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程。</span><br><span class=\"line\">  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止。</span><br><span class=\"line\">  CloseIOAndSignal(); signal(SIGINT,EXIT); signal(SIGTERM,EXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 打开日志文件。</span><br><span class=\"line\">  if (logfile.Open(argv[1],&quot;a+&quot;)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;打开日志文件失败（%s）。\\n&quot;,argv[1]); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 解析xml，得到程序运行的参数。</span><br><span class=\"line\">  if (_xmltoarg(argv[2])==false) return -1;</span><br><span class=\"line\"></span><br><span class=\"line\">  PActive.AddPInfo(starg.timeout,starg.pname);  // 把进程的心跳信息写入共享内存。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 向服务端发起连接请求。</span><br><span class=\"line\">  if (TcpClient.ConnectToServer(starg.ip,starg.port)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;TcpClient.ConnectToServer(%s,%d) failed.\\n&quot;,starg.ip,starg.port); EXIT(-1);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录业务。</span><br><span class=\"line\">  if (Login(argv[2])==false) &#123; logfile.Write(&quot;Login() failed.\\n&quot;); EXIT(-1); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 调用文件下载的主函数。</span><br><span class=\"line\">  _tcpgetfiles();</span><br><span class=\"line\"></span><br><span class=\"line\">  EXIT(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 登录业务。 </span><br><span class=\"line\">bool Login(const char *argv)    </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\">  memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\"> </span><br><span class=\"line\">  SPRINTF(strsendbuffer,sizeof(strsendbuffer),&quot;%s&lt;clienttype&gt;2&lt;/clienttype&gt;&quot;,argv);</span><br><span class=\"line\">  logfile.Write(&quot;发送：%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">  if (TcpClient.Write(strsendbuffer)==false) return false; // 向服务端发送请求报文。</span><br><span class=\"line\"></span><br><span class=\"line\">  if (TcpClient.Read(strrecvbuffer,20)==false) return false; // 接收服务端的回应报文。</span><br><span class=\"line\">  logfile.Write(&quot;接收：%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">  logfile.Write(&quot;登录(%s:%d)成功。\\n&quot;,starg.ip,starg.port); </span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void EXIT(int sig)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  logfile.Write(&quot;程序退出，sig=%d\\n\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void _help()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;\\n&quot;);</span><br><span class=\"line\">  printf(&quot;Using:/project/tools1/bin/tcpgetfiles logfilename xmlbuffer\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;Sample:/project/tools1/bin/procctl 20 /project/tools1/bin/tcpgetfiles /log/idc/tcpgetfiles_surfdata.log \\&quot;&lt;ip&gt;192.168.174.132&lt;/ip&gt;&lt;port&gt;5005&lt;/port&gt;&lt;ptype&gt;1&lt;/ptype&gt;&lt;srvpath&gt;/tmp/tcp/surfdata2&lt;/srvpath&gt;&lt;andchild&gt;true&lt;/andchild&gt;&lt;matchname&gt;*.XML,*.CSV,*.JSON&lt;/matchname&gt;&lt;clientpath&gt;/tmp/tcp/surfdata3&lt;/clientpath&gt;&lt;timetvl&gt;10&lt;/timetvl&gt;&lt;timeout&gt;50&lt;/timeout&gt;&lt;pname&gt;tcpgetfiles_surfdata&lt;/pname&gt;\\&quot;\\n&quot;);</span><br><span class=\"line\">  printf(&quot;       /project/tools1/bin/procctl 20 /project/tools1/bin/tcpgetfiles /log/idc/tcpgetfiles_surfdata.log \\&quot;&lt;ip&gt;192.168.174.132&lt;/ip&gt;&lt;port&gt;5005&lt;/port&gt;&lt;ptype&gt;2&lt;/ptype&gt;&lt;srvpath&gt;/tmp/tcp/surfdata2&lt;/srvpath&gt;&lt;srvpathbak&gt;/tmp/tcp/surfdata2bak&lt;/srvpathbak&gt;&lt;andchild&gt;true&lt;/andchild&gt;&lt;matchname&gt;*.XML,*.CSV,*.JSON&lt;/matchname&gt;&lt;clientpath&gt;/tmp/tcp/surfdata3&lt;/clientpath&gt;&lt;timetvl&gt;10&lt;/timetvl&gt;&lt;timeout&gt;50&lt;/timeout&gt;&lt;pname&gt;tcpgetfiles_surfdata&lt;/pname&gt;\\&quot;\\n\\n\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;本程序是数据中心的公共功能模块，采用tcp协议从服务端下载文件。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;logfilename   本程序运行的日志文件。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;xmlbuffer     本程序运行的参数，如下：\\n&quot;);</span><br><span class=\"line\">  printf(&quot;ip            服务端的IP地址。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;port          服务端的端口。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;ptype         文件下载成功后服务端文件的处理方式：1-删除文件；2-移动到备份目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;srvpath       服务端文件存放的根目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;srvpathbak    文件成功下载后，服务端文件备份的根目录，当ptype==2时有效。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;andchild      是否下载srvpath目录下各级子目录的文件，true-是；false-否，缺省为false。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;matchname     待下载文件名的匹配规则，如\\&quot;*.TXT,*.XML\\&quot;\\n&quot;);</span><br><span class=\"line\">  printf(&quot;clientpath    客户端文件存放的根目录。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;timetvl       扫描服务目录文件的时间间隔，单位：秒，取值在1-30之间。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;timeout       本程序的超时时间，单位：秒，视文件大小和网络带宽而定，建议设置50以上。\\n&quot;);</span><br><span class=\"line\">  printf(&quot;pname         进程名，尽可能采用易懂的、与其它进程不同的名称，方便故障排查。\\n\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(&amp;starg,0,sizeof(struct st_arg));</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;ip&quot;,starg.ip);</span><br><span class=\"line\">  if (strlen(starg.ip)==0) &#123; logfile.Write(&quot;ip is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;port&quot;,&amp;starg.port);</span><br><span class=\"line\">  if ( starg.port==0) &#123; logfile.Write(&quot;port is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;ptype&quot;,&amp;starg.ptype);</span><br><span class=\"line\">  if ((starg.ptype!=1)&amp;&amp;(starg.ptype!=2)) &#123; logfile.Write(&quot;ptype not in (1,2).\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;srvpath&quot;,starg.srvpath);</span><br><span class=\"line\">  if (strlen(starg.srvpath)==0) &#123; logfile.Write(&quot;srvpath is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;srvpathbak&quot;,starg.srvpathbak);</span><br><span class=\"line\">  if ((starg.ptype==2)&amp;&amp;(strlen(starg.srvpathbak)==0)) &#123; logfile.Write(&quot;srvpathbak is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;andchild&quot;,&amp;starg.andchild);</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;matchname&quot;,starg.matchname);</span><br><span class=\"line\">  if (strlen(starg.matchname)==0) &#123; logfile.Write(&quot;matchname is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;clientpath&quot;,starg.clientpath);</span><br><span class=\"line\">  if (strlen(starg.clientpath)==0) &#123; logfile.Write(&quot;clientpath is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;timetvl&quot;,&amp;starg.timetvl);</span><br><span class=\"line\">  if (starg.timetvl==0) &#123; logfile.Write(&quot;timetvl is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 扫描服务端目录文件的时间间隔，单位：秒。</span><br><span class=\"line\">  // starg.timetvl没有必要超过30秒。</span><br><span class=\"line\">  if (starg.timetvl&gt;30) starg.timetvl=30;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 进程心跳的超时时间，一定要大于starg.timetvl，没有必要小于50秒。</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;timeout&quot;,&amp;starg.timeout);</span><br><span class=\"line\">  if (starg.timeout==0) &#123; logfile.Write(&quot;timeout is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\">  if (starg.timeout&lt;50) starg.timeout=50;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;pname&quot;,starg.pname,50);</span><br><span class=\"line\">  if (strlen(starg.pname)==0) &#123; logfile.Write(&quot;pname is null.\\n&quot;); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件下载的主函数。</span><br><span class=\"line\">void _tcpgetfiles()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  PActive.AddPInfo(starg.timeout,starg.pname);</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\">    memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\"></span><br><span class=\"line\">    PActive.UptATime();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 接收服务端的报文。</span><br><span class=\"line\">    // 第二个参数的取值必须大于starg.timetvl，小于starg.timeout。</span><br><span class=\"line\">    if (TcpClient.Read(strrecvbuffer,starg.timetvl+10)==false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.Write(&quot;TcpClient.Read() failed.\\n&quot;); return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 处理心跳报文。</span><br><span class=\"line\">    if (strcmp(strrecvbuffer,&quot;&lt;activetest&gt;ok&lt;/activetest&gt;&quot;)==0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      strcpy(strsendbuffer,&quot;ok&quot;);</span><br><span class=\"line\">      // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">      if (TcpClient.Write(strsendbuffer)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;TcpClient.Write() failed.\\n&quot;); return;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 处理下载文件的请求报文。</span><br><span class=\"line\">    if (strncmp(strrecvbuffer,&quot;&lt;filename&gt;&quot;,10)==0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 解析下载文件请求报文的xml。</span><br><span class=\"line\">      char serverfilename[301];  memset(serverfilename,0,sizeof(serverfilename));</span><br><span class=\"line\">      char mtime[21];            memset(mtime,0,sizeof(mtime));</span><br><span class=\"line\">      int  filesize=0;</span><br><span class=\"line\">      GetXMLBuffer(strrecvbuffer,&quot;filename&quot;,serverfilename,300);</span><br><span class=\"line\">      GetXMLBuffer(strrecvbuffer,&quot;mtime&quot;,mtime,19);</span><br><span class=\"line\">      GetXMLBuffer(strrecvbuffer,&quot;size&quot;,&amp;filesize);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 客户端和服务端文件的目录是不一样的，以下代码生成客户端的文件名。</span><br><span class=\"line\">      // 把文件名中的srvpath替换成clientpath，要小心第三个参数</span><br><span class=\"line\">      char clientfilename[301];  memset(clientfilename,0,sizeof(clientfilename));</span><br><span class=\"line\">      strcpy(clientfilename,serverfilename);</span><br><span class=\"line\">      UpdateStr(clientfilename,starg.srvpath,starg.clientpath,false);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 接收文件的内容。</span><br><span class=\"line\">      logfile.Write(&quot;recv %s(%d) ...&quot;,clientfilename,filesize);</span><br><span class=\"line\">      if (RecvFile(TcpClient.m_connfd,clientfilename,mtime,filesize)==true)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.WriteEx(&quot;ok.\\n&quot;);</span><br><span class=\"line\">        SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;result&gt;ok&lt;/result&gt;&quot;,serverfilename);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      else</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.WriteEx(&quot;failed.\\n&quot;);</span><br><span class=\"line\">        SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;result&gt;failed&lt;/result&gt;&quot;,serverfilename);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 把接收结果返回给对端。</span><br><span class=\"line\">      // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">      if (TcpClient.Write(strsendbuffer)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;TcpClient.Write() failed.\\n&quot;); return;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 接收文件的内容。</span><br><span class=\"line\">bool RecvFile(const int sockfd,const char *filename,const char *mtime,int filesize)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 生成临时文件名。</span><br><span class=\"line\">  char strfilenametmp[301];</span><br><span class=\"line\">  SNPRINTF(strfilenametmp,sizeof(strfilenametmp),300,&quot;%s.tmp&quot;,filename);</span><br><span class=\"line\"></span><br><span class=\"line\">  int  totalbytes=0;        // 已接收文件的总字节数。</span><br><span class=\"line\">  int  onread=0;            // 本次打算接收的字节数。</span><br><span class=\"line\">  char buffer[1000];        // 接收文件内容的缓冲区。</span><br><span class=\"line\">  FILE *fp=NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 创建临时文件。</span><br><span class=\"line\">  if ( (fp=FOPEN(strfilenametmp,&quot;wb&quot;))==NULL ) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(buffer,0,sizeof(buffer));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算本次应该接收的字节数。</span><br><span class=\"line\">    if (filesize-totalbytes&gt;1000) onread=1000;</span><br><span class=\"line\">    else onread=filesize-totalbytes;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 接收文件内容。</span><br><span class=\"line\">    if (Readn(sockfd,buffer,onread)==false) &#123; fclose(fp); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把接收到的内容写入文件。</span><br><span class=\"line\">    fwrite(buffer,1,onread,fp);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算已接收文件的总字节数，如果文件接收完，跳出循环。</span><br><span class=\"line\">    totalbytes=totalbytes+onread;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (totalbytes==filesize) break;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭临时文件。</span><br><span class=\"line\">  fclose(fp);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 重置文件的时间。</span><br><span class=\"line\">  UTime(strfilenametmp,mtime);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把临时文件RENAME为正式的文件。</span><br><span class=\"line\">  if (RENAME(strfilenametmp,filename)==false) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"tcp服务端\"><a href=\"#tcp服务端\" class=\"headerlink\" title=\"tcp服务端\"></a>tcp服务端</h5><p>fileserver.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * 程序名：fileserver.cpp，文件传输的服务端。</span><br><span class=\"line\">*/</span><br><span class=\"line\">#include &quot;_public.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 程序运行的参数结构体。</span><br><span class=\"line\">struct st_arg</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int  clienttype;          // 客户端类型，1-上传文件；2-下载文件。</span><br><span class=\"line\">  char ip[31];              // 服务端的IP地址。</span><br><span class=\"line\">  int  port;                // 服务端的端口。</span><br><span class=\"line\">  int  ptype;               // 文件成功传输后的处理方式：1-删除文件；2-移动到备份目录。</span><br><span class=\"line\">  char clientpath[301];     // 客户端文件存放的根目录。</span><br><span class=\"line\">  bool andchild;            // 是否传输各级子目录的文件，true-是；false-否。</span><br><span class=\"line\">  char matchname[301];      // 待传输文件名的匹配规则，如&quot;*.TXT,*.XML&quot;。</span><br><span class=\"line\">  char srvpath[301];        // 服务端文件存放的根目录。</span><br><span class=\"line\">  char srvpathbak[301];     // 文件成功下载后，服务端文件备份的根目录，当ptype==2时有效。</span><br><span class=\"line\">  int  timetvl;             // 扫描目录文件的时间间隔，单位：秒。</span><br><span class=\"line\">  int  timeout;             // 进程心跳的超时时间。</span><br><span class=\"line\">  char pname[51];           // 进程名，建议用&quot;tcpgetfiles_后缀&quot;的方式。</span><br><span class=\"line\">&#125; starg;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构中。</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">CLogFile logfile;      // 服务程序的运行日志。</span><br><span class=\"line\">CTcpServer TcpServer;  // 创建服务端对象。</span><br><span class=\"line\"></span><br><span class=\"line\">void FathEXIT(int sig);  // 父进程退出函数。</span><br><span class=\"line\">void ChldEXIT(int sig);  // 子进程退出函数。</span><br><span class=\"line\"></span><br><span class=\"line\">bool ActiveTest();    // 心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">char strrecvbuffer[1024];   // 发送报文的buffer。</span><br><span class=\"line\">char strsendbuffer[1024];   // 接收报文的buffer。</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件下载的主函数，执行一次文件下载的任务。</span><br><span class=\"line\">bool _tcpputfiles();</span><br><span class=\"line\">bool bcontinue=true;   // 如果调用_tcpputfiles发送了文件，bcontinue为true，初始化为true。</span><br><span class=\"line\"></span><br><span class=\"line\">// 把文件的内容发送给对端。</span><br><span class=\"line\">bool SendFile(const int sockfd,const char *filename,const int filesize);</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除或者转存本地的文件。</span><br><span class=\"line\">bool AckMessage(const char *strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">// 登录业务处理函数。</span><br><span class=\"line\">bool ClientLogin();</span><br><span class=\"line\"></span><br><span class=\"line\">// 上传文件的主函数。</span><br><span class=\"line\">void RecvFilesMain();</span><br><span class=\"line\"></span><br><span class=\"line\">// 下载文件的主函数。</span><br><span class=\"line\">void SendFilesMain();</span><br><span class=\"line\"></span><br><span class=\"line\">// 接收文件的内容。</span><br><span class=\"line\">bool RecvFile(const int sockfd,const char *filename,const char *mtime,int filesize);</span><br><span class=\"line\"></span><br><span class=\"line\">CPActive PActive;  // 进程心跳。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if (argc!=3)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;Using:./fileserver port logfile\\n&quot;);</span><br><span class=\"line\">    printf(&quot;Example:./fileserver 5005 /log/idc/fileserver.log\\n&quot;); </span><br><span class=\"line\">    printf(&quot;         /project/tools1/bin/procctl 10 /project/tools1/bin/fileserver 5005 /log/idc/fileserver.log\\n\\n\\n&quot;); </span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭全部的信号和输入输出。</span><br><span class=\"line\">  // 设置信号,在shell状态下可用 &quot;kill + 进程号&quot; 正常终止些进程</span><br><span class=\"line\">  // 但请不要用 &quot;kill -9 +进程号&quot; 强行终止</span><br><span class=\"line\">  CloseIOAndSignal(); signal(SIGINT,FathEXIT); signal(SIGTERM,FathEXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">  if (logfile.Open(argv[2],&quot;a+&quot;)==false) &#123; printf(&quot;logfile.Open(%s) failed.\\n&quot;,argv[2]); return -1; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 服务端初始化。</span><br><span class=\"line\">  if (TcpServer.InitServer(atoi(argv[1]))==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;TcpServer.InitServer(%s) failed.\\n&quot;,argv[1]); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 等待客户端的连接请求。</span><br><span class=\"line\">    if (TcpServer.Accept()==false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.Write(&quot;TcpServer.Accept() failed.\\n&quot;); FathEXIT(-1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    logfile.Write(&quot;客户端（%s）已连接。\\n&quot;,TcpServer.GetIP());</span><br><span class=\"line\"></span><br><span class=\"line\">    if (fork()&gt;0) &#123; TcpServer.CloseClient(); continue; &#125;  // 父进程继续回到Accept()。</span><br><span class=\"line\">   </span><br><span class=\"line\">    // 子进程重新设置退出信号。</span><br><span class=\"line\">    signal(SIGINT,ChldEXIT); signal(SIGTERM,ChldEXIT);</span><br><span class=\"line\"></span><br><span class=\"line\">    TcpServer.CloseListen();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 子进程与客户端进行通讯，处理业务。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 处理登录客户端的登录报文。</span><br><span class=\"line\">    if (ClientLogin()==false) ChldEXIT(-1);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果clienttype==1，调用上传文件的主函数。</span><br><span class=\"line\">    if (starg.clienttype==1) RecvFilesMain();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果clienttype==2，调用下载文件的主函数。</span><br><span class=\"line\">    if (starg.clienttype==2) SendFilesMain();</span><br><span class=\"line\"></span><br><span class=\"line\">    ChldEXIT(0);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 父进程退出函数。</span><br><span class=\"line\">void FathEXIT(int sig)  </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 以下代码是为了防止信号处理函数在执行的过程中被信号中断。</span><br><span class=\"line\">  signal(SIGINT,SIG_IGN); signal(SIGTERM,SIG_IGN);</span><br><span class=\"line\"></span><br><span class=\"line\">  logfile.Write(&quot;父进程退出，sig=%d。\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  TcpServer.CloseListen();    // 关闭监听的socket。</span><br><span class=\"line\"></span><br><span class=\"line\">  kill(0,15);     // 通知全部的子进程退出。</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 子进程退出函数。</span><br><span class=\"line\">void ChldEXIT(int sig)  </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 以下代码是为了防止信号处理函数在执行的过程中被信号中断。</span><br><span class=\"line\">  signal(SIGINT,SIG_IGN); signal(SIGTERM,SIG_IGN);</span><br><span class=\"line\"></span><br><span class=\"line\">  logfile.Write(&quot;子进程退出，sig=%d。\\n&quot;,sig);</span><br><span class=\"line\"></span><br><span class=\"line\">  TcpServer.CloseClient();    // 关闭客户端的socket。</span><br><span class=\"line\"></span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 登录。</span><br><span class=\"line\">bool ClientLogin()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\">  memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\"></span><br><span class=\"line\">  if (TcpServer.Read(strrecvbuffer,20)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;TcpServer.Read() failed.\\n&quot;); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 解析客户端登录报文。</span><br><span class=\"line\">  _xmltoarg(strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">  if ( (starg.clienttype!=1) &amp;&amp; (starg.clienttype!=2) )</span><br><span class=\"line\">    strcpy(strsendbuffer,&quot;failed&quot;);</span><br><span class=\"line\">  else</span><br><span class=\"line\">    strcpy(strsendbuffer,&quot;ok&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  if (TcpServer.Write(strsendbuffer)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;TcpServer.Write() failed.\\n&quot;); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  logfile.Write(&quot;%s login %s.\\n&quot;,TcpServer.GetIP(),strsendbuffer);</span><br><span class=\"line\">  </span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把xml解析到参数starg结构中</span><br><span class=\"line\">bool _xmltoarg(char *strxmlbuffer)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(&amp;starg,0,sizeof(struct st_arg));</span><br><span class=\"line\"></span><br><span class=\"line\">  // 不需要对参数做合法性判断，客户端已经判断过了。</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;clienttype&quot;,&amp;starg.clienttype);</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;ptype&quot;,&amp;starg.ptype);</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;clientpath&quot;,starg.clientpath);</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;andchild&quot;,&amp;starg.andchild);</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;matchname&quot;,starg.matchname);</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;srvpath&quot;,starg.srvpath);</span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;srvpathbak&quot;,starg.srvpathbak);</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;timetvl&quot;,&amp;starg.timetvl);</span><br><span class=\"line\">  if (starg.timetvl&gt;30) starg.timetvl=30;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;timeout&quot;,&amp;starg.timeout);</span><br><span class=\"line\">  if (starg.timeout&lt;50) starg.timeout=50;</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strxmlbuffer,&quot;pname&quot;,starg.pname,50);</span><br><span class=\"line\">  strcat(starg.pname,&quot;_srv&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 上传文件的主函数。</span><br><span class=\"line\">void RecvFilesMain()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  PActive.AddPInfo(starg.timeout,starg.pname);</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\">    memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\"></span><br><span class=\"line\">    PActive.UptATime();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 接收客户端的报文。</span><br><span class=\"line\">    // 第二个参数的取值必须大于starg.timetvl，小于starg.timeout。</span><br><span class=\"line\">    if (TcpServer.Read(strrecvbuffer,starg.timetvl+10)==false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.Write(&quot;TcpServer.Read() failed.\\n&quot;); return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 处理心跳报文。</span><br><span class=\"line\">    if (strcmp(strrecvbuffer,&quot;&lt;activetest&gt;ok&lt;/activetest&gt;&quot;)==0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      strcpy(strsendbuffer,&quot;ok&quot;);</span><br><span class=\"line\">      // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">      if (TcpServer.Write(strsendbuffer)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;TcpServer.Write() failed.\\n&quot;); return;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 处理上传文件的请求报文。</span><br><span class=\"line\">    if (strncmp(strrecvbuffer,&quot;&lt;filename&gt;&quot;,10)==0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      // 解析上传文件请求报文的xml。</span><br><span class=\"line\">      char clientfilename[301];  memset(clientfilename,0,sizeof(clientfilename));</span><br><span class=\"line\">      char mtime[21];            memset(mtime,0,sizeof(mtime));</span><br><span class=\"line\">      int  filesize=0;</span><br><span class=\"line\">      GetXMLBuffer(strrecvbuffer,&quot;filename&quot;,clientfilename,300);</span><br><span class=\"line\">      GetXMLBuffer(strrecvbuffer,&quot;mtime&quot;,mtime,19);</span><br><span class=\"line\">      GetXMLBuffer(strrecvbuffer,&quot;size&quot;,&amp;filesize);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 客户端和服务端文件的目录是不一样的，以下代码生成服务端的文件名。</span><br><span class=\"line\">      // 把文件名中的clientpath替换成srvpath，要小心第三个参数</span><br><span class=\"line\">      char serverfilename[301];  memset(serverfilename,0,sizeof(serverfilename));</span><br><span class=\"line\">      strcpy(serverfilename,clientfilename);</span><br><span class=\"line\">      UpdateStr(serverfilename,starg.clientpath,starg.srvpath,false);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 接收文件的内容。</span><br><span class=\"line\">      logfile.Write(&quot;recv %s(%d) ...&quot;,serverfilename,filesize);</span><br><span class=\"line\">      if (RecvFile(TcpServer.m_connfd,serverfilename,mtime,filesize)==true)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.WriteEx(&quot;ok.\\n&quot;);</span><br><span class=\"line\">        SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;result&gt;ok&lt;/result&gt;&quot;,clientfilename);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      else</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.WriteEx(&quot;failed.\\n&quot;);</span><br><span class=\"line\">        SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;result&gt;failed&lt;/result&gt;&quot;,clientfilename);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 把接收结果返回给对端。</span><br><span class=\"line\">      // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">      if (TcpServer.Write(strsendbuffer)==false)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        logfile.Write(&quot;TcpServer.Write() failed.\\n&quot;); return;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 接收文件的内容。</span><br><span class=\"line\">bool RecvFile(const int sockfd,const char *filename,const char *mtime,int filesize)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 生成临时文件名。</span><br><span class=\"line\">  char strfilenametmp[301];</span><br><span class=\"line\">  SNPRINTF(strfilenametmp,sizeof(strfilenametmp),300,&quot;%s.tmp&quot;,filename);</span><br><span class=\"line\"></span><br><span class=\"line\">  int  totalbytes=0;        // 已接收文件的总字节数。</span><br><span class=\"line\">  int  onread=0;            // 本次打算接收的字节数。</span><br><span class=\"line\">  char buffer[1000];        // 接收文件内容的缓冲区。</span><br><span class=\"line\">  FILE *fp=NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 创建临时文件。</span><br><span class=\"line\">  if ( (fp=FOPEN(strfilenametmp,&quot;wb&quot;))==NULL ) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(buffer,0,sizeof(buffer));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算本次应该接收的字节数。</span><br><span class=\"line\">    if (filesize-totalbytes&gt;1000) onread=1000;</span><br><span class=\"line\">    else onread=filesize-totalbytes;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 接收文件内容。</span><br><span class=\"line\">    if (Readn(sockfd,buffer,onread)==false) &#123; fclose(fp); return false; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把接收到的内容写入文件。</span><br><span class=\"line\">    fwrite(buffer,1,onread,fp);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算已接收文件的总字节数，如果文件接收完，跳出循环。</span><br><span class=\"line\">    totalbytes=totalbytes+onread;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (totalbytes==filesize) break;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 关闭临时文件。</span><br><span class=\"line\">  fclose(fp);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 重置文件的时间。</span><br><span class=\"line\">  UTime(strfilenametmp,mtime);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 把临时文件RENAME为正式的文件。</span><br><span class=\"line\">  if (RENAME(strfilenametmp,filename)==false) return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 下载文件的主函数。</span><br><span class=\"line\">void SendFilesMain()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  PActive.AddPInfo(starg.timeout,starg.pname);</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 调用文件下载的主函数，执行一次文件下载的任务。</span><br><span class=\"line\">    if (_tcpputfiles()==false) &#123; logfile.Write(&quot;_tcpputfiles() failed.\\n&quot;); return; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (bcontinue==false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      sleep(starg.timetvl);</span><br><span class=\"line\"></span><br><span class=\"line\">      if (ActiveTest()==false) break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PActive.UptATime();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 心跳。</span><br><span class=\"line\">bool ActiveTest()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\">  memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\"></span><br><span class=\"line\">  SPRINTF(strsendbuffer,sizeof(strsendbuffer),&quot;&lt;activetest&gt;ok&lt;/activetest&gt;&quot;);</span><br><span class=\"line\">  // logfile.Write(&quot;发送：%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">  if (TcpServer.Write(strsendbuffer)==false) return false; // 向服务端发送请求报文。</span><br><span class=\"line\"></span><br><span class=\"line\">  if (TcpServer.Read(strrecvbuffer,20)==false) return false; // 接收服务端的回应报文。</span><br><span class=\"line\">  // logfile.Write(&quot;接收：%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 文件下载的主函数，执行一次文件下载的任务。</span><br><span class=\"line\">bool _tcpputfiles()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  CDir Dir;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 调用OpenDir()打开starg.srvpath目录。</span><br><span class=\"line\">  if (Dir.OpenDir(starg.srvpath,starg.matchname,10000,starg.andchild)==false)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    logfile.Write(&quot;Dir.OpenDir(%s) 失败。\\n&quot;,starg.srvpath); return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  int delayed=0;        // 未收到对端确认报文的文件数量。</span><br><span class=\"line\">  int buflen=0;         // 用于存放strrecvbuffer的长度。</span><br><span class=\"line\"></span><br><span class=\"line\">  bcontinue=false;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(strsendbuffer,0,sizeof(strsendbuffer));</span><br><span class=\"line\">    memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 遍历目录中的每个文件，调用ReadDir()获取一个文件名。</span><br><span class=\"line\">    if (Dir.ReadDir()==false) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    bcontinue=true;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把文件名、修改时间、文件大小组成报文，发送给对端。</span><br><span class=\"line\">    SNPRINTF(strsendbuffer,sizeof(strsendbuffer),1000,&quot;&lt;filename&gt;%s&lt;/filename&gt;&lt;mtime&gt;%s&lt;/mtime&gt;&lt;size&gt;%d&lt;/size&gt;&quot;,Dir.m_FullFileName,Dir.m_ModifyTime,Dir.m_FileSize);</span><br><span class=\"line\"></span><br><span class=\"line\">    // logfile.Write(&quot;strsendbuffer=%s\\n&quot;,strsendbuffer);</span><br><span class=\"line\">    if (TcpServer.Write(strsendbuffer)==false)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.Write(&quot;TcpServer.Write() failed.\\n&quot;); return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把文件的内容发送给对端。</span><br><span class=\"line\">    logfile.Write(&quot;send %s(%d) ...&quot;,Dir.m_FullFileName,Dir.m_FileSize);</span><br><span class=\"line\">    if (SendFile(TcpServer.m_connfd,Dir.m_FullFileName,Dir.m_FileSize)==true)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.WriteEx(&quot;ok.\\n&quot;); delayed++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      logfile.WriteEx(&quot;failed.\\n&quot;); TcpServer.CloseClient(); return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PActive.UptATime();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 接收对端的确认报文。</span><br><span class=\"line\">    while (delayed&gt;0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\">      if (TcpRead(TcpServer.m_connfd,strrecvbuffer,&amp;buflen,-1)==false) break;</span><br><span class=\"line\">      // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 删除或者转存本地的文件。</span><br><span class=\"line\">      delayed--;</span><br><span class=\"line\">      AckMessage(strrecvbuffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 继续接收对端的确认报文。</span><br><span class=\"line\">  while (delayed&gt;0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(strrecvbuffer,0,sizeof(strrecvbuffer));</span><br><span class=\"line\">    if (TcpRead(TcpServer.m_connfd,strrecvbuffer,&amp;buflen,10)==false) break;</span><br><span class=\"line\">    // logfile.Write(&quot;strrecvbuffer=%s\\n&quot;,strrecvbuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 删除或者转存本地的文件。</span><br><span class=\"line\">    delayed--;</span><br><span class=\"line\">    AckMessage(strrecvbuffer);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 把文件的内容发送给对端。</span><br><span class=\"line\">bool SendFile(const int sockfd,const char *filename,const int filesize)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int  onread=0;        // 每次调用fread时打算读取的字节数。</span><br><span class=\"line\">  int  bytes=0;         // 调用一次fread从文件中读取的字节数。</span><br><span class=\"line\">  char buffer[1000];    // 存放读取数据的buffer。</span><br><span class=\"line\">  int  totalbytes=0;    // 从文件中已读取的字节总数。</span><br><span class=\"line\">  FILE *fp=NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 以&quot;rb&quot;的模式打开文件。</span><br><span class=\"line\">  if ( (fp=fopen(filename,&quot;rb&quot;))==NULL )  return false;</span><br><span class=\"line\"></span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(buffer,0,sizeof(buffer));</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算本次应该读取的字节数，如果剩余的数据超过1000字节，就打算读1000字节。</span><br><span class=\"line\">    if (filesize-totalbytes&gt;1000) onread=1000;</span><br><span class=\"line\">    else onread=filesize-totalbytes;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从文件中读取数据。</span><br><span class=\"line\">    bytes=fread(buffer,1,onread,fp);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把读取到的数据发送给对端。</span><br><span class=\"line\">    if (bytes&gt;0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      if (Writen(sockfd,buffer,bytes)==false) &#123; fclose(fp); return false; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算文件已读取的字节总数，如果文件已读完，跳出循环。</span><br><span class=\"line\">    totalbytes=totalbytes+bytes;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (totalbytes==filesize) break;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  fclose(fp);</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除或者转存本地的文件。</span><br><span class=\"line\">bool AckMessage(const char *strrecvbuffer)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char filename[301];</span><br><span class=\"line\">  char result[11];</span><br><span class=\"line\"></span><br><span class=\"line\">  memset(filename,0,sizeof(filename));</span><br><span class=\"line\">  memset(result,0,sizeof(result));</span><br><span class=\"line\"></span><br><span class=\"line\">  GetXMLBuffer(strrecvbuffer,&quot;filename&quot;,filename,300);</span><br><span class=\"line\">  GetXMLBuffer(strrecvbuffer,&quot;result&quot;,result,10);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 如果服务端接收文件不成功，直接返回。</span><br><span class=\"line\">  if (strcmp(result,&quot;ok&quot;)!=0) return true;</span><br><span class=\"line\"></span><br><span class=\"line\">  // ptype==1，删除文件。</span><br><span class=\"line\">  if (starg.ptype==1)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    if (REMOVE(filename)==false) &#123; logfile.Write(&quot;REMOVE(%s) failed.\\n&quot;,filename); return false; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // ptype==2，移动到备份目录。</span><br><span class=\"line\">  if (starg.ptype==2)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // 生成转存后的备份目录文件名。</span><br><span class=\"line\">    char bakfilename[301];</span><br><span class=\"line\">    STRCPY(bakfilename,sizeof(bakfilename),filename);</span><br><span class=\"line\">    UpdateStr(bakfilename,starg.srvpath,starg.srvpathbak,false);</span><br><span class=\"line\">    if (RENAME(filename,bakfilename)==false)</span><br><span class=\"line\">    &#123; logfile.Write(&quot;RENAME(%s,%s) failed.\\n&quot;,filename,bakfilename); return false; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"tcp编译\"><a href=\"#tcp编译\" class=\"headerlink\" title=\"tcp编译\"></a>tcp编译</h5><p>makefile</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 开发框架头文件路径。</span><br><span class=\"line\">PUBINCL = -I/project/public</span><br><span class=\"line\"></span><br><span class=\"line\"># 开发框架cpp文件名，这里直接包含进来，没有采用链接库，是为了方便调试。</span><br><span class=\"line\">PUBCPP = /project/public/_public.cpp</span><br><span class=\"line\"></span><br><span class=\"line\"># 编译参数。</span><br><span class=\"line\">CFLAGS = -g</span><br><span class=\"line\"></span><br><span class=\"line\">all:tcpputfiles fileserver tcpgetfiles </span><br><span class=\"line\"></span><br><span class=\"line\">tcpputfiles:tcpputfiles.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o tcpputfiles tcpputfiles.cpp $(PUBINCL) $(PUBCPP) -lm -lc</span><br><span class=\"line\">\tcp tcpputfiles ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">fileserver:fileserver.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o fileserver fileserver.cpp $(PUBINCL) $(PUBCPP) -lm -lc</span><br><span class=\"line\">\tcp fileserver ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">tcpgetfiles:tcpgetfiles.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o tcpgetfiles tcpgetfiles.cpp $(PUBINCL) $(PUBCPP) -lm -lc</span><br><span class=\"line\">\tcp tcpgetfiles ../bin/.</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -f tcpputfiles fileserver tcpgetfiles </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"mysql数据库开发\"><a href=\"#mysql数据库开发\" class=\"headerlink\" title=\"mysql数据库开发\"></a>mysql数据库开发</h4><h5 id=\"查看修改数据库字符集\"><a href=\"#查看修改数据库字符集\" class=\"headerlink\" title=\"查看修改数据库字符集\"></a>查看修改数据库字符集</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql -u root -p</span><br><span class=\"line\"></span><br><span class=\"line\">SHOW VARIABLES LIKE &#x27;character%&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">quit</span><br><span class=\"line\"></span><br><span class=\"line\">vi /etc/my.cnf</span><br><span class=\"line\"></span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\">character-set-server=utf8</span><br><span class=\"line\"> </span><br><span class=\"line\">[client]</span><br><span class=\"line\">default-character-set=utf8</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"A-查看修改数据库的字符集方式\"><a href=\"#A-查看修改数据库的字符集方式\" class=\"headerlink\" title=\"A. 查看修改数据库的字符集方式\"></a>A. 查看修改数据库的字符集方式</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- database_name 为数据库名称</span><br><span class=\"line\">SHOW CREATE DATABASE database_name;</span><br><span class=\"line\"></span><br><span class=\"line\">-- database_name 为数据库名称</span><br><span class=\"line\">-- utf8为目标字符编码</span><br><span class=\"line\">ALTER DATABSE database_name DEFAULT CHARACTER SET utf8;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"B-查看修改表的字符集方式\"><a href=\"#B-查看修改表的字符集方式\" class=\"headerlink\" title=\"B. 查看修改表的字符集方式\"></a>B. 查看修改表的字符集方式</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- table_name为表的名称</span><br><span class=\"line\">SHOW CREATE TABLE table_name;</span><br><span class=\"line\"></span><br><span class=\"line\">-- table_name为表的名称</span><br><span class=\"line\">-- utf8为目标字符编码</span><br><span class=\"line\">ALTER TABLE table_name DEFAULT CHARACTER SET utf8;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"C-查看字段的字符集方式\"><a href=\"#C-查看字段的字符集方式\" class=\"headerlink\" title=\"C. 查看字段的字符集方式\"></a>C. 查看字段的字符集方式</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- column_name为字段名称</span><br><span class=\"line\">SHOW FULL COLUMNS FROM column_name;</span><br><span class=\"line\"></span><br><span class=\"line\">-- table_name为表的名称</span><br><span class=\"line\">-- column_name为字段名称</span><br><span class=\"line\">-- varchar(20)为字段的类型</span><br><span class=\"line\">-- utf8为目标字符集</span><br><span class=\"line\">ALTER TABLE table_name CHANGE column_name column_name VARCHAR(20) CHARACTER SET utf8;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"D-同时修改表和表中所有字符类型的字段字符集方式\"><a href=\"#D-同时修改表和表中所有字符类型的字段字符集方式\" class=\"headerlink\" title=\"D. 同时修改表和表中所有字符类型的字段字符集方式\"></a>D. 同时修改表和表中所有字符类型的字段字符集方式</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- 例子：alter table user2 convert to character set utf8 collate utf8_general_ci;</span><br><span class=\"line\">ALTER TABLE tbl_name CONVERT TO CHARACTER SET character_name [COLLATE ...]</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h5><p>createtable.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  程序名：createtable.cpp，此程序演示开发框架操作MySQL数据库（创建表）。</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  connection conn;   // 数据库连接类。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。</span><br><span class=\"line\">  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span><br><span class=\"line\">  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 准备创建表的SQL语句。</span><br><span class=\"line\">  // 超女表girls，超女编号id，超女姓名name，体重weight，报名时间btime，超女说明memo，超女图片pic。</span><br><span class=\"line\">  stmt.prepare(&quot;create table girls(id      bigint(10),\\</span><br><span class=\"line\">                   name    varchar(30),\\</span><br><span class=\"line\">                   weight  decimal(8,2),\\</span><br><span class=\"line\">                   btime   datetime,\\</span><br><span class=\"line\">                   memo    longtext,\\</span><br><span class=\"line\">                   pic     longblob,\\</span><br><span class=\"line\">                   primary key (id))&quot;);</span><br><span class=\"line\">  /*</span><br><span class=\"line\">  1、int prepare(const char *fmt,...)，SQL语句可以多行书写。</span><br><span class=\"line\">  2、SQL语句最后的分号可有可无，建议不要写（兼容性考虑）。</span><br><span class=\"line\">  3、SQL语句中不能有说明文字。</span><br><span class=\"line\">  4、可以不用判断stmt.prepare()的返回值，stmt.execute()时再判断。</span><br><span class=\"line\">  */</span><br><span class=\"line\"></span><br><span class=\"line\">  // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span><br><span class=\"line\">  // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span><br><span class=\"line\">  if (stmt.execute()!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;create table girls ok.\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">-- 超女基本信息表。</span><br><span class=\"line\">create table girls(id      bigint(10),    -- 超女编号。</span><br><span class=\"line\">                   name    varchar(30),   -- 超女姓名。</span><br><span class=\"line\">                   weight  decimal(8,2),  -- 超女体重。</span><br><span class=\"line\">                   btime   datetime,      -- 报名时间。</span><br><span class=\"line\">                   memo    longtext,      -- 备注。</span><br><span class=\"line\">                   pic     longblob,      -- 照片。</span><br><span class=\"line\">                   primary key (id));</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h5><p>inserttable.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  程序名：inserttable.cpp，此程序演示开发框架操作MySQL数据库（向表中插入5条记录）。</span><br><span class=\"line\">*/</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  connection conn;   // 数据库连接类。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。</span><br><span class=\"line\">  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span><br><span class=\"line\">  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 定义用于超女信息的结构，与表中的字段对应。</span><br><span class=\"line\">  struct st_girls</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    long   id;        // 超女编号</span><br><span class=\"line\">    char   name[31];  // 超女姓名</span><br><span class=\"line\">    double weight;    // 超女体重</span><br><span class=\"line\">    char   btime[20]; // 报名时间</span><br><span class=\"line\">  &#125; stgirls;</span><br><span class=\"line\"></span><br><span class=\"line\">  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 准备插入表的SQL语句。</span><br><span class=\"line\">  stmt.prepare(&quot;\\</span><br><span class=\"line\">    insert into girls(id,name,weight,btime) values(:1+1,:2,:3+45.35,str_to_date(:4,&#x27;%%Y-%%m-%%d %%H:%%i:%%s&#x27;))&quot;);</span><br><span class=\"line\">    //insert into girls(id,name,weight,btime) values(?+1,?,?+45.35,to_date(?,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;))&quot;);</span><br><span class=\"line\">  /*</span><br><span class=\"line\">    注意事项：</span><br><span class=\"line\">    1、参数的序号从1开始，连续、递增，参数也可以用问号表示，但是，问号的兼容性不好，不建议；</span><br><span class=\"line\">    2、SQL语句中的右值才能作为参数，表名、字段名、关键字、函数名等都不能作为参数；</span><br><span class=\"line\">    3、参数可以参与运算或用于函数的参数；</span><br><span class=\"line\">    4、如果SQL语句的主体没有改变，只需要prepare()一次就可以了；</span><br><span class=\"line\">    5、SQL语句中的每个参数，必须调用bindin()绑定变量的地址；</span><br><span class=\"line\">    6、如果SQL语句的主体已改变，prepare()后，需重新用bindin()绑定变量；</span><br><span class=\"line\">    7、prepare()方法有返回值，一般不检查，如果SQL语句有问题，调用execute()方法时能发现；</span><br><span class=\"line\">    8、bindin()方法的返回值固定为0，不用判断返回值；</span><br><span class=\"line\">    9、prepare()和bindin()之后，每调用一次execute()，就执行一次SQL语句，SQL语句的数据来自被绑定变量的值。</span><br><span class=\"line\">  */</span><br><span class=\"line\">  stmt.bindin(1,&amp;stgirls.id);</span><br><span class=\"line\">  stmt.bindin(2, stgirls.name,30);</span><br><span class=\"line\">  stmt.bindin(3,&amp;stgirls.weight);</span><br><span class=\"line\">  stmt.bindin(4, stgirls.btime,19);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 模拟超女数据，向表中插入5条测试数据。</span><br><span class=\"line\">  for (int ii=0;ii&lt;5;ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stgirls,0,sizeof(struct st_girls));         // 结构体变量初始化。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为结构体变量的成员赋值。</span><br><span class=\"line\">    stgirls.id=ii;                                     // 超女编号。</span><br><span class=\"line\">    sprintf(stgirls.name,&quot;西施%05dgirl&quot;,ii+1);         // 超女姓名。</span><br><span class=\"line\">    stgirls.weight=ii;                                 // 超女体重。</span><br><span class=\"line\">    sprintf(stgirls.btime,&quot;2021-08-25 10:33:%02d&quot;,ii); // 报名时间。 </span><br><span class=\"line\"></span><br><span class=\"line\">    // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span><br><span class=\"line\">    // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span><br><span class=\"line\">    if (stmt.execute()!=0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;成功插入了%ld条记录。\\n&quot;,stmt.m_cda.rpc); // stmt.m_cda.rpc是本次执行SQL影响的记录数。</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;insert table girls ok.\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  conn.commit();   // 提交数据库事务。</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"修改数据\"><a href=\"#修改数据\" class=\"headerlink\" title=\"修改数据\"></a>修改数据</h5><p>updatetable.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  程序名：updatetable.cpp，此程序演示开发框架操作MySQL数据库（修改表中的记录）。</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  connection conn;   // 数据库连接类。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。</span><br><span class=\"line\">  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span><br><span class=\"line\">  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 定义用于超女信息的结构，与表中的字段对应。</span><br><span class=\"line\">  struct st_girls</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    long   id;        // 超女编号</span><br><span class=\"line\">    char   name[31];  // 超女姓名</span><br><span class=\"line\">    double weight;    // 超女体重</span><br><span class=\"line\">    char   btime[20]; // 报名时间</span><br><span class=\"line\">  &#125; stgirls;</span><br><span class=\"line\"></span><br><span class=\"line\">  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 准备修改表的SQL语句。</span><br><span class=\"line\">  stmt.prepare(&quot;\\</span><br><span class=\"line\">    update girls set name=:1,weight=:2,btime=str_to_date(:3,&#x27;%%Y-%%m-%%d %%H:%%i:%%s&#x27;) where id=:4&quot;);</span><br><span class=\"line\">  /*</span><br><span class=\"line\">    注意事项：</span><br><span class=\"line\">    1、参数的序号从1开始，连续、递增，参数也可以用问号表示，但是，问号的兼容性不好，不建议；</span><br><span class=\"line\">    2、SQL语句中的右值才能作为参数，表名、字段名、关键字、函数名等都不能作为参数；</span><br><span class=\"line\">    3、参数可以参与运算或用于函数的参数；</span><br><span class=\"line\">    4、如果SQL语句的主体没有改变，只需要prepare()一次就可以了；</span><br><span class=\"line\">    5、SQL语句中的每个参数，必须调用bindin()绑定变量的地址；</span><br><span class=\"line\">    6、如果SQL语句的主体已改变，prepare()后，需重新用bindin()绑定变量；</span><br><span class=\"line\">    7、prepare()方法有返回值，一般不检查，如果SQL语句有问题，调用execute()方法时能发现；</span><br><span class=\"line\">    8、bindin()方法的返回值固定为0，不用判断返回值；</span><br><span class=\"line\">    9、prepare()和bindin()之后，每调用一次execute()，就执行一次SQL语句，SQL语句的数据来自被绑定变量的值。</span><br><span class=\"line\">  */</span><br><span class=\"line\">  stmt.bindin(1, stgirls.name,30);</span><br><span class=\"line\">  stmt.bindin(2,&amp;stgirls.weight);</span><br><span class=\"line\">  stmt.bindin(3, stgirls.btime,19);</span><br><span class=\"line\">  stmt.bindin(4,&amp;stgirls.id);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 模拟超女数据，修改超女信息表中的全部记录。</span><br><span class=\"line\">  for (int ii=0;ii&lt;5;ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stgirls,0,sizeof(struct st_girls));         // 结构体变量初始化。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为结构体变量的成员赋值。</span><br><span class=\"line\">    stgirls.id=ii+1;                                   // 超女编号。</span><br><span class=\"line\">    sprintf(stgirls.name,&quot;貂蝉%05dgirl&quot;,ii+1);         // 超女姓名。</span><br><span class=\"line\">    stgirls.weight=ii+48.39;                           // 超女体重。</span><br><span class=\"line\">    sprintf(stgirls.btime,&quot;2021-10-02 11:25:%02d&quot;,ii); // 报名时间。 </span><br><span class=\"line\"></span><br><span class=\"line\">    // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span><br><span class=\"line\">    // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span><br><span class=\"line\">    if (stmt.execute()!=0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;成功修改了%ld条记录。\\n&quot;,stmt.m_cda.rpc); // stmt.m_cda.rpc是本次执行SQL影响的记录数。</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;update table girls ok.\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  conn.commit();   // 提交数据库事务。</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h5><p>selecttable.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  程序名：selecttable.cpp，此程序演示开发框架操作MySQL数据库（查询表中的记录）。</span><br><span class=\"line\">*/</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  connection conn;   // 数据库连接类。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。</span><br><span class=\"line\">  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span><br><span class=\"line\">  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 定义用于超女信息的结构，与表中的字段对应。</span><br><span class=\"line\">  struct st_girls</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    long   id;        // 超女编号</span><br><span class=\"line\">    char   name[31];  // 超女姓名</span><br><span class=\"line\">    double weight;    // 超女体重</span><br><span class=\"line\">    char   btime[20]; // 报名时间</span><br><span class=\"line\">  &#125; stgirls;</span><br><span class=\"line\"></span><br><span class=\"line\">  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">  int iminid,imaxid;  // 查询条件最小和最大的id。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 准备查询表的SQL语句。</span><br><span class=\"line\">  stmt.prepare(&quot;\\</span><br><span class=\"line\">    select id,name,weight,date_format(btime,&#x27;%%Y-%%m-%%d %%H:%%i:%%s&#x27;) from girls where id&gt;=:1 and id&lt;=:2&quot;);</span><br><span class=\"line\">  /*</span><br><span class=\"line\">    注意事项：</span><br><span class=\"line\">    1、如果SQL语句的主体没有改变，只需要prepare()一次就可以了；</span><br><span class=\"line\">    2、结果集中的字段，调用bindout()绑定变量的地址；</span><br><span class=\"line\">    3、bindout()方法的返回值固定为0，不用判断返回值；</span><br><span class=\"line\">    4、如果SQL语句的主体已改变，prepare()后，需重新用bindout()绑定变量；</span><br><span class=\"line\">    5、调用execute()方法执行SQL语句，然后再循环调用next()方法获取结果集中的记录；</span><br><span class=\"line\">    6、每调用一次next()方法，从结果集中获取一条记录，字段内容保存在已绑定的变量中。</span><br><span class=\"line\">  */</span><br><span class=\"line\">  // 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span><br><span class=\"line\">  stmt.bindin(1,&amp;iminid);</span><br><span class=\"line\">  stmt.bindin(2,&amp;imaxid);</span><br><span class=\"line\">  // 为SQL语句绑定输出变量的地址，bindout方法不需要判断返回值。</span><br><span class=\"line\">  stmt.bindout(1,&amp;stgirls.id);</span><br><span class=\"line\">  stmt.bindout(2, stgirls.name,30);</span><br><span class=\"line\">  stmt.bindout(3,&amp;stgirls.weight);</span><br><span class=\"line\">  stmt.bindout(4, stgirls.btime,19);</span><br><span class=\"line\"></span><br><span class=\"line\">  iminid=1;    // 指定待查询记录的最小id的值。</span><br><span class=\"line\">  imaxid=3;    // 指定待查询记录的最大id的值。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span><br><span class=\"line\">  // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span><br><span class=\"line\">  if (stmt.execute() != 0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。</span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stgirls,0,sizeof(struct st_girls));         // 结构体变量初始化。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从结果集中获取一条记录，一定要判断返回值，0-成功，1403-无记录，其它-失败。</span><br><span class=\"line\">    // 在实际开发中，除了0和1403，其它的情况极少出现。</span><br><span class=\"line\">    if (stmt.next()!=0) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把获取到的记录的值打印出来。</span><br><span class=\"line\">    printf(&quot;id=%ld,name=%s,weight=%.02f,btime=%s\\n&quot;,stgirls.id,stgirls.name,stgirls.weight,stgirls.btime);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span><br><span class=\"line\">  printf(&quot;本次查询了girls表%ld条记录。\\n&quot;,stmt.m_cda.rpc);</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h5><p>deletetable.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  程序名：deletetable.cpp，此程序演示开发框架操作MySQL数据库（删除表中的记录）。</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  connection conn;   // 数据库连接类。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。</span><br><span class=\"line\">  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span><br><span class=\"line\">  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">  int iminid,imaxid;  // 删除条件最小和最大的id。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 准备删除表的SQL语句。</span><br><span class=\"line\">  stmt.prepare(&quot;delete from girls where id&gt;=:1 and id&lt;=:2&quot;);</span><br><span class=\"line\">  // 为SQL语句绑定输入变量的地址，bindin方法不需要判断返回值。</span><br><span class=\"line\">  stmt.bindin(1,&amp;iminid);</span><br><span class=\"line\">  stmt.bindin(2,&amp;imaxid);</span><br><span class=\"line\"></span><br><span class=\"line\">  iminid=1;    // 指定待删除记录的最小id的值。</span><br><span class=\"line\">  imaxid=3;    // 指定待删除记录的最大id的值。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span><br><span class=\"line\">  // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span><br><span class=\"line\">  if (stmt.execute() != 0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span><br><span class=\"line\">  printf(&quot;本次删除了girls表%ld条记录。\\n&quot;,stmt.m_cda.rpc);</span><br><span class=\"line\"></span><br><span class=\"line\">  conn.commit();   // 提交数据库事务。</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"二进制大对象存放\"><a href=\"#二进制大对象存放\" class=\"headerlink\" title=\"二进制大对象存放\"></a>二进制大对象存放</h5><p>filetoblob.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  程序名：filetoblob.cpp，此程序演示开发框架操作MySQL数据库（把图片文件存入BLOB字段）。</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  connection conn;   // 数据库连接类。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。</span><br><span class=\"line\">  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span><br><span class=\"line\">  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 定义用于超女信息的结构，与表中的字段对应。</span><br><span class=\"line\">  struct st_girls</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    long   id;             // 超女编号</span><br><span class=\"line\">    char   pic[100000];    // 超女图片的内容。</span><br><span class=\"line\">    unsigned long picsize; // 图片内容占用的字节数。</span><br><span class=\"line\">  &#125; stgirls;</span><br><span class=\"line\"></span><br><span class=\"line\">  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 准备修改表的SQL语句。</span><br><span class=\"line\">  stmt.prepare(&quot;update girls set pic=:1 where id=:2&quot;);</span><br><span class=\"line\">  stmt.bindinlob(1, stgirls.pic,&amp;stgirls.picsize);</span><br><span class=\"line\">  stmt.bindin(2,&amp;stgirls.id);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 修改超女信息表中id为1、2的记录。</span><br><span class=\"line\">  for (int ii=1;ii&lt;3;ii++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stgirls,0,sizeof(struct st_girls));         // 结构体变量初始化。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 为结构体变量的成员赋值。</span><br><span class=\"line\">    stgirls.id=ii;                                   // 超女编号。</span><br><span class=\"line\">    // 把图片的内容加载到stgirls.pic中。</span><br><span class=\"line\">    if (ii==1) stgirls.picsize=filetobuf(&quot;1.jpg&quot;,stgirls.pic);</span><br><span class=\"line\">    if (ii==2) stgirls.picsize=filetobuf(&quot;2.jpg&quot;,stgirls.pic);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span><br><span class=\"line\">    // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span><br><span class=\"line\">    if (stmt.execute()!=0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;成功修改了%ld条记录。\\n&quot;,stmt.m_cda.rpc); // stmt.m_cda.rpc是本次执行SQL影响的记录数。</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;update table girls ok.\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  conn.commit();   // 提交数据库事务。</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"二进制大对象抽取\"><a href=\"#二进制大对象抽取\" class=\"headerlink\" title=\"二进制大对象抽取\"></a>二进制大对象抽取</h5><p>blobtofile.cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  程序名：blobtofile.cpp，此程序演示开发框架操作MySQL数据库（提取BLOB字段内容到图片文件中）。</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;_mysql.h&quot;       // 开发框架操作MySQL的头文件。</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc,char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  connection conn;   // 数据库连接类。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 登录数据库，返回值：0-成功；其它是失败，存放了MySQL的错误代码。</span><br><span class=\"line\">  // 失败代码在conn.m_cda.rc中，失败描述在conn.m_cda.message中。</span><br><span class=\"line\">  if (conn.connecttodb(&quot;127.0.0.1,root,phcQdNaiZ.g2,mysql,3306&quot;,&quot;utf8&quot;)!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;connect database failed.\\n%s\\n&quot;,conn.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 定义用于超女信息的结构，与表中的字段对应。</span><br><span class=\"line\">  struct st_girls</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    long   id;             // 超女编号</span><br><span class=\"line\">    char   pic[100000];    // 超女图片的内容。</span><br><span class=\"line\">    unsigned long picsize; // 图片内容占用的字节数。</span><br><span class=\"line\">  &#125; stgirls;</span><br><span class=\"line\"></span><br><span class=\"line\">  sqlstatement stmt(&amp;conn);  // 操作SQL语句的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">  // 准备查询表的SQL语句。</span><br><span class=\"line\">  stmt.prepare(&quot;select id,pic from girls where id in (1,2)&quot;);</span><br><span class=\"line\">  stmt.bindout(1,&amp;stgirls.id);</span><br><span class=\"line\">  stmt.bindoutlob(2, stgirls.pic,100000,&amp;stgirls.picsize);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 执行SQL语句，一定要判断返回值，0-成功，其它-失败。</span><br><span class=\"line\">  // 失败代码在stmt.m_cda.rc中，失败描述在stmt.m_cda.message中。</span><br><span class=\"line\">  if (stmt.execute()!=0)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    printf(&quot;stmt.execute() failed.\\n%s\\n%s\\n&quot;,stmt.m_sql,stmt.m_cda.message); return -1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 本程序执行的是查询语句，执行stmt.execute()后，将会在数据库的缓冲区中产生一个结果集。</span><br><span class=\"line\">  while (true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    memset(&amp;stgirls,0,sizeof(stgirls)); // 先把结构体变量初始化。</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从结果集中获取一条记录，一定要判断返回值，0-成功，1403-无记录，其它-失败。</span><br><span class=\"line\">    // 在实际开发中，除了0和1403，其它的情况极少出现。</span><br><span class=\"line\">    if (stmt.next()!=0) break;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 生成文件名。</span><br><span class=\"line\">    char filename[101]; memset(filename,0,sizeof(filename));</span><br><span class=\"line\">    sprintf(filename,&quot;%d_out.jpg&quot;,stgirls.id);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 把内容写入文件。</span><br><span class=\"line\">    buftofile(filename,stgirls.pic,stgirls.picsize);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 请注意，stmt.m_cda.rpc变量非常重要，它保存了SQL被执行后影响的记录数。</span><br><span class=\"line\">  printf(&quot;本次查询了girls表%ld条记录。\\n&quot;,stmt.m_cda.rpc);</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"编译文件-5\"><a href=\"#编译文件-5\" class=\"headerlink\" title=\"编译文件\"></a>编译文件</h5><p>makefile</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># mysql头文件存放的目录。locate mysql.h</span><br><span class=\"line\">MYSQLINCL = -I/usr/include/mysql</span><br><span class=\"line\"></span><br><span class=\"line\"># mysql库文件存放的目录。locate libmysqlclient.a</span><br><span class=\"line\">MYSQLLIB = -L/usr/lib64/mysql</span><br><span class=\"line\"></span><br><span class=\"line\">#_mysql.h _mysql.cpp在当前文件夹</span><br><span class=\"line\"></span><br><span class=\"line\"># 需要链接的mysql库。</span><br><span class=\"line\">MYSQLLIBS = -lmysqlclient</span><br><span class=\"line\"></span><br><span class=\"line\">CFLAGS=-g -Wno-write-strings</span><br><span class=\"line\"></span><br><span class=\"line\">all:createtable  inserttable updatetable selecttable deletetable filetoblob blobtofile book1 book2</span><br><span class=\"line\"></span><br><span class=\"line\">createtable:createtable.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o createtable createtable.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">inserttable:inserttable.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o inserttable inserttable.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">updatetable:updatetable.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o updatetable updatetable.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">selecttable:selecttable.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o selecttable selecttable.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">deletetable:deletetable.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o deletetable deletetable.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">filetoblob:filetoblob.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o filetoblob filetoblob.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">blobtofile:blobtofile.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o blobtofile blobtofile.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">book1:book1.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o book1 book1.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">book2:book2.cpp _mysql.h _mysql.cpp</span><br><span class=\"line\">\tg++ $(CFLAGS) -o book2 book2.cpp $(MYSQLINCL) $(MYSQLLIB) $(MYSQLLIBS) _mysql.cpp -lm -lc</span><br><span class=\"line\"></span><br><span class=\"line\">clean:</span><br><span class=\"line\">\trm -rf createtable  inserttable updatetable selecttable deletetable filetoblob blobtofile book1 book2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n","text":"C++开发public框架:心跳程序-框架中的心跳类_public.h// 信号量。class CSEM{private: union semun // 用于信...","permalink":"/post/cpp开发","photos":[],"count_time":{"symbolsCount":"103k","symbolsTime":"1:34"},"categories":[{"name":"开发经验","slug":"开发经验","count":8,"path":"api/categories/开发经验.json"}],"tags":[{"name":"C++","slug":"C","count":5,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">C++开发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#public%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">public框架:</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BF%83%E8%B7%B3%E7%A8%8B%E5%BA%8F-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%B3%E7%B1%BB\"><span class=\"toc-text\">心跳程序-框架中的心跳类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#public-h\"><span class=\"toc-text\">_public.h</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#public-cpp\"><span class=\"toc-text\">_public.cpp</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">调度程序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">编译文件</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">守护进程程序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6-1\"><span class=\"toc-text\">编译文件</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">压缩文件程序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6-2\"><span class=\"toc-text\">编译文件</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B8%85%E7%90%86%E6%96%87%E4%BB%B6%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">清理文件程序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6-3\"><span class=\"toc-text\">编译文件</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%8B%9F%E7%94%9F%E4%BA%A7%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">模拟生产测试数据文件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6-4\"><span class=\"toc-text\">编译文件</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ftp%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD\"><span class=\"toc-text\">ftp上传下载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85ftp\"><span class=\"toc-text\">安装ftp</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#ftp%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8B%E8%BD%BD\"><span class=\"toc-text\">ftp客户端下载</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#ftp%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E4%BC%A0\"><span class=\"toc-text\">ftp客户端上传</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#ftp%E7%BC%96%E8%AF%91\"><span class=\"toc-text\">ftp编译</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#TCP%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD\"><span class=\"toc-text\">TCP上传下载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#tcp%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E4%BC%A0\"><span class=\"toc-text\">tcp客户端上传</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#tcp%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8B%E8%BD%BD\"><span class=\"toc-text\">tcp客户端下载</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#tcp%E6%9C%8D%E5%8A%A1%E7%AB%AF\"><span class=\"toc-text\">tcp服务端</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#tcp%E7%BC%96%E8%AF%91\"><span class=\"toc-text\">tcp编译</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">mysql数据库开发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E7%AC%A6%E9%9B%86\"><span class=\"toc-text\">查看修改数据库字符集</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#A-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">A. 查看修改数据库的字符集方式</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#B-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">B. 查看修改表的字符集方式</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#C-%E6%9F%A5%E7%9C%8B%E5%AD%97%E6%AE%B5%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">C. 查看字段的字符集方式</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#D-%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E8%A1%A8%E5%92%8C%E8%A1%A8%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E6%AE%B5%E5%AD%97%E7%AC%A6%E9%9B%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">D. 同时修改表和表中所有字符类型的字段字符集方式</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E8%A1%A8\"><span class=\"toc-text\">创建表</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">插入数据</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">修改数据</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">查询数据</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">删除数据</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%94%BE\"><span class=\"toc-text\">二进制大对象存放</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%A4%A7%E5%AF%B9%E8%B1%A1%E6%8A%BD%E5%8F%96\"><span class=\"toc-text\">二进制大对象抽取</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6-5\"><span class=\"toc-text\">编译文件</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"暗使开开","slug":"blog-author","avatar":"\\favicon.ico","link":"/","description":"<p>即使是虚拟的也会开心</p>唯有终夜长开眼，报以平生未展眉","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/344723412"},"qq":{"icon":"/svg/qq.svg","link":"https://qm.qq.com/q/MXqKNejl6g"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"计算机的发展史","uid":"f18e335be203daef5375edd1ee27ca4d","slug":"计算机的发展史","date":"2022-08-28T16:00:00.000Z","updated":"2024-07-30T07:08:04.854Z","comments":true,"path":"api/articles/计算机的发展史.json","keywords":null,"cover":[],"text":"计算机的发展史一、计算机的产生和发展世界上第一台电子计算机 ENIAC(1946) 1946年 美国 ENIAC 1955年退役十进制运算18 000 多个电子...","permalink":"/post/计算机的发展史","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"计组","slug":"计组","count":7,"path":"api/tags/计组.json"}],"author":{"name":"暗使开开","slug":"blog-author","avatar":"\\favicon.ico","link":"/","description":"<p>即使是虚拟的也会开心</p>唯有终夜长开眼，报以平生未展眉","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/344723412"},"qq":{"icon":"/svg/qq.svg","link":"https://qm.qq.com/q/MXqKNejl6g"}}}}},"next_post":{"title":"计算机网络","uid":"293c17b4d2a4292133cc4d1ffd7f8725","slug":"计算机网络","date":"2022-07-29T16:00:00.000Z","updated":"2024-08-04T10:50:18.894Z","comments":true,"path":"api/articles/计算机网络.json","keywords":null,"cover":null,"text":"超五类网线接法橙白，橙，绿白，蓝，蓝白，绿，棕白，棕 VPN核心功能：用于建立安全的远程访问或在不同地点的网络之间建立加密通信。VPN（Virtual Priv...","permalink":"/post/计算机网络","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"计网","slug":"计网","count":1,"path":"api/categories/计网.json"}],"tags":[],"author":{"name":"暗使开开","slug":"blog-author","avatar":"\\favicon.ico","link":"/","description":"<p>即使是虚拟的也会开心</p>唯有终夜长开眼，报以平生未展眉","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/344723412"},"qq":{"icon":"/svg/qq.svg","link":"https://qm.qq.com/q/MXqKNejl6g"}}}}}}