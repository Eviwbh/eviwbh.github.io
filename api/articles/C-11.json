{"title":"C++","uid":"2d728caa47af746573cb7fba96b85d4f","slug":"C-11","date":"2024-07-29T16:00:00.000Z","updated":"2024-07-30T07:12:03.321Z","comments":true,"path":"api/articles/C-11.json","keywords":null,"cover":null,"content":"<h1 id=\"C-中map与unordered-map的区别\"><a href=\"#C-中map与unordered-map的区别\" class=\"headerlink\" title=\"C++中map与unordered_map的区别\"></a>C++中map与unordered_map的区别</h1><h2 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h2><ul>\n<li>map: <code>#include &lt;map&gt;</code></li>\n<li>unordered_map: <code>#include &lt;unordered_map&gt;</code></li>\n</ul>\n<h2 id=\"内部实现机理\"><a href=\"#内部实现机理\" class=\"headerlink\" title=\"内部实现机理\"></a>内部实现机理</h2><ul>\n<li>map： map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。</li>\n<li>unordered_map: <code>unordered_map</code>内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的</li>\n</ul>\n<p>unordered_map和map类似，都是存储的key-value的值，可以通过key快速索引到value。不同的是unordered_map不会根据key的大小进行排序，存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。</p>\n<p>所以使用时map的key需要定义<code>operator&lt;</code>。而unordered_map需要定义<code>hash_value</code>函数并且重载<code>operator==</code>。但是很多系统内置的数据类型都自带这些，那么如果是自定义类型，那么就需要自己重载<code>operator&lt;</code>或者<code>hash_value()</code>了。</p>\n<h2 id=\"优缺点以及适用处\"><a href=\"#优缺点以及适用处\" class=\"headerlink\" title=\"优缺点以及适用处\"></a>优缺点以及适用处</h2><table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">map</th>\n<th align=\"left\">unordered_map</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">优点</td>\n<td align=\"left\">有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作红黑树，内部实现一个红黑书使得map的很多操作在lgnlgn的时间复杂度下就可以实现，因此效率非常的高</td>\n<td align=\"left\">因为内部实现了哈希表，因此其查找速度非常的快</td>\n</tr>\n<tr>\n<td align=\"left\">缺点</td>\n<td align=\"left\">空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红&#x2F;黑性质，使得每一个节点都占用大量的空间</td>\n<td align=\"left\">哈希表的建立比较耗费时间</td>\n</tr>\n<tr>\n<td align=\"left\">适用处</td>\n<td align=\"left\">对于那些有顺序要求的问题，用map会更高效一些</td>\n<td align=\"left\">对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</td>\n</tr>\n</tbody></table>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>如果需要内部元素自动排序，使用<code>map</code>，不需要排序使用<code>unordered_map</code></p>\n<h2 id=\"note\"><a href=\"#note\" class=\"headerlink\" title=\"note:\"></a>note:</h2><p>对于<code>unordered_map</code>或者<code>unordered_set</code>容器，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照哈希表从前往后依次遍历的</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://blog.csdn.net/batuwuhanpei/article/details/50727227\">c++中map与unordered_map的区别</a></li>\n<li><a href=\"https://www.cnblogs.com/NeilZhang/p/5724996.html\">C++11 新特性： unordered_map 与 map 的对比</a></li>\n</ol>\n<h1 id=\"C-11之Lambda表达式\"><a href=\"#C-11之Lambda表达式\" class=\"headerlink\" title=\"C++ 11之Lambda表达式\"></a>C++ 11之Lambda表达式</h1><p>C++11的一大亮点就是引入了Lambda表达式。利用Lambda表达式，可以方便的定义和创建匿名函数,用以替换独立函数或者函数对象，并且使代码更可读。但是从本质上来讲，lambda表达式只是一种语法糖，因为所有其能完成的工作都可以用其它稍微复杂的代码来实现。但是它简便的语法却给C++带来了深远的影响。如果从广义上说，lamdba表达式产生的是函数对象。在类中，可以重载函数调用运算符()，此时类的对象可以将具有类似函数的行为，我们称这些对象为函数对象（Function Object）或者仿函数（Functor）。对于C++这门语言来说来说，“Lambda表达式”或“匿名函数”这些概念听起来好像很深奥，但很多高级语言在很早以前就已经提供了Lambda表达式的功能，如C#，Python等。今天，我们就来简单介绍一下C++中Lambda表达式的简单使用。</p>\n<h2 id=\"声明Lambda表达式\"><a href=\"#声明Lambda表达式\" class=\"headerlink\" title=\"声明Lambda表达式\"></a>声明Lambda表达式</h2><p>Lambda表达式完整的声明格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125; </span><br></pre></td></tr></table></figure>\n\n<p>各项具体含义如下</p>\n<ul>\n<li>capture list：捕获外部变量列表</li>\n<li>params list：形参列表</li>\n<li>mutable指示符：用来说用是否可以修改捕获的变量</li>\n<li>exception：异常设定</li>\n<li>return type：返回类型</li>\n<li>function body：函数体</li>\n</ul>\n<p>此外，我们还可以省略其中的某些成分来声明“不完整”的Lambda表达式，常见的有以下几种：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">格式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">[capture list] (params list) -&gt; return type {function body}</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">[capture list] (params list) {function body}</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">[capture list] {function body}</td>\n</tr>\n</tbody></table>\n<p>其中：</p>\n<ul>\n<li>格式1声明了const类型的表达式，这种类型的表达式不能修改捕获列表中的值。</li>\n<li>格式2省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型： （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定； （2）：如果function body中没有return语句，则返回值为void类型。</li>\n<li>格式3中省略了参数列表，类似普通函数中的无参函数。</li>\n</ul>\n<p>Lambda表达式的一个实例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">bool cmp(int a, int b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return  a &lt; b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vector&lt;int&gt; myvec&#123; 3, 2, 5, 7, 3, 2 &#125;;</span><br><span class=\"line\">    vector&lt;int&gt; lbvec(myvec);</span><br><span class=\"line\"></span><br><span class=\"line\">    sort(myvec.begin(), myvec.end(), cmp); // 旧式做法</span><br><span class=\"line\">    cout &lt;&lt; &quot;predicate function:&quot; &lt;&lt; endl;</span><br><span class=\"line\">    for (int it : myvec)</span><br><span class=\"line\">        cout &lt;&lt; it &lt;&lt; &#x27; &#x27;;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    sort(lbvec.begin(), lbvec.end(), [](int a, int b) -&gt; bool &#123; return a &lt; b; &#125;);   // Lambda表达式</span><br><span class=\"line\">    cout &lt;&lt; &quot;lambda expression:&quot; &lt;&lt; endl;</span><br><span class=\"line\">    for (int it : lbvec)</span><br><span class=\"line\">        cout &lt;&lt; it &lt;&lt; &#x27; &#x27;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在C++11之前，我们使用STL的sort函数，需要提供一个谓词函数。如果使用C++11的Lambda表达式，我们只需要传入一个匿名函数即可，方便简洁，而且代码的可读性也比旧式的做法好多了。</p>\n<p>下面，我们就重点介绍一下Lambda表达式各项的具体用法。</p>\n<h2 id=\"捕获外部变量\"><a href=\"#捕获外部变量\" class=\"headerlink\" title=\"捕获外部变量\"></a>捕获外部变量</h2><p>Lambda表达式可以使用其可见范围内的外部变量，但必须明确声明（明确声明哪些外部变量可以被该Lambda表达式使用）。那么，在哪里指定这些外部变量呢？Lambda表达式通过在最前面的方括号[]来明确指明其内部可以访问的外部变量，这一过程也称过Lambda表达式“捕获”了外部变量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int a = 123;</span><br><span class=\"line\">    auto f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class=\"line\">    f(); // 输出：123</span><br><span class=\"line\"></span><br><span class=\"line\">    //或通过“函数体”后面的‘()’传入参数</span><br><span class=\"line\">    auto x = [](int a)&#123;cout &lt;&lt; a &lt;&lt; endl;&#125;(123); </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>上面这个例子先声明了一个整型变量a，然后再创建Lambda表达式，该表达式“捕获”了a变量，这样在Lambda表达式函数体中就可以获得该变量的值。</p>\n<p>类似参数传递方式（值传递、引入传递、指针传递），在Lambda表达式中，外部变量的捕获方式也有值捕获、引用捕获、隐式捕获。</p>\n<h3 id=\"1、值捕获\"><a href=\"#1、值捕获\" class=\"headerlink\" title=\"1、值捕获\"></a>1、值捕获</h3><p>值捕获和参数传递中的值传递类似，被捕获的变量的值在Lambda表达式创建时通过值拷贝的方式传入，因此随后对该变量的修改不会影响影响Lambda表达式中的值。</p>\n<p>示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int a = 123;</span><br><span class=\"line\">    auto f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class=\"line\">    a = 321;</span><br><span class=\"line\">    f(); // 输出：123</span><br><span class=\"line\">&#125;  1 2 3 4 5 6 7 int main() &#123;    int a = 123;    auto f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;     a = 321;    f(); // 输出：123 &#125;   </span><br></pre></td></tr></table></figure>\n\n<p>*<strong>这里需要注意的是，如果以传值方式捕获外部变量，则在Lambda表达式函数体中不能修改该外部变量的值。*</strong></p>\n<h3 id=\"2、引用捕获\"><a href=\"#2、引用捕获\" class=\"headerlink\" title=\"2、引用捕获\"></a>2、引用捕获</h3><p>使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符 <code>&amp;</code>。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int a = 123;</span><br><span class=\"line\">    auto f = [&amp;a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class=\"line\">    a = 321;</span><br><span class=\"line\">    f(); // 输出：321</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n\n<p>从示例中可以看出，引用捕获的变量使用的实际上就是该引用所绑定的对象。</p>\n<h3 id=\"3、隐式捕获\"><a href=\"#3、隐式捕获\" class=\"headerlink\" title=\"3、隐式捕获\"></a>3、隐式捕获</h3><p>上面的值捕获和引用捕获都需要我们在捕获列表中显示列出Lambda表达式中使用的外部变量。除此之外，我们还可以让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获。隐式捕获有两种方式，分别是<code>[=]</code>和<code>[&amp;]</code>。<code>[=]</code>表示以值捕获的方式捕获外部变量，<code>[&amp;]</code>表示以引用捕获的方式捕获外部变量。</p>\n<p>隐式值捕获示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int a = 123;</span><br><span class=\"line\">    auto f = [=] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    // 值捕获</span><br><span class=\"line\">    f(); // 输出：123</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>隐式引用捕获示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int a = 123;</span><br><span class=\"line\">    auto f = [&amp;] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    // 引用捕获</span><br><span class=\"line\">    a = 321;</span><br><span class=\"line\">    f(); // 输出：321</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、混合方式\"><a href=\"#4、混合方式\" class=\"headerlink\" title=\"4、混合方式\"></a>4、混合方式</h3><p>上面的例子，要么是值捕获，要么是引用捕获，Lambda表达式还支持混合的方式捕获外部变量，这种方式主要是以上几种捕获方式的组合使用。</p>\n<p>到这里，我们来总结一下：C++11中的Lambda表达式捕获外部变量主要有以下形式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">捕获形式</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">[]</td>\n<td align=\"left\">不捕获任何外部变量</td>\n</tr>\n<tr>\n<td align=\"left\">[变量名, …]</td>\n<td align=\"left\">默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用<code>&amp;</code> 说明符）</td>\n</tr>\n<tr>\n<td align=\"left\">[this]</td>\n<td align=\"left\">以值的形式捕获this指针</td>\n</tr>\n<tr>\n<td align=\"left\">[&#x3D;]</td>\n<td align=\"left\">以值的形式捕获所有外部变量</td>\n</tr>\n<tr>\n<td align=\"left\">[&amp;]</td>\n<td align=\"left\">以引用形式捕获所有外部变量</td>\n</tr>\n<tr>\n<td align=\"left\">[&#x3D;, &amp;x]</td>\n<td align=\"left\">变量x以引用形式捕获，其余变量以传值形式捕获</td>\n</tr>\n<tr>\n<td align=\"left\">[&amp;, x]</td>\n<td align=\"left\">变量x以值的形式捕获，其余变量以引用形式捕获</td>\n</tr>\n</tbody></table>\n<h2 id=\"修改捕获变量\"><a href=\"#修改捕获变量\" class=\"headerlink\" title=\"修改捕获变量\"></a>修改捕获变量</h2><p>前面我们提到过，在Lambda表达式中，如果以传值方式捕获外部变量，则函数体中不能修改该外部变量，否则会引发编译错误。那么有没有办法可以修改值捕获的外部变量呢？这是就需要使用mutable关键字，该关键字用以说明表达式体内的代码可以修改值捕获的变量，示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int a = 123;</span><br><span class=\"line\">    auto f = [a]()mutable &#123; cout &lt;&lt; ++a; &#125;; // 不会报错</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl; // 输出：123</span><br><span class=\"line\">    f(); // 输出：124</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Lambda表达式的参数\"><a href=\"#Lambda表达式的参数\" class=\"headerlink\" title=\"Lambda表达式的参数\"></a>Lambda表达式的参数</h2><p>Lambda表达式的参数和普通函数的参数类似，那么这里为什么还要拿出来说一下呢？原因是在Lambda表达式中传递参数还有一些限制，主要有以下几点：</p>\n<ul>\n<li><ol>\n<li>参数列表中不能有默认参数</li>\n</ol>\n</li>\n<li><ol>\n<li>不支持可变参数</li>\n</ol>\n</li>\n<li><ol>\n<li>所有参数必须有参数名</li>\n</ol>\n</li>\n</ul>\n<p>常用举例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">　　　　 int m = [](int x) &#123; return [](int y) &#123; return y * 2; &#125;(x)+6; &#125;(5);</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;m:&quot; &lt;&lt; m &lt;&lt; std::endl;            　　//输出m:16</span><br><span class=\"line\"></span><br><span class=\"line\">        std::cout &lt;&lt; &quot;n:&quot; &lt;&lt; [](int x, int y) &#123; return x + y; &#125;(5, 4) &lt;&lt; std::endl;            //输出n:9</span><br><span class=\"line\">        </span><br><span class=\"line\">        auto gFunc = [](int x) -&gt; function&lt;int(int)&gt; &#123; return [=](int y) &#123; return x + y; &#125;; &#125;;</span><br><span class=\"line\">        auto lFunc = gFunc(4);</span><br><span class=\"line\">        std::cout &lt;&lt; lFunc(5) &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">        auto hFunc = [](const function&lt;int(int)&gt;&amp; f, int z) &#123; return f(z) + 1; &#125;;</span><br><span class=\"line\">        auto a = hFunc(gFunc(7), 8);</span><br><span class=\"line\"></span><br><span class=\"line\">        int a = 111, b = 222;</span><br><span class=\"line\">        auto func = [=, &amp;b]()mutable &#123; a = 22; b = 333; std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        func();</span><br><span class=\"line\">        std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">        a = 333;</span><br><span class=\"line\">        auto func2 = [=, &amp;a] &#123; a = 444; std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class=\"line\">        func2();</span><br><span class=\"line\"></span><br><span class=\"line\">        auto func3 = [](int x) -&gt;function&lt;int(int)&gt; &#123; return [=](int y) &#123; return x + y; &#125;; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    　　</span><br><span class=\"line\">　　　　 std::function&lt;void(int x)&gt; f_display_42 = [](int x) &#123; print_num(x); &#125;;</span><br><span class=\"line\">\tf_display_42(44);</span><br><span class=\"line\">　　&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>详细的使用方式可以参考<code>cppreference.com</code>的<code>Lambda 表达式 (C++11 起)</code>的文档说明。</p>\n<h2 id=\"参考-1\"><a href=\"#参考-1\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://www.cnblogs.com/DswCnblog/p/5629165.html\">C++ 11 Lambda表达式</a></li>\n<li><a href=\"https://zh.cppreference.com/w/cpp/language/lambda\">Lambda 表达式 (C++11 起)</a></li>\n</ol>\n<h1 id=\"C-阻止类被继承（继承类被实例化）的几种常用办法\"><a href=\"#C-阻止类被继承（继承类被实例化）的几种常用办法\" class=\"headerlink\" title=\"C++ 阻止类被继承（继承类被实例化）的几种常用办法\"></a>C++ 阻止类被继承（继承类被实例化）的几种常用办法</h1><p>不时会留意到有人问起如何阻止 C++ 中的类被继承，但多数人都没有把这个问题问对。</p>\n<p>在 C++11 标准之前，阻止类被继承在语法上是做不到的，大家通常做到的只是<code>继承而来的类不能被实例化了</code>。这样一来，继承得到的类就完全没有用了。虽然最终的效果一致，但对问题的理解其实是有差异的。</p>\n<p>从 C++11 标准开始，C++ 引入了一个新的关键字 <code>final</code>，只有被 <code>final</code> 修饰的类才能真正做到不能被继承。</p>\n<p>下面举例实现常用的以达到“不能被继承&#x2F;继承类不能被实例化”的几种手段。</p>\n<h2 id=\"私有化构造函数\"><a href=\"#私有化构造函数\" class=\"headerlink\" title=\"私有化构造函数\"></a>私有化构造函数</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Demo1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    static Demo1* Create()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return new Demo1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    // 注意：私有掉构造函数</span><br><span class=\"line\">    Demo1() &#123;&#125;</span><br><span class=\"line\">    Demo1(const Demo1&amp;);</span><br><span class=\"line\">    void operator=(const Demo1&amp;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Test1 : public Demo1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">//  Demo1*      pd1 = new Demo1;        // 错误：不能调用私有构造</span><br><span class=\"line\">    Demo1*      pd1 = Demo1::Create();</span><br><span class=\"line\">//  Test1*      pt1 = new Test1;        // 错误：不能调用基类私有构造</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用-虚继承-私有基类构造函数\"><a href=\"#使用-虚继承-私有基类构造函数\" class=\"headerlink\" title=\"使用 虚继承 + 私有基类构造函数\"></a>使用 虚继承 + 私有基类构造函数</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">class SealedT</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 注意：不是 friend class T;</span><br><span class=\"line\">    friend T;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    SealedT() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 注意：是虚继承</span><br><span class=\"line\">class Demo2 : virtual SealedT&lt;Demo2&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Demo2*      pd2 = new Demo2;</span><br><span class=\"line\">//  Test2*      pt2 = new Test2;        // 错误：不能访问间接虚基类</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用-虚继承-受保护的基类构造函数\"><a href=\"#使用-虚继承-受保护的基类构造函数\" class=\"headerlink\" title=\"使用 虚继承 + 受保护的基类构造函数\"></a>使用 虚继承 + 受保护的基类构造函数</h2><p>这个其实与前面一种形式是类似的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Sealed</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">    Sealed() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Demo3 : virtual Sealed</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Test3 : public Demo3</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Demo3*      pb3 = new Demo3;</span><br><span class=\"line\">//  Test3*      pt3 = new Test3;        // 错误：不能访问间接虚基类</span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用-final-关键字\"><a href=\"#使用-final-关键字\" class=\"headerlink\" title=\"使用 final 关键字\"></a>使用 final 关键字</h2><p>这个是最简单、最直接、最完美的。C++ 标准为啥如此晚才推出此功能。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Demo4 final</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 不能从被 final 修饰的类继承，编译失败</span><br><span class=\"line\">/*</span><br><span class=\"line\">class Test4 : public Demo4</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">*/  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考-2\"><a href=\"#参考-2\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://stackoverflow.com/questions/2184133/prevent-class-inheritance-in-c\">Prevent class inheritance in C++</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Virtual_inheritance\">Virtual inheritance</a></li>\n</ol>\n<h1 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h1><h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>(1): vector<int> ilist1;</p>\n<p>默认初始化，vector为空， size为0，表明容器中没有元素，而且 capacity 也返回 0，意味着还没有分配内存空间。这种初始化方式适用于元素个数未知，需要在程序中动态添加的情况。</p>\n<p>(2): vector<int> ilist2(ilist);</p>\n<p>vector<int> ilist2  &#x3D; ilist; </p>\n<p>两种方式等价 ，ilist2 初始化为ilist 的拷贝，ilist必须与ilist2 类型相同，也就是同为int的vector类型，ilist2将具有和ilist相同的容量和元素</p>\n<p>(3): vector<int> ilist &#x3D; {1,2,3.0,4,5,6,7};</p>\n<p> vector<int> ilist {1,2,3.0,4,5,6,7};</p>\n<p>ilist 初始化为列表中元素的拷贝，列表中元素必须与ilist的元素类型相容，本例中必须是与整数类型相容的类型，整形会直接拷贝，其他类型会进行类型转换。</p>\n<p>(4): vector<int> ilist3(ilist.begin()+2,ilist.end()-1);</p>\n<p>ilist3初始化为两个迭代器指定范围中元素的拷贝，范围中的元素类型必须与ilist3 的元素类型相容，在本例中ilist3被初始化为{3,4,5,6}。注意：由于只要求范围中的元素类型与待初始化的容器的元素类型相容，因此迭代器来自不同的容器是可能的，例如，用一个double的list的范围来初始化ilist3是可行的。另外由于构造函数只是读取范围中的元素进行拷贝，因此使用普通迭代器还是const迭代器来指出范围并没有区别。这种初始化方法特别适合于获取一个序列的子序列。</p>\n<p>(5): vector<int> ilist4(7);</p>\n<p>默认值初始化，ilist4中将包含7个元素，每个元素进行缺省的值初始化，对于int，也就是被赋值为0，因此ilist4被初始化为包含7个0。当程序运行初期元素大致数量可预知，而元素的值需要动态获取的时候，可采用这种初始化方式。</p>\n<p>(6):vector<int> ilist5(7,3);</p>\n<p>指定值初始化，ilist5被初始化为包含7个值为3的int</p>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><ul>\n<li><p>sort(vec.rbegin(), vec.rend());</p>\n<p>&#x2F;&#x2F;逆向排序 即按照从大到小的顺序进行排序   </p>\n</li>\n<li><p>sort(vec.begin(), vec.end());</p>\n<p>&#x2F;&#x2F;正向排序 即按照从小到大的顺序排序</p>\n</li>\n</ul>\n<h2 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h2><p>​\tvector<int> vec3;&#x2F;&#x2F;vec3是空的<br>​    vec3.insert(vec3.end(),vec1.begin(),vec1.end())&#x2F;&#x2F;将vec1压入<br>​    vec3.insert(vec3.end(),vec2.begin(),vec2.end())&#x2F;&#x2F;继续将vec2压入</p>\n","text":"C++中map与unordered_map的区别头文件 map: #include <map> unordered_map: #include <unorder...","permalink":"/post/C-11","photos":[],"count_time":{"symbolsCount":"9.8k","symbolsTime":"9 mins."},"categories":[{"name":"编程语言","slug":"编程语言","count":1,"path":"api/categories/编程语言.json"}],"tags":[{"name":"C++","slug":"C","count":1,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-%E4%B8%ADmap%E4%B8%8Eunordered-map%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">C++中map与unordered_map的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%B4%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">头文件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E6%9C%BA%E7%90%86\"><span class=\"toc-text\">内部实现机理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%98%E7%BC%BA%E7%82%B9%E4%BB%A5%E5%8F%8A%E9%80%82%E7%94%A8%E5%A4%84\"><span class=\"toc-text\">优缺点以及适用处</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E8%AE%BA\"><span class=\"toc-text\">结论</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#note\"><span class=\"toc-text\">note:</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-11%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">C++ 11之Lambda表达式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">声明Lambda表达式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">捕获外部变量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%80%BC%E6%8D%95%E8%8E%B7\"><span class=\"toc-text\">1、值捕获</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%BC%95%E7%94%A8%E6%8D%95%E8%8E%B7\"><span class=\"toc-text\">2、引用捕获</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%E3%80%81%E9%9A%90%E5%BC%8F%E6%8D%95%E8%8E%B7\"><span class=\"toc-text\">3、隐式捕获</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%B7%B7%E5%90%88%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">4、混合方式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">修改捕获变量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">Lambda表达式的参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83-1\"><span class=\"toc-text\">参考</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-%E9%98%BB%E6%AD%A2%E7%B1%BB%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%88%E7%BB%A7%E6%89%BF%E7%B1%BB%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%89%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%8A%9E%E6%B3%95\"><span class=\"toc-text\">C++ 阻止类被继承（继承类被实例化）的几种常用办法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A7%81%E6%9C%89%E5%8C%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">私有化构造函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-%E8%99%9A%E7%BB%A7%E6%89%BF-%E7%A7%81%E6%9C%89%E5%9F%BA%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">使用 虚继承 + 私有基类构造函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-%E8%99%9A%E7%BB%A7%E6%89%BF-%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%9F%BA%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">使用 虚继承 + 受保护的基类构造函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-final-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">使用 final 关键字</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83-2\"><span class=\"toc-text\">参考</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Vector\"><span class=\"toc-text\">Vector</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">初始化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">排序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%88%E5%B9%B6\"><span class=\"toc-text\">合并</span></a></li></ol></li></ol>","author":{"name":"暗使开开","slug":"blog-author","avatar":"\\favicon.ico","link":"/","description":"<p>即使是虚拟的也会开心</p>唯有终夜长开眼，报以平生未展眉","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/344723412"},"qq":{"icon":"/svg/qq.svg","link":"https://qm.qq.com/q/MXqKNejl6g"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"C++面试题","uid":"222b440dd80fa4c997be1565560f0d77","slug":"C面试题","date":"2024-07-30T03:50:33.000Z","updated":"2024-07-30T03:55:53.694Z","comments":true,"path":"api/articles/C面试题.json","keywords":null,"cover":[],"text":"C++面试题简述下 C++ 语言的特点 C++ 在 C 语言基础上引入了面对对象的机制，同时也兼容C语言。 C++ 有三大特性（1）封装（2）继承（3）多态。 ...","permalink":"/post/C面试题","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"暗使开开","slug":"blog-author","avatar":"\\favicon.ico","link":"/","description":"<p>即使是虚拟的也会开心</p>唯有终夜长开眼，报以平生未展眉","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/344723412"},"qq":{"icon":"/svg/qq.svg","link":"https://qm.qq.com/q/MXqKNejl6g"}}}}},"next_post":{"title":"Hexo","uid":"862ecabae65544f00e4a4f42f663a791","slug":"Hexo 基本操作","date":"2022-08-29T15:02:22.000Z","updated":"2024-07-30T04:13:44.174Z","comments":true,"path":"api/articles/Hexo 基本操作.json","keywords":null,"cover":null,"text":"Hexo 基本操作 hexo cl hexo new post markdown_name hexo g hexo d hexo s 上传日志到云服务器 or ...","permalink":"/post/Hexo 基本操作","photos":[],"count_time":{"symbolsCount":738,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"暗使开开","slug":"blog-author","avatar":"\\favicon.ico","link":"/","description":"<p>即使是虚拟的也会开心</p>唯有终夜长开眼，报以平生未展眉","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/344723412"},"qq":{"icon":"/svg/qq.svg","link":"https://qm.qq.com/q/MXqKNejl6g"}}}}}}