---
    title: 计算机的基本组成
    date: 2022-08-29 23:02:22 
    tags: 计组
---



# 计算机的基本组成

现在的计算机都是存储程序结构的计算机

## 一、冯·诺依曼计算机（以运算器为中心）的特点



![img](http://toomson.com:81/images/image-20220504004646123.png)



1. 计算机由五大部件组成（输入设备，运算器，控制器，存储器，输出设备）
2. 指令和数据以同等地位存于存储器，可按地址寻访
3. 指令和数据用二进制表示
4. 指令由操作码和地址码组成
5. 存储程序
6. 以运算器为中心

## 二、计算机硬件框图

### 1.计算机硬件框图（以存储器为中心）



![img](http://toomson.com:81/images/image-20220504005110646.png)



### 2.现代计算机硬件框图



![img](http://toomson.com:81/images/image-20220504005207613.png)



CPU：ALU（运算器），CU（控制器）

存储器：主存，副存

主机：CPU，存储器

I/O设备：输入设备，输出设备

硬件：主机系统，I/O设备

### 系统复杂性管理的方法-2（3’Y）

- 层次化（Hierachy）：将被设计的系统划分为多个模块或子模块
- 模块化（Modularity）：有明确定义（well-defined）的功能和接口
- 规则性（regularity）：模块更容易被重用

## 三、计算机的工作步骤

一个现实中的问题，如何用计算机来解决？

### 1. 上机前的准备

- 建立数学模型
- 编制解题程序
- 确定计算方法
  程序 —— 运算的 全部步骤
  指令 —— 每 一个步骤
- 编程举例：计算 ax2 + bx + c= (ax + b)x + c

1. 取x 至运算器中
2. 乘以x 在运算器中
3. 乘以a 在运算器中
4. 存ax2 在存储器中
5. 取b 至运算器中
6. 乘以x 在运算器中
7. 加ax2 在运算器中
8. 加c 在运算器中

或者

1. 取x 至运算器中
2. 乘以a 在运算器中
3. 加b 在运算器中
4. 乘以x 在运算器中
5. 加c 在运算器中

- 指令格式举例：操作码|地址码

| 指令和数据存于主存单元的地址 | 操作码       | 地址码          | 步骤             | 注释                        |
| :--------------------------- | :----------- | :-------------- | :--------------- | :-------------------------- |
| 0                            | 000001(取数) | 0000001000（α） | [α] ->ACC        | 取数x至ACC                  |
| 1                            | 000100(存数) | 0000001001(β)   | [ACC] -> β       | 乘a得ax ,存于ACC中          |
| 2                            | 000011(加)   | 0000001010(γ)   | [ACC]+[γ] -> ACC | 加b得ax+b ,存于ACC中        |
| 3                            | 000100(乘)   | 0000001000(δ)   | [ACC]×[δ] -> ACC | 乘x得（ax+b)x,存于ACC中     |
| 4                            | 000011       | 0000001011      |                  | 加c得ax2 + bx + c ,存于ACC  |
| 5                            | 000010       | 0000001100      |                  | 将ax2 + bx +c ,存于主存单元 |
| 6                            | 000011(打印) | 0000001011(o)   | [ o ] -> 打印机  | 打印                        |
| 7                            | 000110       |                 |                  | 停机                        |
| 8                            | x            |                 |                  | 原始数据x                   |
| 9                            | a            |                 |                  | 原始数据a                   |
| 10                           | b            |                 |                  | 原始数据b                   |
| 11                           | c            |                 |                  | 原始数据c                   |
| 12                           |              |                 |                  | 存放结果                    |

指令和数据都是保存在存储器中的

### 2.计算机的解题过程

#### 1. 存储器的基本组成



![img](http://toomson.com:81/images/image-20220504005332704.png)



存储器：存储体，MAR，MDR

- 存储体 -存储单元 -存储元件（0/1）
- 大楼 -房间 -床位（无人/有人）

| 存储单元   | 存放一串二进制代码         |
| :--------- | :------------------------- |
| 存储字     | 存储单元中二进制代码的组合 |
| 存储字长   | 存储单元中二进制代码的位数 |
| 按地址寻访 | 每个存储单元赋予一个地址号 |

MAR：存储器地址寄存器，反映存储单元（房间）的个数

MDR：存储器数据寄存器，反映存储字长

例如：MAR = 4 位 -> 存储单元个数 16
MDR = 8 位 -> 存储字长 8

#### 2. 运算器的基本组成及操作过程



![img](http://toomson.com:81/images/image-20220504005536012.png)



运算器：X->ALU<=>ACC<=>MQ

|      | ACC        | MQ           | X      |
| :--- | :--------- | :----------- | :----- |
| 加法 | 被加数和   |              | 加数   |
| 减法 | 被减数差   |              | 减数   |
| 乘法 | 乘积高位   | 乘数乘积低位 | 被乘法 |
| 除法 | 被除数余数 | 商           | 除法   |

ALU：算咯运算单元

① 加法操作过程



![img](http://toomson.com:81/images/image-20220504005601141.png)



| 指令          | 加                             | M                     |
| :------------ | :----------------------------- | :-------------------- |
| 初态ACC被加数 |                                | [M] -> X 把M中的值给X |
| 得到          | [ACC]+[X] -> ACC 运算结果给ACC |                       |

② 减法操作过程



![img](http://toomson.com:81/images/image-20220504005614149.png)



| 指令          | 减                             | M                     |
| :------------ | :----------------------------- | :-------------------- |
| 初态ACC被减数 |                                | [M] -> X 把M中的值给X |
| 得到          | [ACC]-[X] -> ACC 运算结果给ACC |                       |

③ 乘法操作过程



![img](http://toomson.com:81/images/image-20220504005625456.png)



| 指令                       | 乘                 | M         |
| :------------------------- | :----------------- | :-------- |
| 初态ACC被乘数              |                    | [M] -> MQ |
| [ACC] -> X把ACC的内容送到X | 0 -> ACC把ACC清零  |           |
| 得到                       | [X]*[MQ] -> ACC/MQ |           |

④ 除法操作过程



![img](http://toomson.com:81/images/image-20220504005636127.png)



| 指令          | 除              | M        |
| :------------ | :-------------- | :------- |
| 初态ACC被除数 |                 | [M] -> X |
| 得到          | [ACC]/[X] -> MQ |          |

余数在ACC中

#### 3.控制器的基本组成



![img](http://toomson.com:81/images/image-20220504005649872.png)



- 控制器：CU，IR，PC

- CU：控制单元

  PC: 存放当前欲执行指令的地址， 具有计数功能（PC）+ 1 -> PC

  IR: 存放当前欲执行的指令

完成一条指令：取指令PC -> 分析指令IR -> 执行指令CU

### 运算器、控制器、存储器构成了什么主机

- 一条指令在主机上的完成过程
- 程序在主机上是如何执行的

#### 4.主机完成一条指令的过程

##### 以取数指令为例



![img](http://toomson.com:81/images/image-20220504005710023.png)



1. PC把需要的指令的地址送给MAR（控制器上的PC中存放着要执行的指令的地址，指令保存在存储体当中）
2. MAR把地址送给存储体（在控制器的控制下，存储体把指定存储单元当中保存的取数指令取出来，送入MDR中）
3. 存储体把指定存储单元当中保存的取数指令取出来，给MDR中（MDR中现在就有了指令）
4. MDR把取出来的指令送给IR（IR存放当前欲执行的指令和当前指令操作数的地址）
5. 分析指令 IR送给CU
6. 从IR的地址码部分取出操作数地址送给MAR（CU控制IR把操作数地址送给MAR）
7. MAR把地址给存储体（在控制器的控制下，存储体把指定存储单元当中保存的取数指令要去的数取出来，）
8. 存储体把找到的数据给MDR
9. MDR送给运算器中的ACC

##### 以存数指令为例



![img](http://toomson.com:81/images/image-20220504005727581.png)



1. PC把需要的指令的地址送给MAR（控制器上的PC中存放着要执行的指令的地址，指令保存在存储体当中）
2. MAR把地址送给存储体（在控制器的控制下，存储体把指定存储单元当中保存的存数指令取出来，送入MDR中）
3. 存储体把指定存储单元当中保存的存数指令取出来，给MDR中（MDR中现在就有了指令）
4. MDR把取出来的指令送给IR（IR存放当前欲执行的指令和当前指令操作数的地址）
5. 分析指令 IR送给CU
6. 从IR的地址码部分取出操作数地址送给MAR（CU控制IR把操作数地址送给MAR）
7. MAR把地址给存储体（在控制器CU的控制下，MAR把地址给存储体，告诉存储体现在有一个数据要存进来，对应的地址是多少）
8. 运算器中ACC中的内容取出来送给MDR（CU控制）
9. MDR把得到的数据保存到存储体（在CU控制的控制之下把MDR中的数据保存的存储体对应的地址中）

#### ax2 + bx + c 程序的运行过程

- 将程序通过输入设备送至计算机

- 程序首地址 -> PC

- 启动程序运行

- 取指令 PC -> MAR -> M(存储体) -> MDR -> IR ,(PC)+1 -> PC

- 分析指令 OP(IR)(指令的操作码部分) -> CU

- 执行指令 Ad(IR)(指令的操作数部分) -> MAR -> M -> MDR -> ACC

  …

- 打印结果

- 停机